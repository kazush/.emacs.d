#+title: Emacs configuration
#+startup: content indent
#+property: header-args :tangle yes

*Note: This Emacs configuration required Emacs 29.1 or above.*

* Use-package integration with straight.el

Load ~use-package~ using straight.el

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+end_src

* Pre Init Config

Load preinit.org if exists.

#+begin_src emacs-lisp
(let ((preinit-file (expand-file-name "~/.emacs.d/preinit.org")))
  (when (file-exists-p preinit-file)
    (org-babel-load-file preinit-file)))
#+end_src

* Helper Macros and Functions

Some tiny macros to increase code readability and take care of the issue with
:if keyword not working with straight.el.

#+begin_src emacs-lisp
  (defmacro use-package-if (cond name &rest args)
    `(when ,cond
       (use-package ,name ,@args)))

  (defmacro when-use-exwm (&rest body)
    `(when (and (eq window-system 'x)
                (member (getenv "use_exwm") '("1" "yes")))
       (progn ,@body)))

  (defmacro when-not-use-exwm (&rest body)
    `(unless (and (eq window-system 'x)
                  (member (getenv "use_exwm") '("1" "yes")))
       (progn ,@body)))

  (defmacro use-package-if-exwm (name &rest args)
    `(when-use-exwm
      (use-package ,name ,@args)))

  (defmacro use-package-if-not-exwm (name &rest args)
    `(when-not-use-exwm
      (use-package ,name ,@args)))

  (defmacro use-package-if-gui (name &rest args)
    `(when window-system
       (use-package ,name ,@args)))
#+end_src

Tiny helper function to return file contents as string.

#+begin_src emacs-lisp
(defun my/get-file-contents (path)
  "return the contents of the file at PATH as string."
  (with-temp-buffer
    (insert-file-contents path)
    (buffer-string)))
#+end_src

* Basic config

Miscellaneous built-in features are configured and customzied here.

** Server

Start emacs server function so emacsclient processes can connect to this
instance. ~restart-server~ is a helper function to restart the server process.

#+begin_src emacs-lisp
  (require 'server)
  (defun my/restart-server ()
    "Restarts server."
    (interactive)
    (message "restarting server...")
    (server-force-stop)
    (server-force-delete)
    (server-start))

  ;; Workaround for the env where another Emacs instance is running on CRD.
  (when (getenv "CHROME_REMOTE_DESKTOP_SESSION")
    (setq server-name "crd"))

  (my/restart-server)
#+end_src

** Dired

A few tweaks to make dired work better for me.

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :custom
  ;; make file size format human-friendly
  (dired-listing-switches "-alh")
  :bind (:map dired-mode-map
              ("k" . dired-kill-subdir)))

(use-package wdired
  :straight (:type built-in)
  :custom
  (wdired-allow-to-change-permissions t))
#+end_src

** General editor preferences

Customization for miscellaneous built-in features.

#+begin_src emacs-lisp
;; Increase read buffer.
(setq read-process-output-max (* 8 1024 1024))
(setq process-adaptive-read-buffering t)

;; Use spaces for indentation.
(setq-default indent-tabs-mode nil)

;; Disable native-comp warnings.
(setq native-comp-async-report-warnings-errors 'silent)

;; Auto-save visited files every 30sec.
(setq auto-save-visited-interval 30)
(auto-save-visited-mode +1)

;; Set additional load-path.
(add-to-list 'load-path "~/lib/elisp")

;; No warning message when function is redefined by advice.
(setq ad-redefinition-action 'accept)

;; No duplicates in history.
(setq history-delete-duplicates t)

;; C-u SPC pops the last mark, afterwords no C-u is needed for further pops.
(setq set-mark-command-repeat-pop t)

(global-auto-revert-mode)
(transient-mark-mode t)
(show-paren-mode 1)

;; Show the paired paren at the top-right corner when it's off screen.
(setq show-paren-context-when-offscreen 'overlay)

;; Allows yanking text into an isearch without moving the mouse cursor to the
;; echo area.
(setq mouse-yank-at-point t)

;; Inhibit backups.
(setq backup-inhibited t)

;; Kill the whole line at start of line.
(setq kill-whole-line t)

:; Do not automatically add a newline.
(setq require-final-newline nil)

;; Increase size of log and history.
(setq message-log-max 10000)
(setq history-length 1000)

;; Disable novice restrictions.
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)

;; Fit within 80 columns by default.
(setq-default fill-column 80)
;; (add-hook 'text-mode-hook '(lambda () (auto-fill-mode 1)))

;; Do not truncate lines. I'd prefer wrapping lines.
(setq truncate-partial-width-windows nil)
(setq truncate-line nil)

;; Resolve symlinks.
(setq find-file-visit-truename t)

;; Shift key enables accelerated cursor movement on a per-word basis.
(require 'misc)
(global-set-key (kbd "C-S-f") 'forward-to-word)
(global-set-key (kbd "C-S-b") 'backward-word)

;; Display function name in mode line.
;; (which-function-mode 1)

;; Set language environment suitable for UTF-8 and Japanese.
(set-language-environment "UTF-8")
(prefer-coding-system 'japanese-shift-jis)
(prefer-coding-system 'utf-8)

;; Set Japanese to default input method for fcitx5.
(setopt default-input-method "japanese")

;; Enable winner-mode which does undo/redo of window configuration with C-c
;; left/right.
(winner-mode 1)

;; Automatically focus help and man windows when displayed.
(setq help-window-select t)
(setq Man-notify-method 'aggressive)

;; Add word-wrap-whitespace-mode to visual line mode so line wrapping works as
;; expected for non English text.
(add-hook 'visual-line-mode-hook #'word-wrap-whitespace-mode)

;; Preferences on isearch
(setq isearch-allow-scroll t)
(setq isearch-lazy-count t)

;; Disable saving active region to the primary selection.
;; This could cause Emacs to freeze especially if it's running in a container.
(setq select-active-regions nil)

#+end_src

Change the format of buffer name to /<unique dir suffix>/<filename>/.

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t)
(setq uniquify-ignore-buffers-re "^\\*")
#+end_src

** Electric Pair Mode
Enable electric pair mode now that I'm moving away from smartparens.

#+begin_src emacs-lisp
(use-package elec-pair
  :straight (:type built-in)
  :config
  (electric-pair-mode 1))
#+end_src

** Run chmod +x on save for script files

Emacs now has built-in function for this so I'll just use it instead of custom
code which is copied from [[http://www.namazu.org/~tsuchiya/elisp/][here]].

#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

;; Keep old code for now, but it'll be deleted in the future.
;; #'(lambda ()
;;     (save-restriction
;;       (widen)
;;       (if (string= "#!" (buffer-substring 1 (min 3 (point-max))))
;;           (let ((name (buffer-file-name)))
;;             (or
;;              (char-equal ?. (string-to-char
;;                              (file-name-nondirectory name)))
;;              (let ((mode (file-modes name)))
;;                (set-file-modes name
;;                                (logior mode (logand (/ mode 4) 73)))
;;                (message (concat "Wrote " name " (+x)"))))
;;             ))))
#+end_src

** Tramp

#+begin_src emacs-lisp
;; tramp to access remote files transparently
(use-package tramp
  :straight (:type built-in)
  :defer t
  :custom
  (tramp-default-method "ssh"))
#+end_src

** Ediff

TODO: watch [[https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/][this video]].

#+begin_src emacs-lisp
(use-package ediff
  :commands (ediff ediff3)
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally)
  :config
  (add-hook 'ediff-after-quit-hook-internal  #'winner-undo))
#+end_src

** Authinfo

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg"))
#+end_src

*** EasyPG

IIRC this is a workaround for some issues with authinfo that I don't
remember. Not sure if this is still needed to make authinfo work in my
environment.

#+begin_src emacs-lisp
(require 'epa-file)
(setq epa-pinentry-mode 'loopback)
#+end_src

** Plstore

#+begin_src emacs-lisp
(use-package plstore
  :straight (:type built-in)
  :custom
  (plstore-encrypt-to (getenv "PLSTORE_GPG_KEY")))
#+end_src

** EWW

#+begin_src emacs-lisp
(use-package eww
  :bind ( :map eww-mode-map
          ("c" . my/eww-org-roam-capture)
          ("j" . scroll-up-command)
          ("k" . scroll-down-command)
          ("N" . scroll-up-command)
          ("P" . scroll-down-command)
          ("v" . eww-browse-with-external-browser)
          ("T" . my/eww-toggle-auto-readable)
          :map eww-link-keymap
          ("v" . my/browse-url-at-point))
  :hook ((eww-after-render . my/eww-maybe-auto-readable)
         (eww-after-render . my/eww-set-initial-position))
  :config

  ;; Controls behaviour of auto readable feature.
  (defvar my/eww-enable-auto-readable t)
  (defun my/eww-toggle-auto-readable ()
    (interactive)
    (setq my/eww-enable-auto-readable (not my/eww-enable-auto-readable))
    (when (derived-mode-p 'eww-mode)
      (eww-reload)))

  ;; Regexp of URLS that readable mode should be automatically enabled for.
  (defvar my/eww-auto-readable-urls
    '("cnn.co.jp" "apnews.com" "doorblog.jp" "mql5.com" "gizmodo.jp"))

  ;; Automatically enable readable mode for the sites specified above.
  (defun my/eww-maybe-auto-readable ()
    (let ((url (eww-current-url))
          (pat-list my/eww-auto-readable-urls))
      (while-let ((pat (car pat-list)))
        (when (and my/eww-enable-auto-readable
                   (string-match-p pat url))
          (eww-readable)
          (setq pat-list nil))
        (setq pat-list (cdr pat-list)))))

  ;; alist of (<URL pattern> . <text pattern>).
  (defvar my/eww-set-initial-position-alist
    '(("reddit.com/" . "submitted .+ ago \\(\\* \\)?by ")
      ("news.yahoo.co.jp" . "JavaScriptの設定を変更する方法はこちら")
      ("www.bloomberg.co.jp" . "検索")))

  ;; Set initial position to directly get to the text of interest for the sites
  ;; specified above. (e.g. a site with many skippable lines at the top)
  (defun my/eww-set-initial-position ()
    (let ((url (eww-current-url))
          (alist my/eww-set-initial-position-alist))
      (while-let ((site-data (car alist)))
        (let ((url-pat (car site-data))
              (text-pat (cdr site-data)))
          (when (string-match-p url-pat url)
            (let ((p (search-forward-regexp text-pat nil t)))
              (when p
                (goto-char p)
                (beginning-of-line)
                (set-window-start nil (window-point))
                (setq alist nil))))
          (setq alist (cdr alist))))))

  (defun my/eww-org-roam-capture ()
    "Capture the current eww content to org-roam."
    (interactive)
    (let* ((title (plist-get eww-data :title))
           (link (plist-get eww-data :url))
           (node (org-roam-node-create :title title))
           (org-roam-capture-templates
            `(("d" "default - capture the current eww content"
               plain "\n%?\n\nlink: %a\n\n%c"
               :target (file+head "fleeting/${slug}.org"
                                  "#+title: ${title}\n")
               :unnarrowed t
               :kill-buffer t))))
      (org-eww-store-link)
      (org-eww-copy-for-org-mode)
      (org-roam-capture- :keys "d" :node node :info `(:ref ,link)))))
#+end_src

** SHR

This is a temporary measure. Set variables to try to avoid unwanted line breaks.

#+begin_src emacs-lisp
(use-package shr
  :bind (:map shr-map
              ("j" . scroll-up-command)
              ("k" . scroll-down-command)
              ("RET" . my/shr-browse-url-with-eww))
  :custom
  (shr-use-fonts nil)
  (shr-max-width 100000)
  (shr-fill-text nil)
  :config

  ;; Forcibly use EWW to browse a URL.
  (defun my/shr-browse-url-with-eww (&optional external mouse-event new-window)
    (interactive (list current-prefix-arg last-nonmenu-event))
    (let ((url (get-text-property (point) 'shr-url))
          (browse-url-browser-function #'eww-browse-url))
      (browse-url url)))
  )
#+end_src

** Browse URL

Add small wrappers so that I can launch intended browser as needed.

#+begin_src emacs-lisp
(defun my/browse-url-at-point-with-default-browser ()
  (interactive)
  (let ((browse-url-browser-function #'browse-url-default-browser))
    (call-interactively #'browse-url-at-point)))

(defun my/browse-url-at-point-with-eww ()
  (interactive)
  (let ((browse-url-browser-function #'eww-browse-url))
    (call-interactively #'browse-url-at-point)))

(defun my/browse-url-at-point (&optional arg)
  (interactive "P")
  (if arg (my/browse-url-at-point-with-eww)
    (my/browse-url-at-point-with-default-browser)))
#+end_src

** Image Converter

#+begin_src emacs-lisp
(setq image-use-external-converter t)
(setq image-converter--converters '((imagemagick :command "magick-elfeed" :probe ("-list" "format"))))
(setq image-converter 'imagemagick)
(setq image-converter-file-name-extensions '("avif"))

;; Add support of avif to take care of some sites returning missing
;; content-type header for avif.
(add-to-list 'image-type-header-regexps '("\\`\0\0\0 ftypavif" . image-convert))
(defun my/image-convert (orig image &optional format)
  (apply orig (list image (or (and (eq format t) 'image/avif) format))))
(advice-add 'image-convert :around #'my/image-convert)
#+end_src

** recentf

#+begin_src emacs-lisp
(use-package recentf
  :custom
  (recentf-max-saved-items 100)
  (recentf-exclude '("/org/roam/"))
  :config

  (add-to-list 'recentf-exclude
               (lambda (file)
                 (when (boundp 'org-agenda-files)
                   (member file org-agenda-files))))

  (recentf-mode))
#+end_src

** project and xref

If eglot is used, project and xref need to be loaded from built-in packages.

#+begin_src emacs-lisp
(use-package project
  :disabled
  :straight (:type built-in))

(use-package xref
  :disabled
  :straight (:type built-in))
#+end_src

** Scratch Buffer

Use pp for eval output.

#+begin_src emacs-lisp
(use-package elisp-mode
  :straight (:type built-in)
  :bind ( :map lisp-interaction-mode-map
          ("C-x C-e" . pp-eval-last-sexp)))
#+end_src

** save cursor positions
#+begin_src emacs-lisp
(use-package saveplace
  :straight (:type built-in)
  :config
  (save-place-mode))
#+end_src
* User Interface

Configure different features and settings that are related to user interface.

** Fonts and Faces

Face related settings are always in progress. The ~unless (daemonp)~ part is
probably a workaround to avoid errors when emacs is launched in daemon mode, but
I don't remember the reason.

Fonts and face settings are grouped into helper functions so that they can be
called in hooks.

#+begin_src emacs-lisp
(require 'font-lock)
(setq font-lock-maximum-decoration t)
(global-font-lock-mode t)

(defun my/setup-faces ()
  "Set faces for my preference."
  (interactive)
  (set-face-foreground 'default my/default-face-foreground)
  (set-face-background 'default
    (if my/transparent-bg-p
        (if window-system "#000000" "unspecified-bg")
      my/default-face-background))
  (set-face-attribute 'fixed-pitch nil
                      :family 'unspecified
                      :inherit 'default)
  (set-face-attribute 'fixed-pitch-serif nil
                      :family 'unspecified
                      :inherit 'default)
  (set-face-attribute 'region nil
                      :foreground 'unspecified
                      :background "#404068")
  (set-face-foreground 'show-paren-match "orange")
  (set-face-attribute 'font-lock-doc-face nil
                      :foreground "azure3"
                      :background 'unspecified)
  (set-face-attribute 'font-lock-comment-face nil
                      :foreground "azure4"
                      :background 'unspecified
                      :slant 'italic)
  (set-face-attribute 'font-lock-comment-delimiter-face nil
                      ;; :weight 'bold
                      :inherit 'font-lock-comment-face)
  (set-face-attribute 'font-lock-constant-face nil
                      :weight 'unspecified)
  (set-face-attribute 'highlight nil
                      ;; :foreground "orange"
                      ;; :background 'unspecified
                      :background "dark slate gray"
                      :weight 'bold)
  (set-face-attribute 'ansi-color-blue nil
                      :foreground "DodgerBlue")
  (set-face-attribute 'tab-bar nil
                      :family "Monospace"
                      :background "gray15"
                      :inherit 'unspecified)
  (set-face-attribute 'tab-bar-tab-inactive nil
                      :foreground "gray"
                      :background "gray15")
  (set-face-attribute 'tab-bar-tab nil
                      :foreground "white"
                      :background "gray20")
  (set-face-foreground 'font-lock-variable-name-face "khaki")
  (set-face-foreground 'font-lock-function-name-face "dodger blue")

  (set-face-attribute 'outline-1 nil :height 1.2)
  (set-face-attribute 'outline-2 nil :height 1.05)

  (custom-set-faces
   ;; ANSI colors
   '(ansi-color-black ((t :foreground "#2e3440" :background "#2e3440")))
   '(ansi-color-red ((t :foreground "#ff616a" :background "#ff616a")))
   '(ansi-color-green ((t :foreground "#a3be8c" :background "#a3be8c")))
   '(ansi-color-yellow ((t :foreground "#ebcb8b" :background "#4b2b1b")))
   '(ansi-color-blue ((t :foreground "#81a1f1" :background "#81a1f1")))
   '(ansi-color-magenta ((t :foreground "#b48ead" :background "#b48ead")))
   '(ansi-color-cyan ((t :foreground "#88c0d0" :background "#88c0d0")))
   '(ansi-color-white ((t :foreground "#e5e9f0" :background "#e5e9f0")))
   '(ansi-color-bright-black ((t :foreground "#4c566a" :background "#4c566a")))
   '(ansi-color-bright-red ((t :foreground "#ff616a" :background "#ff616a")))
   '(ansi-color-bright-green ((t :foreground "#a3be8c" :background "#a3be8c")))
   '(ansi-color-bright-yellow ((t :foreground "#ebcb8b" :background "#ebcb8b")))
   '(ansi-color-bright-blue ((t :foreground "#81a1f1" :background "#81a1f1")))
   '(ansi-color-bright-magenta ((t :foreground "#b48ead" :background "#b48ead")))
   '(ansi-color-bright-cyan ((t :foreground "#8fbcbb" :background "#8fbcbb")))
   '(ansi-color-bright-white ((t :foreground "#eceff4" :background "#eceff4")))
   ;; Highlighting for ediff/diff
   '(diff-header ((t :foreground "gray95" :background "gray20")))
   '(diff-file-header ((t :foreground "gray95" :background "gray30")))
   '(ediff-current-diff-A ((t :foreground "unspecified" :background "#403030")))
   '(ediff-current-diff-B ((t :foreground "unspecified" :background "#304030")))
   '(ediff-current-diff-C ((t :foreground "unspecified" :background "#404030")))
   '(ediff-fine-diff-A ((t :foreground "unspecified" :background "#504040")))
   '(ediff-fine-diff-B ((t :foreground "unspecified" :background "#405040")))
   '(ediff-fine-diff-C ((t :foreground "unspecified" :background "#505040")))
   '(ediff-even-diff-A ((t :foreground "unspecified" :background "#403030")))
   '(ediff-even-diff-B ((t :foreground "unspecified" :background "#304030")))
   '(ediff-even-diff-C ((t :foreground "unspecified" :background "#404030")))
   '(ediff-odd-diff-A ((t :foreground "unspecified" :background "#403030")))
   '(ediff-odd-diff-B ((t :foreground "unspecified" :background "#304030")))
   '(ediff-odd-diff-C ((t :foreground "unspecified" :background "#404030")))
   '(diff-refine-removed ((t :foreground "unspecified" :background "#504040")))
   '(diff-refine-added ((t :foreground "unspecified" :background "#405040")))
   '(diff-refine-changed ((t :foreground "unspecified" :background "#404030"))))

  (unless (daemonp)
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "darkgray"
                        :background "gray10"
                        :inherit 'mode-line)))

(defun my/set-fontset-emoji-font (&optional font size fset)
  "Set up color emoji font to a given FONTSET or fontset for default face."
  (let ((emoji-font (my/make-font-str (or font my/default-emoji-font) size))
        (fontset (or fset (face-attribute 'default :fontset))))
    (dolist (script '(symbol emoji))
      (set-fontset-font fontset script emoji-font nil 'prepend))))

(defun my/set-fontset-jp-font (&optional font size fset)
  "Set a given japanese FONT to a given fontset FSET or fontset for default face."
  (let ((font-xlfd (my/make-font-str (or font my/default-jp-font) size))
        (fontset (or fset (face-attribute 'default :fontset))))
    (dolist (script '(han kana cjk-misc cyrillic))
      (set-fontset-font fontset script font-xlfd nil))))

(defun my/setup-variable-font ()
  "Set up variable-pictch face for mixed font environments."
  (interactive)
  (let* ((base-font (my/make-font-str "Noto Serif" my/default-font-size))
         (suffix "serif")
         (fontset (format "fontset-%s" suffix)))
    ;; Create a new fontset called "fontset-serif".
    (create-fontset-from-ascii-font base-font nil suffix)
    ;; Set Japanese and emoji font to the fontset.
    (my/set-fontset-jp-font  "Noto Serif CJK JP" nil fontset)
    (my/set-fontset-emoji-font "Noto Color Emoji" nil fontset)
    ;; Set the fontset to variable-pitch
    (set-face-attribute 'variable-pitch nil
                        :font base-font
                        :fontset fontset)))

(defun my/setup-other-fonts ()
  "Set up non-default fontsets for my preference."
  (interactive)
  (setq use-default-font-for-symbols nil)
  (my/set-fontset-jp-font)
  (my/set-fontset-emoji-font)
  (my/setup-variable-font))

(defun my/setup-fonts ()
  "Set up all fontsets for my preference."
  (interactive)
  (my/setup-default-font)
  (my/setup-other-fonts))
#+end_src

** Misc display tweaks

Different tweaks on appearance.

#+begin_src emacs-lisp
;; Display time and load in the mode line.
(when-use-exwm
 (display-time-mode +1))

;; Display line and column numbers in the mode line.
(line-number-mode +1)
(column-number-mode +1)

;; Enable visual bell.
(setq visible-bell t)

;; Highlight line mode.
;; (use-package hl-line
;;   :hook ((org-mode-hook
;;          prog-mode-hook
;;          text-mode-hook
;;          yaml-mode-hook) . hl-line-mode)
;;   :config
;;   (set-face-attribute 'hl-line nil
;;                       :foreground 'unspecified
;;                       :background "gray15")
;;   )

;; Disable unnecessary features for some performance optimization.
(setq use-dialog-box nil)
(setq bidi-inhibit-bpa t)
(setq redisplay-skip-fontification-on-input t)
(setq-default indicate-empty-lines t)
(setq-default bidi-display-reordering 'left-to-right)

;; Somehow pixel scrolling does not work well yet.
;; (setq pixel-scroll-precision-use-momentum t)
;; (pixel-scroll-precision-mode)

;; Background transparency settings.
(defun my/set-transparency (enable &optional frame)
  "Set background transparency of default face."
  (interactive)
  (if enable
      (progn
        (if (not window-system)
            (set-face-background 'default "unspecified-bg")
          (set-frame-parameter frame 'alpha my/transparency)
          (set-face-background 'default "black"))
        (setq my/transparent-bg-p t))
    (when window-system
      (set-frame-parameter frame 'alpha 1.0))
    (set-face-background 'default my/default-face-background)
    (setq my/transparent-bg-p nil)))

(defun my/toggle-transparency ()
  "Toggle background transparency of default face."
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (my/set-transparency
     (if window-system
         (or (null alpha) (eql alpha 1.0))
       (string= (face-attribute 'default :background)
                my/default-face-background)))))
#+end_src

** Icons

*** nerd-icons

#+begin_src emacs-lisp
(use-package nerd-icons
  :straight (nerd-icons
             :type git
             :host github
             :repo "rainstormstudio/nerd-icons.el"
             :files (:defaults "data"))
  :custom
  ;; The Nerd Font you want to use in GUI
  ;; "Symbols Nerd Font Mono" is the default and is recommended
  ;; but you can use any other Nerd Font if you want
  (nerd-icons-font-family "Symbols Nerd Font Mono")
  )
#+end_src

** Keymaps

Create a dedicated keymap to group various commands with the same key
prefix. This way which-key will be more useful.

*** Editing

#+begin_src emacs-lisp
(define-prefix-command 'my/edit-map)
(global-set-key (kbd "C-c SPC") 'my/edit-map)
(define-key my/edit-map " " #'set-mark-command)
#+end_src

*** Window/Workspace Management

#+begin_src emacs-lisp
(define-prefix-command 'my/wm-map)
(global-set-key (kbd "C-c w") 'my/wm-map)
#+end_src

*** Information

#+begin_src emacs-lisp
(define-prefix-command 'my/info-map)
(global-set-key (kbd "C-c i") 'my/info-map)
#+end_src

*** Search

#+begin_src emacs-lisp
(define-prefix-command 'my/search-map)
(global-set-key (kbd "M-s /") 'my/search-map)
#+end_src

*** AI map

#+begin_src emacs-lisp
(define-prefix-command 'my/ai-map)
(global-set-key (kbd "C-c a") 'my/ai-map)
#+end_src

*** Misc

#+begin_src emacs-lisp
(define-prefix-command 'my/misc-map)
(global-set-key (kbd "C-q") 'my/misc-map)
(define-key my/misc-map (kbd "C-q") 'quoted-insert)
#+end_src

** Key bindings

#+begin_src emacs-lisp
;; Bind C-z to tab bar prefix to replace persp-mode with tab bar.
(global-set-key (kbd "C-z") tab-prefix-map)
 ;; Remap tab-rename as C-z r will be bound to my/consult-recent-file-other-tab
(define-key tab-prefix-map "R" #'tab-rename)
(defun my/new-tab-with-scratch ()
  (interactive)
  (switch-to-buffer-other-tab (get-scratch-buffer-create)))
(define-key tab-prefix-map "s" #'my/new-tab-with-scratch)

;; Change key translation map
;; - bind function of C-? (DEL) to C-h
;; - bind function of C-h (help) to C-]
(define-key key-translation-map [?\C-h] [?\C-?])
(define-key key-translation-map [?\C-\]] [?\C-h])

;; ibuffer
(global-set-key (kbd "C-x C-b") 'ibuffer)

;; Bind tabify and untabify.
(global-set-key (kbd "M-T") 'tabify)
(global-set-key (kbd "C-x T") 'untabify)

;; Make find-file-other-window the default behavior for find-file.
;; (global-set-key (kbd "C-x C-f") 'find-file-other-window)

;; Bind some commands often used under C-x keymap.
(global-set-key (kbd "C-x 5 k") 'delete-frame)
(global-set-key (kbd "C-x K") 'kill-buffer-and-window)
(global-set-key (kbd "C-x U") 'revert-buffer)
(global-set-key (kbd "C-x %") 'query-replace-regexp)

;; Make switch to next/prev buffer easier.
(global-set-key (kbd "C-x C-n") 'switch-to-next-buffer)
(global-set-key (kbd "C-x C-p") 'switch-to-prev-buffer)

;; Make switch to scratch buffer easier, but often I forgot the key binding.
(defun my/toggle-popup-scratch-buffer ()
  (interactive)
  (let* ((buf (get-scratch-buffer-create))
         (win (get-buffer-window buf)))
    (if win (delete-window win)
        (pop-to-buffer buf))))
(global-set-key (kbd "M-S") #'my/toggle-popup-scratch-buffer)

;; To be used along with scroll-other-window-up (M-C-v).
(global-set-key (kbd "M-V") #'scroll-other-window-down)

;; Comment out in favor of org-mode key bindings.
;; Move to another window with S-<arrow>.
;; (when (fboundp 'windmove-default-keybindings)
;;   (windmove-default-keybindings))

;; Move to another window with C-<arrow>.
(when window-system
  ;; (global-set-key (kbd "C-<left>") #'windmove-left)
  ;; (global-set-key (kbd "C-<down>") #'windmove-down)
  ;; (global-set-key (kbd "C-<up>") #'windmove-up)
  ;; (global-set-key (kbd "C-<right>") #'windmove-right)
  (global-set-key (kbd "s-h") #'windmove-left)
  (global-set-key (kbd "s-j") #'windmove-down)
  (global-set-key (kbd "s-k") #'windmove-up)
  (global-set-key (kbd "s-l") #'windmove-right)
  (global-set-key (kbd "s-n") #'switch-to-next-buffer)
  (global-set-key (kbd "s-p") #'switch-to-prev-buffer)
  (global-set-key (kbd "s-C") #'kill-buffer-and-window)
  (global-set-key (kbd "s-f") #'find-file-other-window))

;; Bind some commands often used under C-c keymap.
(global-set-key (kbd "C-c c") #'compile)
(global-set-key (kbd "C-c v") #'view-mode)
(global-set-key (kbd "C-c B") #'my/browse-url-at-point)
(global-set-key (kbd "C-c K") #'bury-buffer)
#+end_src

** Input Method

Disable GTK native input to allow toggling Mozc using the same key as Fcitx5.

#+begin_src emacs-lisp
(when (boundp 'x-gtk-use-native-input)
  (setq x-gtk-use-native-input nil))
#+end_src

Specify Japanese input method ~Mozc~ (which bases Google Japanese Input method).
Currently it is disabled as I don't want to build emacs-mozc on Arch.

#+begin_src emacs-lisp
(use-package mozc
  :custom
  (default-input-method "japanese-mozc")
  (mozc-candidate-style 'echo-area)
  :bind (("<hiragana-katakana>" . toggle-input-method)
         ("<henkan>" . toggle-input-method)
         ("S-SPC" . my/scroll-down-or-toggle-input-method)
         :map mozc-mode-map
         ("S-SPC" . my/deactivate-input-method)
         ("<henkan>" . my/deactivate-input-method)
         ("<hiragana-katakana>" . my/deactivate-input-method))
  :config
  (defun my/scroll-down-or-toggle-input-method ()
    "Scroll down in EAF browser buffer or toggle-input-method."
    (interactive)
    (if (and (derived-mode-p 'eaf-mode)
             (string= eaf--buffer-app-name "browser"))
        (eaf-py-proxy-scroll_down_page)
      (toggle-input-method)))

  (defun my/deactivate-input-method ()
    (interactive)
    (deactivate-input-method))

  (set-face-attribute 'mozc-preedit-selected-face nil
                      :foreground "#c0c0c0" :background "RoyalBlue4"))
#+end_src

#+begin_src emacs-lisp
(use-package mozc-cand-posframe
  :after mozc
  :config
  (setq mozc-candidate-style 'posframe)
  (set-face-attribute 'mozc-cand-posframe-normal-face nil
                      :foreground "#c0c0c0" :background "gray15")
  (set-face-attribute 'mozc-cand-posframe-focused-face nil
                      :foreground "#c0c0c0" :background "RoyalBlue4"))
#+end_src

** Misc input tweaks

#+begin_src emacs-lisp
;; wheel mouse support
(when window-system
  ;; enable wheelmouse support by default
  (mwheel-install)

  ;; make pasting utf8 text work
  (set-selection-coding-system 'utf-8))

;; Use shorter answer form (y or n).
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Modeline

#+begin_src emacs-lisp
;; Hide unnecessary mode information with Diminish.
(use-package diminish
  :config
  (diminish 'eldoc-mode))
#+end_src


*** doom-modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode))
#+end_src

** Setup UI look & feel

When running as daemon, apparently these functions need to be called whenever a
new emacsclient is connected hence ~server-after-make-frame-hook~ is set here.

#+begin_src emacs-lisp
(defun my/setup-ui ()
  "Sets up UI apperance."
  (interactive)
  ;; (menu-bar-mode -1)
  ;; (tool-bar-mode -1)
  (my/setup-faces)
  (when window-system
    ;; (scroll-bar-mode -1)
    ;; (fringe-mode 10)
    (my/setup-fonts)))

(defun my/setup-default-frame-bgcolor ()
  "To resolve the issue where the server cannot create a new X frame when the unspecified-bg (tty-specific value) is set to background."
  (interactive)
  (set-face-background 'default "black"))
(add-hook 'before-make-frame-hook #'my/setup-default-frame-bgcolor)

;; Hooks to forcibly reset UI for new frames by emacsclient.
(add-hook 'server-after-make-frame-hook 'my/setup-ui)

;; Initialize UI appearance for my preference.
(unless (daemonp)
  (my/setup-ui))
#+end_src

** Key binding guidance

*** Which Key

I'm trying out which-key to see how useful key guidance is for me.

#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :bind (("C-h /" . which-key-show-major-mode))
  :config
  ;; Enable which-key through manual activation with C-h only.
  (setq which-key-show-early-on-C-h t)
  (setq which-key-idle-delay 10000)
  (setq which-key-idle-secondary-delay 0.05)
  (which-key-mode))
#+end_src

*** Hydra

Hydra provides modal feature with key guidance, which is sometimes very useful
as you don't have to keep holding ctrl key.

#+begin_src emacs-lisp
(use-package hydra
  :bind (("C-c v" . my/hydra-move/body)
         ("M-g n" . my/hydra-next-error/body)
         :map my/wm-map
         ("r" . my/hydra-rectangle/body)
         ("w" . my/hydra-window/body)
         :map dired-mode-map
         ("." . my/hydra-dired/body))
  :config
  (require 'hydra-examples)

  ;; Here is my lazy cursor navigation setting I use when viewing a long file.

  (defun my/forward-to-symbol (arg)
    "Move forward until encountering the beginning of a symbol.
  With argument, do this that many times."
    (interactive "^p")
    (or (re-search-forward "\\W\\_<" nil t arg)
        (goto-char (if (> arg 0) (point-max) (point-min)))))

  (defun my/backward-to-symbol (arg)
    "Move backward until encountering the end of a symbol.
  With argument, do this that many times."
    (interactive "^p")
    (my/forward-to-symbol (- arg)))

  ;; Cursor movement
  (defhydra my/hydra-move (nil nil)
    "move"
    ("l" my/forward-to-symbol)
    ("h" my/backward-to-symbol)
    ("e" move-end-of-line)
    ("a" move-beginning-of-line)
    ("j" next-line)
    ("k" previous-line)
    ("n" forward-paragraph)
    ("p" backward-paragraph)
    ("SPC" scroll-up-command)
    ("N" scroll-up-command)
    ("S-SPC" scroll-down-command)
    ("P" scroll-down-command)
    ("q" nil))

  ;; window management
  (defun my/window-split-vertical ()
    (interactive)
    (split-window-right)
    (windmove-right))

  (defun my/window-split-horizontal ()
    (interactive)
    (split-window-below)
    (windmove-down))

  (defhydra my/hydra-window (nil nil :color red :hint nil)
    "
   Split: _v_ert _x_:horz
  Delete: _o_nly  _da_ce  _dw_indow  _db_uffer  _df_rame
    Move: _s_wap
  Frames: _f_rame new  _df_ delete
    Misc: _a_ce  _u_ndo  _r_edo"
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)
    ("H" (hydra-move-splitter-left 4))
    ("J" (hydra-move-splitter-down 4))
    ("K" (hydra-move-splitter-up 4))
    ("L" (hydra-move-splitter-right 4))
    ("|" my/window-split-vertical)
    ("_" my/window-split-horizontal)
    ("v" split-window-right)
    ("x" split-window-below)
    ;; winner-mode must be enabled
    ("u" winner-undo)
    ("r" winner-redo) ;;Fi
    ("o" delete-other-windows :exit t)
    ("a" ace-window :exit t)
    ("f" make-frame :exit t)
    ("s" ace-swap-window)
    ("da" ace-delete-window)
    ("dw" delete-window)
    ("db" kill-this-buffer)
    ("df" delete-frame :exit t)
    ("q" nil))

  (defhydra my/hydra-rectangle (nil nil
                                    :body-pre (rectangle-mark-mode 1)
                                    :color pink
                                    :hint nil
                                    :post (deactivate-mark))
    "
    ^_k_^       _w_ copy      _o_pen       _N_umber-lines            |\\     -,,,--,,_
  _h_   _l_     _y_ank        _t_ype       _e_xchange-point          /,`.-'`'   ..  \-;;,_
    ^_j_^       _d_ kill      _c_lear      _r_eset-region-mark      |,4-  ) )_   .;.(  `'-'
  ^^^^          _u_ndo        _q_ quit     ^ ^                     '---''(./..)-'(_\_)
  "
    ("k" rectangle-previous-line)
    ("j" rectangle-next-line)
    ("h" rectangle-backward-char)
    ("l" rectangle-forward-char)
    ("d" kill-rectangle)                    ;; C-x r k
    ("y" yank-rectangle)                    ;; C-x r y
    ("w" copy-rectangle-as-kill)            ;; C-x r M-w
    ("o" open-rectangle)                    ;; C-x r o
    ("t" string-rectangle)                  ;; C-x r t
    ("c" clear-rectangle)                   ;; C-x r c
    ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
    ("N" rectangle-number-lines)            ;; C-x r N
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("u" undo nil)
    ("q" nil))

  (defhydra my/hydra-next-error (nil nil)
    "
  Compilation errors:
  _j_: next error        _h_: first error    _q_uit
  _k_: previous error    _l_: last error
  "
    ("`" next-error     nil)
    ("j" next-error     nil :bind nil)
    ("k" previous-error nil :bind nil)
    ("h" first-error    nil :bind nil)
    ("l" (condition-case err
             (while t
               (next-error))
           (user-error nil))
     nil :bind nil)
    ("q" nil            nil :color blue))

  (defhydra my/hydra-dired (nil nil
                             :hint nil
                             :color pink)
    "
  _+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
  _C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
  _D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
  _R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
  _Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
  _S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
  _r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
  _z_ compress-file  _A_ find regexp
  _Z_ compress       _Q_ repl regexp

  T - tag prefix
  "
    ("\\" dired-do-ispell)
    ("(" dired-hide-details-mode)
    (")" dired-omit-mode)
    ("+" dired-create-directory)
    ("=" diredp-ediff)         ;; smart diff
    ("?" dired-summary)
    ("$" diredp-hide-subdir-nomove)
    ("A" dired-do-find-regexp)
    ("C" dired-do-copy)        ;; Copy all marked files
    ("D" dired-do-delete)
    ("E" dired-mark-extension)
    ("e" dired-ediff-files)
    ("F" dired-do-find-marked-files)
    ("G" dired-do-chgrp)
    ("g" revert-buffer)        ;; read all directories again (refresh)
    ("i" dired-maybe-insert-subdir)
    ("l" dired-do-redisplay)   ;; relist the marked or singel directory
    ("M" dired-do-chmod)
    ("m" dired-mark)
    ("O" dired-display-file)
    ("o" dired-find-file-other-window)
    ("Q" dired-do-find-regexp-and-replace)
    ("R" dired-do-rename)
    ("r" dired-do-rsynch)
    ("S" dired-do-symlink)
    ("s" dired-sort-toggle-or-edit)
    ("t" dired-toggle-marks)
    ("U" dired-unmark-all-marks)
    ("u" dired-unmark)
    ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
    ("w" dired-kill-subdir)
    ("Y" dired-do-relsymlink)
    ("z" diredp-compress-this-file)
    ("Z" dired-do-compress)
    ("q" nil)
    ("." nil :color blue))
  )
#+end_src

** Highlighting

*** goggles

goggles is now used instead of volatile-highlights.

#+begin_src emacs-lisp
(use-package goggles
  :hook ((prog-mode text-mode) . goggles-mode)
  :config
  (setq-default goggles-pulse t)) ;; set to nil to disable pulsing
#+end_src

** Narrowing

#+begin_src emacs-lisp
(use-package fancy-narrow
  :disabled
  :bind (:map my/edit-map
              ("n" . my/hydra-narrow/body))
  :hook (prog-mode . fancy-narrow-mode)
  :commands (fancy-narrow-to-region
             fancy-widen
             fancy-narrow-to-page
             org-fancy-narrow-to-block
             org-fancy-narrow-to-element
             org-fancy-narrow-to-subtree)
  :config
  (defhydra my/hydra-narrow (:hint nil)
    "
  Narrow To: _r_: region _p_: page    _d_: defun
  Org: _b_: block  _e_: element _s_: subtree
       _w_: widen   _q_: quit
  "
    ("r" fancy-narrow-to-region)
    ("w" fancy-widen)
    ("p" fancy-narrow-to-page)
    ("d" fancy-narrow-to-defun)
    ("b" org-fancy-narrow-to-block)
    ("e" org-fancy-narrow-to-element)
    ("s" org-fancy-narrow-to-subtree)
    ("q" nil)))
#+end_src

** Tab bar

#+begin_src emacs-lisp
(use-package tab-bar
  :bind ( :map tab-prefix-map
          ("C-n" . tab-next)
          ("C-p" . tab-previous)
          ("k" . my/tab-bar-kill-buffer-and-tab)
          ("o" . tab-bar-switch-to-recent-tab)
          ("w" . tab-bar-move-window-to-tab)
          ("!" . tab-close-other)
          ("1" . my/tab-bar-switch-to-1)
          ("2" . my/tab-bar-switch-to-2)
          ("3" . my/tab-bar-switch-to-3)
          ("4" . my/tab-bar-switch-to-4)
          ("5" . my/tab-bar-switch-to-5)
          ("6" . my/tab-bar-switch-to-6)
          ("7" . my/tab-bar-switch-to-7)
          ("8" . my/tab-bar-switch-to-8)
          ("9" . my/tab-bar-switch-to-9))
  :custom
  (tab-bar-close-button-show nil)
  (tab-bar-new-button-show nil)
  (tab-bar-auto-width-max '((150) 15))
  :config

  (defun my/tab-bar-kill-buffer-and-tab ()
    "Kill current buffer and its tab."
    (interactive)
    (kill-buffer)
    (tab-close))

  ;; Create shortcuts for switching to a specified tab.
  (dotimes (num 9 t)
    (fset (intern (format "my/tab-bar-switch-to-%d" (1+ num)))
          `(lambda () (interactive)
             (ignore-errors
               (tab-bar-select-tab ,(1+ num)))))))
#+end_src

** Ultra Scroll

#+begin_src emacs-lisp
(use-package ultra-scroll
  :straight (:type git :host github :repo "jdtsmith/ultra-scroll")
  :init
  (setq scroll-conservatively 101 ; important!
        scroll-margin 0)
  :config
  (ultra-scroll-mode 1))
#+end_src

** Dimmer

#+begin_src emacs-lisp
(use-package dimmer
  :disabled
  :straight (:type git :host github :repo "gonewest818/dimmer.el")
  :custom
  (dimmer-fraction 0.25)
  :config

;; Prevent dimming when transient elements like child frames or posframes are active.
(defun my/dimmer-process-all-predicates (orig-fn &rest args)
    "Avoid invoking dimmer-process-all in certain situations."
    (cond
     ((let ((frame (frame-parameter (frame-parent) 'lsp-ui-doc-frame)))
        (and frame (frame-visible-p frame)))
      nil)
     ((and (boundp 'corfu--frame)
           (not (null corfu--frame))
           (frame-visible-p corfu--frame))
      nil)
     ((and (boundp 'posframe--frame)
           (not (null posframe--frame))
           (frame-visible-p posframe--frame))
      nil)
     (t
      (apply orig-fn args))))
  (advice-add #'dimmer-process-all :around #'my/dimmer-process-all-predicates)

  (dimmer-configure-which-key)
  (dimmer-configure-magit)
  (dimmer-configure-hydra)
  (dimmer-configure-posframe)
  (dimmer-mode 1))
#+end_src

* Completion

vertico and related packages are used for completion framework.

** Vertico

#+begin_src emacs-lisp
(use-package vertico
  :diminish vertico-mode
  :init
  (vertico-mode)
  :config
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  ;; (setq read-extended-command-predicate
  ;;       #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))

(use-package vertico-directory
  :straight (:type built-in)
  :after vertico
  :bind (:map vertico-map
              ("C-l" . vertico-directory-up)
              ("\d" . vertico-directory-delete-char)))

(use-package vertico-repeat
  :straight (:type built-in)
  :after vertico
  :bind (("C-c z" . vertico-repeat)
         ("C-c _" . vertico-repeat-select))
  :hook (minibuffer-setup . vertico-repeat-save))

(use-package vertico-multiform
  :straight (:type built-in)
  :after vertico
  :config
  (vertico-multiform-mode))

(use-package savehist
  :diminish savehist-mode
  :init
  (savehist-mode))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c r" . my/consult-recent-file)
         ("C-c R" . consult-recent-file)
         ("C-c h" . consult-history)
         ("C-c M" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flycheck)
         ("M-g F" . consult-flymake)
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s i" . consult-info)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history)                 ;; orig. previous-matching-history-element
         :map tab-prefix-map
         ("r" . my/consult-recent-file-other-tab)
         )

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :commands (consult-buffer consult-xref consult--read)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Disable live preview when EXWM is enabled as it does not work well.
  (when-use-exwm
   (setq consult-preview-key "M-."))

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-ripgrep consult-git-grep consult-grep
   consult-recent-file
   consult--source-recent-file consult--source-project-recent-file
   :preview-key "M-.")

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))

  (when-use-exwm
   (defun consult-exwm-preview-fix (buf-or-name &optional norecord force-same-window)
     "Kludge to stop EXWM buffers from stealing focus during Consult previews."
     (when (derived-mode-p 'exwm-mode)
       (when-let ((mini (active-minibuffer-window)))
         (select-window (active-minibuffer-window)))))

   (advice-add
    #'switch-to-buffer :after #'consult-exwm-preview-fix)
   )

  ;; Set symbol in region or at point as initial input.
  (dolist (cmd '(consult-line consult-line-multi consult-keep-lines consult-focus-lines
                              consult-grep consult-ripgrep consult-git-grep))
    (eval
     `(consult-customize
       ,cmd
       :initial (if (use-region-p)
                    (buffer-substring (region-beginning) (region-end))
                  (thing-at-point 'symbol)))))

  (defun my/consult-recent-file ()
    "Find recent file using `completing-read'."
    (interactive)
    (let* ((filename
            (consult--read
             (or
              (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
              (user-error "No recent files, `recentf-mode' is %s"
                          (if recentf-mode "enabled" "disabled")))
             :prompt "Find recent file in other window: "
             :sort nil
             :require-match t
             :category 'file
             :state (consult--file-preview)
             :history 'file-name-history))
           (value (find-file-noselect filename nil nil nil)))
      (if (listp value)
          (mapcar 'display-buffer (nreverse value))
        (let ((win (display-buffer value)))
          (when win
            (select-window win))))))

  (defun my/consult-recent-file-other-window ()
    "Find recent file using `completing-read'."
    (interactive)
    (find-file-other-window
     (consult--read
      (or
       (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
       (user-error "No recent files, `recentf-mode' is %s"
                   (if recentf-mode "enabled" "disabled")))
      :prompt "Find recent file in other window: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history)))

  (defun my/consult-recent-file-new-window ()
    "Find recent file using `completing-read'."
    (interactive)
    (my/find-file-new-window
     (consult--read
      (or
       (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
       (user-error "No recent files, `recentf-mode' is %s"
                   (if recentf-mode "enabled" "disabled")))
      :prompt "Find recent file in new window: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history)))

  (defun my/consult-recent-file-other-tab ()
    "Find recent file in other tab using `completing-read'."
    (interactive)
    (find-file-other-tab
     (consult--read
      (or
       (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
       (user-error "No recent files, `recentf-mode' is %s"
                   (if recentf-mode "enabled" "disabled")))
      :prompt "Find recent file in other tab: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history)))

  (consult-customize
   my/consult-recent-file my/consult-recent-file-new-window
   my/consult-recent-file-other-window my/consult-recent-file-other-tab
   :preview-key "M-.")
  )
#+end_src

** Marginalia

#+begin_src emacs-lisp
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))
#+end_src

** Embark

Disabling embark-prefix-help-command for now as I prefer which-key's compact layout.

#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  ;; (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))

  ;; TODO: uncomment if I get used to use this package.
  ;; (setq embark-indicators
  ;;       '(embark-minimal-indicator  ; default is embark-mixed-indicator
  ;;         embark-highlight-indicator
  ;;         embark-isearch-highlight-indicator))

  ;; TODO: uncomment in case I want to replace which-key with this package.
  ;; (vertico-multiform-mode)
  ;; (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))
  )

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Orderless

#+begin_src emacs-lisp
(use-package orderless
  :custom
  (orderless-matching-styles '(orderless-prefixes
                               orderless-literal
                               orderless-regexp))
  (completion-styles '(orderless basic))
  (completion-category-overrides
   '((file (styles basic partial-completion))))
  :config
  (add-to-list 'orderless-affix-dispatch-alist '(?@ . orderless-regexp)))
#+end_src

** Cape

#+begin_src emacs-lisp
(use-package cape
  :custom
  (dabbrev-case-fold-search t)
  (dabbrev-case-replace nil)

  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p" . completion-at-point) ;; capf
         ("C-c p t" . complete-tag)        ;; etags
         ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h" . cape-history)
         ("C-c p f" . cape-file)
         ("C-c p k" . cape-keyword)
         ("C-c p s" . cape-elisp-symbol)
         ("C-c p e" . cape-elisp-block)
         ("C-c p a" . cape-abbrev)
         ("C-c p l" . cape-line)
         ("C-c p w" . cape-dict)
         ("C-c p :" . cape-emoji)
         ("C-c p \\" . cape-tex)
         ("C-c p _" . cape-tex)
         ("C-c p ^" . cape-tex)
         ("C-c p &" . cape-sgml)
         ("C-c p r" . cape-rfc1345))
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-emoji)
  ;; (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
  )
#+end_src

** Corfu

Corfu is used for in-buffer/minibuffer completion.

#+begin_src emacs-lisp
(use-package corfu
  :straight (corfu :files (:defaults "extensions/*"))
  :custom
  (corfu-cycle t)
  (tab-always-indent 'complete)
  (corfu-preselect 'prompt)
  :bind (("C-q <tab>" . completion-at-point)
         ("C-q TAB" . completion-at-point)
         :map corfu-map
         ("C-f" . corfu-expand)
         ("C-i" . corfu-next)
         ("C-l" . my/corfu-backward-word)
         ("<tab>" . my/corfu-next-or-expand)
         ([tab] . my/corfu-next-or-expand)
         ("<backtab>" . corfu-previous)
         ([backtab] . corfu-previous))
  :init
  (global-corfu-mode)

  :config
  ;; Emacs 28 and newer: Hide commands in M-x which do not apply to the current
  ;; mode.  Corfu commands are hidden, since they are not used via M-x. This
  ;; setting is useful beyond Corfu.
  (setq read-extended-command-predicate #'command-completion-default-include-p)

  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer."
    (when (local-variable-p 'completion-at-point-functions)
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)

  ;; Comment out as this dose not seem to work as expected.
  ;; (add-to-list 'completion-styles-alist
  ;;              '(tab completion-basic-try-completion ignore
  ;;                    "Completion style which provides TAB completion only."))
  ;; (setq completion-styles '(tab orderless basic))


  (defun my/corfu-next-or-expand (&optional n)
    "Do corfu-expand when only one candidate exists otherwise move to next candidate."
    (interactive "p")
    (if (= corfu--total 1)
        (progn
          (corfu-next)
          (corfu-expand))
      (corfu-next n)))
  (add-to-list 'corfu-continue-commands 'my/corfu-next-or-expand)

  (defun my/corfu-backward-word (&optional n)
    "Delete the word prior to the point."
    (interactive "p")
    (dotimes (i (or n 1))
      (let ((end (point)))
        (backward-word)
        (delete-region (point) end))))
  (add-to-list 'corfu-continue-commands 'my/corfu-backward-word)
  )
#+end_src

Dabbrev settings copied from the GitHub Corfu page.

#+begin_src emacs-lisp
;; Use Dabbrev with Corfu
(use-package dabbrev
  ;; ;; Swap M-/ and C-M-/
  ;; :bind (("M-/" . dabbrev-completion)
  ;;        ("C-M-/" . dabbrev-expand))
  :config
  (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
  ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
  (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
#+end_src

*** corfu-terminal

#+begin_src emacs-lisp
(use-package corfu-terminal
 :straight
 (corfu-terminal
  :type git
  :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
 :config
 (defun my/start-corfu-terminal-mode ()
   (unless (display-graphic-p)
     (corfu-terminal-mode +1)))

 (add-hook 'server-after-make-frame-hook #'my/start-corfu-terminal-mode)
 (my/start-corfu-terminal-mode)
 )
#+end_src

*** corfu-doc-terminal

#+begin_src emacs-lisp
(use-package corfu-doc-terminal
 :straight (corfu-doc-terminal
            :type git
            :repo "https://codeberg.org/akib/emacs-corfu-doc-terminal.git")
 :config
 (defun start-corfu-doc-terminal-mode ()
   (unless (display-graphic-p)
     (corfu-doc-terminal-mode +1)))

 (add-hook 'server-after-make-frame-hook #'start-corfu-doc-terminal-mode)
 (start-corfu-doc-terminal-mode)
 )
#+end_src

*** corfu-popupinfo

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :straight nil
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-delay '(1.0 . 0))
  :config

  ;; Scroll up/down by half frame-height by default.
  (defun my/corfu-popupinfo-scroll-wrapper (orig-fn &optional n)
    (interactive "P")
    (let ((half-frame-height (with-selected-frame
                                 corfu-popupinfo--frame
                               (/ (window-height
                                   (get-buffer-window " *corfu-popupinfo*")) 2))))
      (funcall orig-fn (or n half-frame-height))))

  (advice-add #'corfu-popupinfo-scroll-up
              :around #'my/corfu-popupinfo-scroll-wrapper)
  (advice-add #'corfu-popupinfo-scroll-down
              :around #'my/corfu-popupinfo-scroll-wrapper)
  )
#+end_src

*** nerd-icons-corfu

#+begin_src emacs-lisp
(use-package nerd-icons-corfu
 :config
 (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

*** corfu-candidate-overlay

#+begin_src emacs-lisp
(use-package corfu-candidate-overlay
  :straight (:type git
                   :repo "https://code.bsdgeek.org/adam/corfu-candidate-overlay"
                   :files (:defaults "*.el"))
  :after corfu
  :bind ("C-c p o" . corfu-candidate-overlay-mode)  ;; toggle overlay mode.
  :config
  (set-face-attribute 'corfu-candidate-overlay-face nil
                      :foreground "wheat2")
  ;; Hack to enable corfu-candidate-overlay-mode in certain modes only.
  ;; (defun my/corfu-candidate-overlay-mode (&optional win-or-frame)
  ;;   (let* ((b (current-buffer))
  ;;          (w (get-buffer-window b))
  ;;          (enabled-mode-list '(prog-mode)))
  ;;     ;; (message "arg:%s, buf:%s, win:%s, livep:%s" win-or-frame b w (window-live-p w))
  ;;     (when (and
  ;;            (window-live-p w)
  ;;            (not (or
  ;;                  (window-minibuffer-p w)
  ;;                  (minibufferp b))))
  ;;       (if (apply #'derived-mode-p enabled-mode-list)
  ;;           (progn
  ;;             ;; (message "enabling corfu...")
  ;;             (unless (member 'corfu-candidate-overlay--post-command post-command-hook)
  ;;               (add-hook 'post-command-hook #'corfu-candidate-overlay--post-command)
  ;;               (add-hook 'pre-command-hook  #'corfu-candidate-overlay--pre-command)))
  ;;         (progn
  ;;           ;; (message "disabling corfu...")
  ;;           (when (member 'corfu-candidate-overlay--post-command post-command-hook)
  ;;             (remove-hook 'post-command-hook #'corfu-candidate-overlay--post-command)
  ;;             (remove-hook 'pre-command-hook  #'corfu-candidate-overlay--pre-command)))
  ;;         ))))
  ;; (add-to-list 'window-state-change-functions 'my/corfu-candidate-overlay-mode)

  ;; enable corfu-candidate-overlay mode globally
  ;; this relies on having corfu-auto set to nil
  ;; ;; bind Ctrl + TAB to trigger the completion popup of corfu
  ;; (global-set-key (kbd "C-<tab>") 'completion-at-point)
  ;; ;; bind Ctrl + Shift + Tab to trigger completion of the first candidate
  ;; ;; (keybing <iso-lefttab> may not work for your keyboard model)
  ;; (global-set-key (kbd "C-<iso-lefttab>") 'corfu-candidate-overlay-complete-at-point)
  )
#+end_src

** nerd-icons-completion

#+begin_src emacs-lisp
(use-package nerd-icons-completion
  :after marginalia
  :config
  (nerd-icons-completion-mode)
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

** completion preview mode

A new mode integrated in Emacs 30.

#+begin_src emacs-lisp
(use-package completion-preview
  :straight (:type built-in)
  :bind (("C-c p P" . completion-preview-mode)
         :map completion-preview-active-mode-map
         ("M-n" . completion-preview-next-candidate)
         ("M-p" . completion-preview-prev-candidate))
  :custom
  (completion-preview-minimum-symbol-length 2)
)
#+end_src

* Edit modes

** AUCTeX

#+begin_src emacs-lisp
(use-package auctex
  :mode (("\\.tex\\'" . LaTeX-mode))
  :hook ((LaTeX-mode . LaTeX-math-mode)
         (LaTeX-mode . visual-line-mode))
  :custom
  (TeX-engine 'xetex)
  (LaTeX-command "xelatex")
  :config
  (with-eval-after-load 'tex
    (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex --synctex=1%(mode)%' %t" TeX-run-TeX nil t))))
#+end_src

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :mode ("\\.yaml\\'" . yaml-mode)
  :config
  (add-hook 'yaml-mode-hook
            #'(lambda ()
                (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
  (setq lsp-yaml-schemas '((Kubernetes . "*k8s*/*.yaml"))))
#+end_src

** Markdown

#+begin_src emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  ;; :init
  ;; ;; gfm-preview is a 1-line script containing "grip --export $1 -"
  ;; (let ((cmd (expand-file-name "~/bin/gfm-preview")))
  ;;   (when (file-exists-p cmd) (setq markdown-command cmd)))
  :custom
  (markdown-header-scaling t)
  (markdown-fontify-code-blocks-natively t)
  (markdown-enable-math t)
  (markdown-enable-highlighting-syntax t)
  (markdown-indent-no-enter 'indent-and-new-item)
  (markdown-list-indent-width 2)
  :config
  (custom-set-faces
   '(markdown-header-face-1 ((t :inherit org-level-1)))
   '(markdown-header-face-2 ((t :inherit org-level-2)))
   '(markdown-header-face-3 ((t :inherit org-level-3)))
   '(markdown-header-face-4 ((t :inherit org-level-4)))
   '(markdown-header-face-5 ((t :inherit org-level-5)))
   '(markdown-header-face-6 ((t :inherit org-level-6)))
   '(markdown-code-face ((t :background "#151b23"
                            :extend t
                            :inherit default)))
   '(markdown-inline-code-face ((t :inherit org-code)))
   )
  )
#+end_src

** UML

#+begin_src emacs-lisp
(use-package plantuml-mode
  :mode (("\\.uml\\'" . plantuml-mode))
  :custom
  (plantuml-jar-path "~/Downloads/plantuml.jar")
  :config
  (with-eval-after-load 'org
    (setq org-plantuml-jar-path "~/Downloads/plantuml.jar")
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (require 'ob-plantuml)))
#+end_src

** Graphviz Dot

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :mode (("\\.dot\\'" . graphviz-dot-mode)))
#+end_src

** More generic modes

#+begin_src emacs-lisp
(require 'generic-x)
#+end_src

* Misc editing enhancements

** Tramp

*** consult-tramp

#+begin_src emacs-lisp
(use-package consult-tramp
  :straight (consult-tramp
             :type git
             :host github
             :repo "Ladicle/consult-tramp")
  :bind ("C-q t" . consult-tramp))
#+end_src

** Multiple Cursors

*** multiple-cursors

Being disabled for now in favor of macursors.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :disabled
  :diminish
  :bind (:map my/edit-map
              ("a" . mc/mark-all-dwim)
              ("e" . mc/edit-lines)
              ("r" . mc/mark-in-region-regexp))
  :commands (mc/mark-all-dwim mc/edit-lines))
#+end_src


*** iedit

#+begin_src emacs-lisp
(use-package iedit
  :bind ( :map my/edit-map
          ("SPC" . iedit-mode)))
#+end_src

** Wgrep

You can edit the text in the grep buffer after typing C-c C-p. Document on the
usage is [[https://github.com/mhayashi1120/Emacs-wgrep#usage][here]].

#+begin_src emacs-lisp
(use-package wgrep :diminish)
(use-package wgrep-ag :diminish)
#+end_src

** Vundo

#+begin_src emacs-lisp
(use-package vundo
  :bind (("C-_" . vundo)
         :map my/edit-map
         ("u" . vundo))
  :config
  (setq vundo-glyph-alist vundo-unicode-symbols)
  )
#+end_src

** ws-butler

Trim spaces from EOL. Only lines touched get trimmed.

#+begin_src emacs-lisp
(use-package ws-butler
  :straight ( :type git :host github :repo "lewang/ws-butler" :branch "master")
  :diminish ws-butler-mode
  :hook (prog-mode . ws-butler-mode))
#+end_src

** yasnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1)

  ;; Define my own snippets here.
  (yas-define-snippets
   'fundamental-mode
   '(("@time" "`(format-time-string \"%H:%M:%S\")`" "current time")
     ("@today" "`(format-time-string \"%Y-%m-%d\")`" "today")
     ("@tomorrow" "`(format-time-string \"%Y-%m-%d\" (time-add (current-time) (* 24 3600)))`" "tomorrow")
     ("@yesterday" "`(format-time-string \"%Y-%m-%d\" (time-subtract (current-time) (* 24 3600)))`" "yesterday")
     ))

  (yas-define-snippets
   'org-mode
   '(("<el" "#+begin_src emacs-lisp\n$0\n#+end_src" "simple emacs-lisp block")
     ))
  )

(use-package yasnippet-snippets)
#+end_src

** Projectile

#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :bind-keymap
  ("C-c P" . projectile-command-map)
  :hook ((prog-mode . projectile-mode)
         (comint-mode . (lambda () (projectile-mode -1))))
  :custom
  (projectile-mode-line '(:eval (format " [%s]" (projectile-project-name)))))
#+end_src

** audo-sudoedit

#+begin_src emacs-lisp
(use-package auto-sudoedit
  :diminish
  :custom
  (auto-sudoedit-ask t)
  :config
  (auto-sudoedit-mode 1))
#+end_src

** spellcheck

jit-spell is being tried out as jinx does not handle English words right before/after Japanese character.

*** ispell
The configuration below is borrowed from https://home.hirosaki-u.ac.jp/heroic-2020/1575/.
Do not forget to install aspell.

#+begin_src emacs-lisp
(use-package ispell
  :commands (ispell ispell-region)
  :custom
  (ispell-program-name "aspell")
  (ispell-local-dictionary "en_US")
  :config
  (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+")))
#+end_src

*** jinx
#+begin_src emacs-lisp
(use-package jinx
  :disabled
  :diminish
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  :hook (((text-mode conf-mode markdown-mode) . jinx-mode))
  :config
  ;; (add-to-list 'jinx-exclude-regexps '(t "[^\000-\377]+"))
  (setq jinx-exclude-regexps
        '((emacs-lisp-mode "Package-Requires:.*$")
          (t "[A-Z]+\\>"         ;; Uppercase words
             "-+\\>"             ;; Hyphens used as lines or bullet points
             "\\w*?[0-9]\\w*\\>" ;; Words with numbers, hex codes
             "[a-z]+://\\S-+"    ;; URI
             "[^\000-\377]+"     ;; Non-Ascii characters
             "<?[-+_.~a-zA-Z][-+_.~:a-zA-Z0-9]*@[-.a-zA-Z0-9]+>?" ;; Email
             "\\(?:Local Variables\\|End\\):\\s-*$" ;; Local variable indicator
             "jinx-\\(?:languages\\|local-words\\):\\s-+.*$"))) ;; Local variables
  (add-to-list 'vertico-multiform-categories
               '(jinx grid (vertico-grid-annotate . 20)))
  (vertico-multiform-mode 1))
#+end_src

*** jit-spell

Note that jit-spell only works well with aspell as aspell wisely ignores Japanese characters while hunspell tries to correct Japanese characters.

#+begin_src emacs-lisp
(use-package jit-spell
  :hook ((text-mode conf-mode markdown-mode) . jit-spell-mode)
  :config
  (set-face-underline 'jit-spell-misspelling '(:style wave :color "#d2b580")))
#+end_src

** File Template

#+begin_src emacs-lisp
(when (locate-library "file-template")
  (use-package file-template
    :custom
    (file-template-insert-automatically t)
    (file-template-paths '(".templates" "~/lib/elisp/templates/"))
    (file-template-mapping-alist
     '(;; ("\\.org$" . "template.org")
       ("\\.mqh$" . "template.mqh")
       ("\\.mq5$" . "template.mq5")))
    :config
    (add-hook 'find-file-not-found-functions #'file-template-find-file-not-found-hook)))
#+end_src

** Adaptive Wrap

Correct indentation on bullet lists in Markdown mode.

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :disabled
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+end_src

* Misc utilities and enhancements
** Dired

Mostly borrowed from https://taipapamotohus.com/post/dired/.

*** Dired+

#+begin_src emacs-lisp
(use-package dired+
  :after dired
  :straight
  (dired+ :fetcher github :repo "emacsmirror/dired-plus")
  :init
  (setq diredp-hide-details-initially-flag nil)
  (setq diredp-hide-details-propagate-flag nil)
  :config
  (diredp-toggle-find-file-reuse-dir 1)
  )
#+end_src

*** Dired quick sort

#+begin_src emacs-lisp
(use-package dired-quick-sort
  :after dired
  :config
  (dired-quick-sort-setup))
#+end_src

*** nerd-icons-dired

#+begin_src emacs-lisp
(use-package nerd-icons-dired
  :diminish
  :after dired
  :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

*** Dired hacks

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("I" . dired-insert-subdir)
              ("i" . dired-subtree-insert)
              (";" . dired-subtree-remove)))

(use-package dired-filter
  :after dired
  :hook (dired-mode . dired-filter-mode)
  :bind ( :map dired-mode-map
          ("/" . dired-filter-map)
          :map dired-filter-map
          ("M" . dired-filter-mark-map)))

(use-package dired-collapse
  :after dired
  :hook (dired-mode . dired-collapse-mode))

(use-package dired-open
  :after dired
  :bind (:map dired-mode-map
              ("V" . dired-open-xdg)))
#+end_src

*** Custom functions

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :bind (("C-c d" . my/consult-dired-recent))
  :config
  (defun my/consult-dired-recent ()
    (interactive)
    (dired (consult--read
            (or
             (delete-dups (mapcar #'file-name-directory (bound-and-true-p recentf-list)))
             (user-error "No recent files, `recentf-mode' is %s"
                         (if recentf-mode "enabled" "disabled")))
            :prompt "Dired with recent dir: "
            :sort nil
            :require-match t
            :category 'file
            :state (consult--file-preview)
            :history 'file-name-history))))
#+end_src

** Async

#+begin_src emacs-lisp
(use-package async
  :config
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1))
#+end_src

** SHR
*** shr-tag-pre-highlight

#+begin_src emacs-lisp
(use-package shr-tag-pre-highlight
  :after shr
  :config
  (add-to-list 'shr-external-rendering-functions
               '(pre . shr-tag-pre-highlight))
  (when (version< emacs-version "26")
    (with-eval-after-load 'eww
      (advice-add 'eww-display-html :around
                  'eww-display-html--override-shr-external-rendering-functions))))
#+end_src
** Japanese Holidays

#+begin_src emacs-lisp
(use-package japanese-holidays
  :after calendar
  :config
  (setq calendar-holidays
        (append japanese-holidays holiday-local-holidays holiday-other-holidays))
  (setq calendar-mark-holidays-flag t)
  (setq japanese-holiday-weekend '(0 6)
        japanese-holiday-weekend-marker
        '(holiday nil nil nil nil nil japanese-holiday-saturday))
  (add-hook 'calendar-today-visible-hook 'japanese-holiday-mark-weekend)
  (add-hook 'calendar-today-invisible-hook 'japanese-holiday-mark-weekend)

  (defun my/japanese-holiday-show (&rest _args)
    (let* ((date (calendar-cursor-to-date t))
           (calendar-date-display-form '((format "%s年 %s月 %s日（%s）" year month day dayname)))
           (date-string (calendar-date-string date))
           (holiday-list (calendar-check-holidays date)))
      (when holiday-list
        (message "%s: %s" date-string (mapconcat #'identity holiday-list "; ")))))
  (add-hook 'calendar-move-hook 'my/japanese-holiday-show))
#+end_src
** Valign

Align tables with variable pitch fonts.

#+begin_src emacs-lisp
(use-package valign
  :diminish
  :custom
  (valign-fancy-bar t)
  ;; :hook ((org-mode markdown-mode) . valign-mode)
  )
#+end_src

** htmlize

#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

** vlf

#+begin_src emacs-lisp
(use-package vlf
  :bind ("C-c V" . vlf)
  :config
  (require 'vlf-setup))
#+end_src

* Window and workspace management

** Persp-mode

Use Persp-mode to isolate buffers based on workspace or project.

Unfortunately disabled this as I found frame handling in this package conflicts
with EXWM. For example, this package manipulates frame params on dialog windows
(e.g. open file dialog on Chrome).

#+begin_src emacs-lisp
(use-package-if-not-exwm
 persp-mode
 :disabled
 :bind (("C-x b" . my/persp-switch-to-buffer)
        ("C-x C-b" . my/persp-list-buffers)
        ("C-x k" . persp-kill-buffer)
        (:map persp-key-map
              ("N" . my/persp-new)
              ("o" . my/persp-switch-to-last-persp)))
 :custom
 (persp-keymap-prefix (kbd "C-z"))
 (persp-auto-save-opt 0)
 (persp-auto-resume-time -1)
 (persp-add-buffer-on-after-change-major-mode t)
 (persp-autokill-buffer-on-remove 'kill-weak)
 (persp-buffer-list-restricted-filter-functions
  persp-common-buffer-filter-functions)
 :init
 (persp-mode)
 :config
 (set-face-attribute 'persp-face-lighter-buffer-not-in-persp nil
                     :foreground "yellow3"
                     :background 'unspecified)

 ;; Quoted from https://gist.github.com/Bad-ptr/1aca1ec54c3bdb2ee80996eb2b68ad2d#file-persp-mru-el

 (add-hook 'persp-before-switch-functions
           #'(lambda (new-persp-name w-or-f)
               (let ((cur-persp-name (safe-persp-name (get-current-persp))))
                 (when (member cur-persp-name persp-names-cache)
                   (setq persp-names-cache
                         (cons cur-persp-name
                               (delete cur-persp-name persp-names-cache)))))))

 (add-hook 'persp-renamed-functions
           #'(lambda (persp old-name new-name)
               (setq persp-names-cache
                     (cons new-name (delete old-name persp-names-cache)))))

 (add-hook 'persp-before-kill-functions
           #'(lambda (persp)
               (setq persp-names-cache
                     (delete (safe-persp-name persp) persp-names-cache))))

 (add-hook 'persp-created-functions
           #'(lambda (persp phash)
               (when (and (eq phash *persp-hash*)
                          (not (member (safe-persp-name persp)
                                       persp-names-cache)))
                 (setq persp-names-cache
                       (cons (safe-persp-name persp) persp-names-cache)))))

 ;; Switch to last perspective.
 (defun my/persp-switch-to-last-persp ()
   (interactive)
   (persp-frame-switch (car persp-names-cache)))

 (defun my/persp-switch-to-buffer (arg)
   (interactive "p")
   (call-interactively
      (if (= arg 4)
          'switch-to-buffer
        'persp-switch-to-buffer)))

 (defun my/persp-list-buffers (arg)
   (interactive "p")
   (if (= arg 4)
       (list-buffers)
     (with-persp-buffer-list () (list-buffers))))

 (defun my/persp-new (name)
  "Create a new persp"
  (interactive "spersp name: ")
  (persp-add-new name)
  (persp-switch name)
  (let ((scratch-buffer (get-scratch-buffer-create)))
    (persp-add-buffer scratch-buffer)
    (switch-to-buffer scratch-buffer)))
 )
#+end_src

** Dedicated window

Pin a window so that find-file or other operations won't steal the window.

#+begin_src emacs-lisp
;; Pin a window.
(defun my/toggle-window-dedicated ()
  "Toggle whether the current active window is dedicated or not"
  (interactive)
  (message
   (if (let (window (get-buffer-window (current-buffer)))
         (set-window-dedicated-p window
                                 (not (window-dedicated-p window))))
       "Window '%s' is dedicated"
     "Window '%s' is normal")
   (current-buffer)))

(define-key my/wm-map "d" #'my/toggle-window-dedicated)
#+end_src

** Move to last buffer

#+begin_src emacs-lisp
(defun my/switch-to-last-buffer ()
  "Switch to last buffer."
  (interactive)
  (let* ((b (other-buffer (current-buffer) 1))
         (w (get-buffer-window b)))
    (if w (select-window w)
      (switch-to-buffer b))))
(global-set-key (kbd "M-o") #'my/switch-to-last-buffer)
#+end_src

** Find file or buffer in new window

#+begin_src emacs-lisp
(defun my/switch-to-buffer-new-window (buffer-or-name &optional norecord)
  (interactive
   (list (read-buffer-to-switch "Switch to buffer in new window: ")))
  (split-window-right)
  (windmove-right)
  (switch-to-buffer buffer-or-name norecord))
(global-set-key (kbd "C-c b") #'my/switch-to-buffer-new-window)

(defun my/find-file-new-window (filename &optional wildcards)
  "Find file in a new window."
  (interactive
   (find-file-read-args "Find file in new window: "
                        (confirm-nonexistent-file-or-buffer)))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
	      (progn
	        (setq value (nreverse value))
	        (my/switch-to-buffer-new-window (car value))
	        (mapc 'switch-to-buffer (cdr value))
	        value)
      (my/switch-to-buffer-new-window value))))

;; (global-set-key (kbd "C-c f") #'my/find-file-new-window)
(global-set-key (kbd "C-c f") #'find-file-other-window)
#+end_src

** Select another window in the reverse cyclic order

#+begin_src emacs-lisp
(defun my/other-window-reverse ()
  "Select another window in the reverse cyclic order."
  (interactive)
  (other-window -1))

(global-set-key (kbd "C-x O") #'my/other-window-reverse)
#+end_src

** Tree view

TBH I don't use this often.

*** treemacs

#+begin_src emacs-lisp
(use-package treemacs
  :bind (:map my/wm-map
              ("T" . treemacs)))
#+end_src

** Ace jump

This is potentially very useful for quickly jumping to a position in the buffer
by selecting a character assigned to each position.

#+begin_src emacs-lisp
;; ace-jump-mode
(use-package ace-jump-mode
  :bind (("C-c C-SPC" . ace-jump-char-mode)
         :map my/wm-map
         ("j" . ace-jump-char-mode))
  :config
  (setq ace-jump-mode-scope 'window))
#+end_src

** Ace window

This is a must-have package for window management. For historical reasons, I
assign "~C-c <num>~" to directly select the window for the assigned number.  ~C-c w
<num>~ is useful to show the buffer in the current window to the selected
window. ~C-c W <num>~ is for swapping the buffers between the current window and
the selected window. ~aw-flip-window~ is also useful to go back and forth between
the two windows.

#+begin_src emacs-lisp
;; ace-window
(use-package ace-window
  :init
  :bind (("C-c 1" . aw-switch-to-window-1)
         ("C-c 2" . aw-switch-to-window-2)
         ("C-c 3" . aw-switch-to-window-3)
         ("C-c 4" . aw-switch-to-window-4)
         ("C-c 5" . aw-switch-to-window-5)
         ("C-c 6" . aw-switch-to-window-6)
         ("C-c 7" . aw-switch-to-window-7)
         ("C-c 8" . aw-switch-to-window-8)
         ("C-c 9" . aw-switch-to-window-9)
         :map my/wm-map
         ("o" . aw-flip-window)
         ("1" . aw-move-window-to-1)
         ("2" . aw-move-window-to-2)
         ("3" . aw-move-window-to-3)
         ("4" . aw-move-window-to-4)
         ("5" . aw-move-window-to-5)
         ("6" . aw-move-window-to-6)
         ("7" . aw-move-window-to-7)
         ("8" . aw-move-window-to-8)
         ("9" . aw-move-window-to-9)
         ("s 1" . aw-swap-window-to-1)
         ("s 2" . aw-swap-window-to-2)
         ("s 3" . aw-swap-window-to-3)
         ("s 4" . aw-swap-window-to-4)
         ("s 5" . aw-swap-window-to-5)
         ("s 6" . aw-swap-window-to-6)
         ("s 7" . aw-swap-window-to-7)
         ("s 8" . aw-swap-window-to-8)
         ("s 9" . aw-swap-window-to-9))
  :config
  ;; generate aw-switch-to-window-N
  (require 'cl)
  (dotimes (num 9 t)
    (fset (intern (format "aw-switch-to-window-%d" (1+ num)))
          (lexical-let ((n num))
            (lambda () (interactive)
              (ignore-errors
                (aw-switch-to-window (nth n (aw-window-list)))))))
    (fset (intern (format "aw-move-window-to-%d" (1+ num)))
          (lexical-let ((n num))
            (lambda () (interactive)
              (ignore-errors
                (aw-move-window (nth n (aw-window-list)))))))
    (fset (intern (format "aw-swap-window-to-%d" (1+ num)))
          (lexical-let ((n num))
            (lambda () (interactive)
              (ignore-errors
                (aw-swap-window (nth n (aw-window-list))))))))

  (setq aw-background nil)
  (setq aw-scope 'frame)
  (ace-window-display-mode))
#+end_src

** Transpose frame

#+begin_src emacs-lisp
;; transpose-frame
(use-package transpose-frame
  :bind (:map my/wm-map
              ("t" . my/hydra-transpose-frame/body))
  :config
  (defhydra my/hydra-transpose-frame (:hint nil)
    "
  Frame
  Transpose: _x_: transpose  _v_: flip      _h_: flop
     Rotate: _r_: rotate 180 _j_: clockwise _k_: anticlockwise
  "
    ("x" transpose-frame)
    ("v" flip-frame)
    ("h" flop-frame)
    ("r" rotate-frame)
    ("j" rotate-frame-clockwise)
    ("k" rotate-frame-anticlockwise)
    ("q" nil)))
#+end_src

** Custom display buffer alist

#+begin_src emacs-lisp
(setq fit-window-to-buffer-horizontally t)
(setq window-resize-pixelwise t)
(setq window-combination-resize t)
(setq split-width-threshold 80)

(defvar my/dba-min-windows 3)
(defvar my/split-window-horizontally-min-width 72)
(defun my/display-buffer-fallback-action (buf alist)
  "Return a window to display buffer BUF.  ALIST is not used.

If the nunber of windows in the frame is less than
my/dba-min-windows, create a new window holizontally.  Otherwise,
return the same window."
  (let* ((num-windows (count-windows))
         (min-frame-width
          (* (+ num-windows 1)
             my/split-window-horizontally-min-width))
         (win (get-buffer-window buf))
         (split-width-threshold
          (if (>= (frame-width) min-frame-width) 0 nil))
         (split-height-threshold
          (if (< (frame-width) min-frame-width) 0 nil)))
    (cond
     (win win)
     ((or (< num-windows my/dba-min-windows))
      (display-buffer-pop-up-window buf alist))
     ((not (buffer-file-name buf))  ;; maybe transient buffer
      (display-buffer-use-some-window buf alist))
     (t (or
         (display-buffer-in-previous-window buf alist)
         (display-buffer-same-window buf alist)
         (display-buffer-reuse-mode-window buf alist))))))

(setq display-buffer-fallback-action
      '((display-buffer--maybe-same-window
         display-buffer-reuse-window
         my/display-buffer-fallback-action
         display-buffer-use-some-window
         display-buffer-pop-up-window)))

(defvar my/side-window-height .3)

(add-to-list 'display-buffer-alist
             `(,(rx bos "*"
                    (or "Completion" "compilation" "Buffer List" (regexp "build.*") "xref")
                    (* not-newline) "*" eos)
               (lambda (buf alist)
                 (let ((win (get-buffer-window buf)))
                   (if win win
                     (display-buffer-in-side-window buf alist))))
               (side . bottom) (slot . 1) (preserve-size . (nil . t))
               ;; (window-parameters . ((no-other-window . t) (no-delete-other-windows . t)))
               (window-height . ,my/side-window-height)))

;; (defun my/display-buffer-in-bottom-window (bufname slot)
;;   "Display buffer with name BUFNAME in a window with slot SLOT at the bottom."
;;   (display-buffer-in-side-window (get-buffer-create bufname)
;;                                  `((side . bottom) (slot . ,slot))))

;; (global-set-key (kbd "C-c w l")
;;                 (lambda (bufname)
;;                   (interactive "B")
;;                   (my/display-buffer-in-bottom-window bufname -1)))
;; (global-set-key (kbd "C-c w c")
;;                 (lambda (bufname)
;;                   (interactive "B")
;;                   (my/display-buffer-in-bottom-window bufname 0)))
;; (global-set-key (kbd "C-c w r")
;;                 (lambda (bufname)
;;                   (interactive "B")
;;                   (my/display-buffer-in-bottom-window bufname 1)))
#+end_src

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :bind ("C-c O" . olivetti-mode)
  :custom
  (olivetti-body-width 128))
#+end_src

* Shell modes

** Custom window/buffer management for shell-ish modes

#+begin_src emacs-lisp
(defun my/shellish-buffer-p (buf &optional filter)
  "Return if BUF is a shell-ish buffer."
  (let ((mode (with-current-buffer buf major-mode))
        (shell-pattern (if filter filter
                         (rx (or "term" "shell" "eshell" "vterm" "eat")))))
    (and (string-match-p
          (concat "\\`\\*" shell-pattern ".*\\*\\'")
          (buffer-name buf))
         (seq-contains '(shell-mode eshell-mode term-mode vterm-mode eat-mode) mode))))

(defun my/get-shellish-buffers ()
  "Return a lit of shellish buffers or nil if none."
  (mapcar
   #'buffer-name
   (cl-remove-if-not 'my/shellish-buffer-p (buffer-list))))

(defvar my/display-shellish-buffer-list #'ignore
  "Custom function used to display shellish buffer list.")

(defvar my/consult-source-shellish-buffer
  `(:name "Shellish"
          :hidden t
          :narrow ?s
          :category buffer
          :face consult-buffer
          :history  buffer-name-history
          :state ,#'consult--buffer-state
          :items
          ,(lambda () (consult--buffer-query :sort 'visibility
                                             :as #'buffer-name
                                             :predicate
                                             #'my/shellish-buffer-p
                                             ))))

(defun my/consult-shellish-buffers ()
  (interactive)
  (consult-buffer (list
                   `(:hidden nil :narrow ?s ,@my/consult-source-shellish-buffer))))

(setq my/display-shellish-buffer-list #'my/consult-shellish-buffers)

(defun my/find-last-shellish-buffer (buflist shell-str)
  "Return most recently used shell-ish buffer containing SHELL-STR in BUFLIST."
  (when buflist
    (if (my/shellish-buffer-p (car buflist) shell-str)
        (car buflist) (my/find-last-shellish-buffer (cdr buflist) shell-str))))

(defvar my/last-non-shellish-buffer nil)
(defvar my/shellish-use-tab-p t)
(defvar my/shellish-window-height .3)

(defun my/remember-last-non-shellish-buffer ()
  "Remember last non-shellish buffer."
  (let ((buf (current-buffer)))
    (unless (my/shellish-buffer-p buf)
      (setq my/last-non-shellish-buffer buf))))

(defun my/shellish-tab-name (&optional shell-str)
  (format "*%s tab*" (if shell-str shell-str "shell")))

(defun my/get-display-buffer-action-for-shellish (&optional shell-str)
  "Return display-buffer's ACTION parameter applied to shellish buffers."
  (let ((tab-name (my/shellish-tab-name shell-str)))
    (if my/shellish-use-tab-p
        `(display-buffer-in-tab . ((tab-name . ,tab-name)))
      `(display-buffer-at-bottom . ((window-height . ,my/shellish-window-height))))))

(defun my/get-shellish (arg shellfunc shell-str)
  "Switch to the shell-ish buffer last used or create new without prefix (ARG).
  - Close the window if the current buffer is already a shell-ish buffer of
    the same type.
  - With single prefix, show buffers list.
  - With double prefixes, unconditionally create new one by calling SHELLFUNC.
  - With triple prefixes, toggle display buffer function between tab and bottom window."
  (interactive "p")
  (when (= arg 64)
    (setq my/shellish-use-tab-p (not my/shellish-use-tab-p)))
  (let ((b (my/find-last-shellish-buffer (buffer-list (selected-frame))
                                         shell-str))
        (display-buffer-overriding-action (my/get-display-buffer-action-for-shellish shell-str)))
    (cond ((or (not b) (= arg 16))
           (my/remember-last-non-shellish-buffer)
           (call-interactively shellfunc))
          ((= arg 4)
           (when b
             (select-window (display-buffer b)))
           (call-interactively my/display-shellish-buffer-list))
          ((string= (alist-get 'name (tab-bar-get-buffer-tab (current-buffer)))
                    (my/shellish-tab-name shell-str))
           (tab-close))
          ((my/shellish-buffer-p (current-buffer) shell-str)
           (condition-case err
               (delete-window (get-buffer-window (current-buffer)))
             (error
              (switch-to-prev-buffer))))
          (b
           (my/remember-last-non-shellish-buffer)
           (select-window (display-buffer b))
           (when my/shellish-use-tab-p
             (delete-other-windows))))))

(defun my/newshell ()
  "Create a new shell with specified buffer name."
  (interactive)
  (if (my/find-last-shellish-buffer (buffer-list (selected-frame)) "shell")
      (shell (format "*shell<%s>*" (read-string "Shell buffer name: ")))
    (shell)))

(defun my/get-shell (arg)
  (interactive "p")
  (my/get-shellish arg 'my/newshell "shell"))

(defun my/newterm ()
  "Create a new shell with specified buffer name."
  (interactive)
  (if (my/find-last-shellish-buffer (buffer-list (selected-frame)) "term")
      (multi-term (format "*terminal<%s>*"
                          (read-string "Shell buffer name: ")))
    (multi-term)))

(defun my/get-term (arg)
  (interactive "p")
  (my/get-shellish arg 'my/newterm "term"))

;; Key bindings
(global-set-key (kbd "C-c S") #'my/get-shell)  ;; C-c s is now mapped to vterm
(global-set-key (kbd "C-c t") #'my/get-term)
#+end_src

** Shell

I have a little helper functions to make shell buffers more useful for use
cases. I have a custom configuration for display-buffer-alist to make my custom
shell buffers always appear at the bottom left on the frame.

~C-c s~ will pop up a shell buffer at the bottom then another ~C-c s~ will close the
shell window. The helper functions defined below make it possible.

#+begin_src emacs-lisp
(use-package shell
  :bind (("C-x ~" . dirs))
  :config
  ;; dirtrack using procfs
  (defun shell-procfs-dirtrack (str)
    (prog1 str
      (when (string-match comint-prompt-regexp str)
        (let ((directory (file-symlink-p
                          (format "/proc/%s/cwd"
                                  (process-id
                                   (get-buffer-process
                                    (current-buffer)))))))
          (when (file-directory-p directory)
            (cd directory))))))

  (define-minor-mode shell-procfs-dirtrack-mode
    "Track shell directory by inspecting procfs."
    :global t
    (cond (shell-procfs-dirtrack-mode
           (when (bound-and-true-p shell-dirtrack-mode)
             (shell-dirtrack-mode 0))
           (when (bound-and-true-p dirtrack-mode)
             (dirtrack-mode 0))
           (add-hook 'comint-preoutput-filter-functions
                     'shell-procfs-dirtrack nil t))
          (t
           (remove-hook 'comint-preoutput-filter-functions
                        'shell-procfs-dirtrack t))))

  ;; Temporarily comment out to make my/get-shell work with remote (i.e. in tramp
  ;; format) default-directory.
  ;; (add-hook 'shell-mode-hook #'(lambda () (shell-procfs-dirtrack-mode 1)))

  ;; custom dir track list
  ;; (add-hook 'shell-mode-hook
  ;;           '(lambda ()
  ;;              (shell-dirtrack-mode 0)
  ;;              (dirtrack-mode 1)
  ;;              (setq dirtrack-list '("(..:..)\\((.+)\\)*\\([^\033()$#]+\\)" 2))
  ;;              (company-mode 0))
  ;;           'APPEND)

  ;; custom password prompt regexp
  (setq comint-password-prompt-regexp
        "\\(^ *\\|\\( *Password\\| *SSO\\| *IronKey\\| SMB\\|'s\\|Bad\\|CVS\\|Enter\\(?: \\(?:\\(?:sam\\|th\\)e\\)\\)?\\|Kerberos\\|LDAP\\|New\\|Old\\|Repeat\\|UNIX\\|\\[sudo]\\|enter\\(?: \\(?:\\(?:sam\\|th\\)e\\)\\)?\\|login\\|new\\|old\\) *\\)\\(?:\\(?:adgangskode\\|contrase\\(?:\\(?:ny\\|ñ\\)a\\)\\|geslo\\|h\\(?:\\(?:asł\\|esl\\)o\\)\\|iphasiwedi\\|jelszó\\|l\\(?:ozinka\\|ösenord\\)\\|m\\(?:ot de passe\\|ật khẩu\\)\\|[Pp]a\\(?:rola\\|s\\(?:ahitza\\|s\\(?: phrase\\|code\\|ord\\|phrase\\|wor[dt]\\)\\|vorto\\)\\)\\|s\\(?:alasana\\|enha\\|laptažodis\\)\\|wachtwoord\\|лозинка\\|пароль\\|ססמה\\|كلمة السر\\|गुप्तशब्द\\|शब्दकूट\\|গুপ্তশব্দ\\|পাসওয়ার্ড\\|ਪਾਸਵਰਡ\\|પાસવર્ડ\\|ପ୍ରବେଶ ସଙ୍କେତ\\|கடவுச்சொல்\\|సంకేతపదము\\|ಗುಪ್ತಪದ\\|അടയാളവാക്ക്\\|රහස්පදය\\|ពាក្យសម្ងាត់\\|パスワード\\|密[码碼]\\|암호\\)\\|Response\\)\\(?:\\(?:, try\\)? *again\\| (empty for no passphrase)\\| (again)\\)?\\(?: for .+\\)?[:：៖]\\s *\\'")
  )
#+end_src

** Eshell

I don't use eshell often (I use shell instead) so there is a chance that this
config does not perfectly work.

#+begin_src emacs-lisp
(use-package eshell
  :bind (("C-c e" . my/get-eshell))
  :commands (eshell)
  :hook (eshell-first-time-mode . my/eshell-setup-alias)
  :custom
  (eshell-destroy-buffer-when-process-dies t)
  (eshell-buffer-shorthand t)
  (eshell-scroll-to-bottom-on-input 'all)
  (eshell-error-if-no-glob t)
  (eshell-hist-ignoredups t)
  (eshell-save-history-on-exit t)
  (eshell-prefer-lisp-functions nil)
  :config
  ;; Extensions
  (setq eshell-modules-list
        (append eshell-modules-list
                '(eshell-smart eshell-elecslash)))

  (defun my/eshell-setup-alias ()
    "add local alias config for eshell."
    ;; aliases
    (eshell/alias "ls" "ls -A $*")
    (eshell/alias "l" "ls -lA $*")
    (eshell/alias "ff" "find-file-other-tab $1")
    (eshell/alias "sb" "switch-to-buffer-other-tab $1")
    (eshell/alias "ffsu" "find-file-other-tab /sudo::$PWD/$1")
    (eshell/alias "e" "find-file-other-tab $1")
    (eshell/alias "ms" "magit-status")
    (eshell/alias "gc" "git checkout $*")
    (eshell/alias "gb" "git branch $*")
    (eshell/alias "gs" "git status $*")
    (eshell/alias "gd" "git diff $*"))

  ;; Faces
  (use-package em-ls
    :straight (:type built-in)
    :config
    (set-face-attribute 'eshell-ls-directory nil
                        :foreground "DodgerBlue"))
  (use-package esh-mode
    :straight (:type built-in)
    :bind (( :map eshell-mode-map
             ("C-x C-b" . eshell-insert-buffer-name))))

  (defun my/neweshell ()
    (interactive)
    (eshell "new"))

  (defun my/get-eshell (arg)
    (interactive "p")
    (my/get-shellish arg 'my/neweshell "eshell")))

(use-package eshell-git-prompt
  :config
  (eshell-git-prompt-use-theme 'powerline))

(use-package eterm-256color)
#+end_src

** VTerm

Do not forget to add the following code to .bashrc
#+begin_src shell
if [[ -n "${EMACS_VTERM_PATH}" ]]; then
  f=${EMACS_VTERM_PATH}etc/emacs-vterm-bash.sh
  if [[ -f "$f" ]]; then
    . "$f"
  fi
fi
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :bind (("C-c s" . my/get-vterm)
         ("C-c C-z" . my/vterm-send-ctrl-z))
  :commands (vterm)
  :config
  (define-key vterm-mode-map (kbd "C-z") tab-prefix-map)

  (defun my/newvterm ()
    "Create a new vterm with specified buffer name."
    (interactive)
    (if (my/find-last-shellish-buffer (buffer-list (selected-frame)) "vterm")
        (vterm (format "*vterm<%s>*"
                       (read-string "Shell buffer name: ")))
      (vterm)))

  (defun my/get-vterm (arg)
    (interactive "p")
    (my/get-shellish arg 'my/newvterm "vterm"))

  (defun my/vterm-send-ctrl-z ()
    (interactive)
    (vterm-send-key (kbd "C-z")))
  )
#+end_src

** Term

#+begin_src emacs-lisp
(use-package term
  :config
  (set-face-attribute 'term nil
                      :foreground 'unspecified
                      :background 'unspecified
                      :inherit 'default))
#+end_src

*** tramp-term

#+begin_src emacs-lisp
(use-package tramp-term
  :bind (("C-c T" . tramp-term)))
#+end_src

*** multi-term

#+begin_src emacs-lisp
(use-package multi-term
  :custom
  (multi-term-dedicated-close-back-to-open-buffer-p nil)
  (multi-term-dedicated-select-after-open-p t)
  (multi-term-program "/bin/bash")
  (term-unbind-key-list '("C-z" "C-x" "C-c" "C-h" "C-u"))
  :hook (term-mode . (lambda ()
                       (define-key term-mode-map (kbd "C-a") 'term-bol)
                       (define-key term-mode-map (kbd "C-c C-a")
                                   'move-beginning-of-line)
                       (setq-local term-prompt-regexp "^[^#$%>]*[#$%>] *")))
  :config
  (setq term-bind-key-alist
        (append
         '(("C-c C-c" . term-send-raw)
           ("C-c C-x" . term-send-raw)
           ("C-c C-z" . term-send-raw)
           ("C-c C-h" . term-send-raw)
           ("C-c C-u" . term-send-raw)
           ("C-c C-k" . term-char-mode)
           ("C-c C-j" . term-line-mode))
         term-bind-key-alist))

  ;; override multi-term to use display-buffer
  (defun multi-term (&optional name)
    "Create new term buffer.
  Will prompt you shell name when you type `C-u' before this command."
    (interactive)
    (let (term-buffer)
      ;; Set buffer.
      (setq term-buffer (multi-term-get-buffer nil))
      (setq multi-term-buffer-list
            (nconc multi-term-buffer-list (list term-buffer)))
      (unless (or (null name)
                  (string= name ""))
        (with-current-buffer term-buffer (rename-buffer name)))
      (set-buffer term-buffer)
      ;; Internal handle for `multi-term' buffer.
      (multi-term-internal)
      ;; Switch buffer
      (select-window (display-buffer term-buffer))))
  )
#+end_src

** Eat

Yet another terminal emulator. Trying out now.

#+begin_src emacs-lisp
(use-package eat
  ;; :bind (("C-c s" . my/get-eat))
  :straight '(eat :type git
                  :host codeberg
                  :repo "akib/emacs-eat"
                  :files ("*.el" ("term" "term/*.el") "*.texi"
                          "*.ti" ("terminfo/e" "terminfo/e/*")
                          ("terminfo/65" "terminfo/65/*")
                          ("integration" "integration/*")
                          (:exclude ".dir-locals.el" "*-tests.el")))
  :hook ((eshell-first-time-mode . eat-eshell-mode)
         (eshell-first-time-mode . eat-eshell-visual-command-mode))
  :config
  (define-key eat-semi-char-mode-map (kbd "C-z") tab-prefix-map)

  (defun my/neweat ()
    "Create a new eat session."
    (interactive)
      (eat nil t))

  (defun my/get-eat (arg)
    (interactive "p")
    (my/get-shellish arg 'my/neweat "eat")))
#+end_src

* Software Development

** Misc preferences

#+begin_src emacs-lisp
(setq compilation-scroll-output t)

;; linum-mode
;; (setq linum-format "%4d\u2502")
;; (add-hook 'prog-mode-hook
;;           '(lambda () (linum-mode 1)))

;; Do not use TAB for indentation by default.
(add-hook 'prog-mode-hook
          #'(lambda ()
              (setq-local indent-tabs-mode nil)))
#+end_src

** Makefile

Enable indent-tabs-mode for makefile mode.

#+begin_src emacs-lisp
(use-package make-mode
  :straight (:type built-in)
  :hook ((makefile-mode . my/makefile-mode-hook))
  :config
  (defun my/makefile-mode-hook ()
    (setq indent-tabs-mode t))
)
#+end_src

** Tree Sitter

#+begin_src emacs-lisp
(use-package treesit
  :straight (:type built-in)
  :custom
  (treesit-font-lock-level 4)
  (treesit-load-name-override-list
   '((c++ "libtree-sitter-cpp" "tree_sitter_cpp")
     (common-lisp "libtree-sitter-common-lisp" "tree_sitter_commonlisp")
     (csharp "libtree-sitter-csharp" "tree_sitter_c_sharp")
     (go-mod "libtree-sitter-go-mod" "tree_sitter_gomod")))
  :init
  ;; Remap major modes to tree-sitter powered modes.
  (setq major-mode-remap-alist
        (append
         major-mode-remap-alist
         '((c-mode . c-ts-mode)
           (c++-mode . c++-ts-mode)
           (csharp-mode . csharp-ts-mode)
           (go-dot-mod-mode . go-mod-ts-mode)
           (go-mode . go-ts-mode)
           (java-mode . java-ts-mode)
           (javascript-mode . js-ts-mode)
           (js-mode . js-ts-mode)
           (json-mode . json-ts-mode)
           (python-mode . python-ts-mode)
           (typescript-mode . typescript-ts-mode))))
  :config
  ;; setting treesit-language-source-alist via :custom not working
  (setq treesit-language-source-alist
        '((bash "https://github.com/tree-sitter/tree-sitter-bash")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (cmake "https://github.com/uyha/tree-sitter-cmake")
          (common-lisp "https://github.com/theHamsta/tree-sitter-commonlisp")
          (cpp "https://github.com/tree-sitter/tree-sitter-cpp" "v0.22.0")
          (css "https://github.com/tree-sitter/tree-sitter-css" "v0.20.0")
          (csharp "https://github.com/tree-sitter/tree-sitter-c-sharp")
          (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
          (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (go "https://github.com/tree-sitter/tree-sitter-go" "v0.20.0")
          (go-mod "https://github.com/camdencheek/tree-sitter-go-mod")
          (html "https://github.com/tree-sitter/tree-sitter-html" "v0.20.1")
          (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript" "v0.20.1"))
          (json "https://github.com/tree-sitter/tree-sitter-json" "v0.20.2")
          (lua "https://github.com/Azganoth/tree-sitter-lua")
          (make "https://github.com/alemuller/tree-sitter-make")
          (markdown "https://github.com/ikatyang/tree-sitter-markdown" "v0.7.1")
          (python "https://github.com/tree-sitter/tree-sitter-python" "v0.20.4")
          (r "https://github.com/r-lib/tree-sitter-r")
          (rust "https://github.com/tree-sitter/tree-sitter-rust" "v0.21.2")
          (toml "https://github.com/tree-sitter/tree-sitter-toml" "v0.5.1")
          (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "tsx/src"))
          (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "v0.20.3" "typescript/src"))
          (yaml "https://github.com/ikatyang/tree-sitter-yaml" "v0.5.0")))

  ;; Install tree-sitter language grammar for all langues configured.
  (defun my/treesit-install-all-languages ()
    (interactive)
    (dolist (ent treesit-language-source-alist)
      (let ((lang (car ent)))
        (unless (treesit-language-available-p lang)
          (message "Installing %s grammar for tree-sitter" lang)
          (treesit-install-language-grammar lang)))))
  )
#+end_src

** lsp-mode
*** lsp-mode
#+begin_src emacs-lisp
(use-package lsp-mode
  :hook
  ((lsp-mode . (lambda ()
                 (lsp-enable-which-key-integration)
                 (define-key lsp-mode-map (kbd "C-c l") lsp-command-map))))
  :commands (lsp lsp-register-client)
  :preface
  ;; Use plists for emacs-lsp-booster
  (setenv "LSP_USE_PLISTS" "true")
  (setq lsp-use-plists t)

  :init
  (setq lsp-keymap-prefix (kbd "C-c l"))
  ;; (setq lsp-signature-auto-activate nil)
  (setq lsp-signature-render-documentation nil)
  :custom
  (lsp-diagnostic-clean-after-change t)
  :config

  ;; Hack to enable LSP in org-src-mode buffers.
  ;; https://github.com/emacs-lsp/lsp-mode/issues/2842#issuecomment-870807018
  ;; Run lsp command after switching to the associated Org Src buffer.
  (defun org-babel-edit-prep:python (babel-info)
    (let ((tangle (->> babel-info caddr (alist-get :tangle))))
      (setq-local buffer-file-name
                  (if (string= tangle "no")
                      "~/tmp/__temp__.py"
                    tangle))))
  ;; Use advice as org-babel-edit-prep:jupyter-<lang> will be defined ob-jupyter.el.
  (advice-add #'org-babel-edit-prep:jupyter-python :after
              #'org-babel-edit-prep:python)

  ;; Enable config for emacs-lsp-booster
  (when (file-exists-p "/usr/bin/emacs-lsp-booster")
    (defun lsp-booster--advice-json-parse (old-fn &rest args)
      "Try to parse bytecode instead of json."
      (or
       (when (equal (following-char) ?#)
         (let ((bytecode (read (current-buffer))))
           (when (byte-code-function-p bytecode)
             (funcall bytecode))))
       (apply old-fn args)))
    (advice-add (if (progn (require 'json)
                           (fboundp 'json-parse-buffer))
                    'json-parse-buffer
                  'json-read)
                :around
                #'lsp-booster--advice-json-parse)

    (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
      "Prepend emacs-lsp-booster command to lsp CMD."
      (let ((orig-result (funcall old-fn cmd test?)))
        (if (and (not test?)                             ;; for check lsp-server-present?
                 (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
                 lsp-use-plists
                 (not (functionp 'json-rpc-connection))  ;; native json-rpc
                 (executable-find "emacs-lsp-booster"))
            (progn
              (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
                (setcar orig-result command-from-exec-path))
              (message "Using emacs-lsp-booster for %s!" orig-result)
              (cons "emacs-lsp-booster" orig-result))
          orig-result)))
    (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)))
#+end_src

*** lsp-ui

#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp-mode
  :bind (:map lsp-ui-doc-frame-mode-map
              ("C-b" . lsp-ui-doc-hide)
              ("C-f" . lsp-ui-doc-hide)
              ("C-g" . lsp-ui-doc-hide)
              ;; ("C-n" . my/lsp-ui-doc-scroll-up-by-1)
              ;; ("C-p" . my/lsp-ui-doc-scroll-down-by-1)
              ("<down>" . my/lsp-ui-doc-scroll-up-by-1)
              ("<up>" . my/lsp-ui-doc-scroll-down-by-1)
              ("C-v" . my/lsp-ui-doc-scroll-up)
              ("M-v" . my/lsp-ui-doc-scroll-down)
              ("<next>" . my/lsp-ui-doc-scroll-up)
              ("<prior>" . my/lsp-ui-doc-scroll-down))
  :custom
  (lsp-ui-doc-position 'at-point)
  (lsp-ui-doc-show-with-cursor t)
  (lsp-ui-doc-delay 1.0)
  :config
  ;; (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  ;; (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
  (define-key lsp-ui-doc-mode-map (kbd "<tab-bar> <mouse-movement>") #'ignore)
  (set-face-attribute 'lsp-ui-peek-selection nil
                      :foreground 'unspecified
                      :background 'unspecified
                      :inherit 'region)
  (set-face-attribute 'lsp-ui-peek-header nil
                      :foreground 'unspecified
                      :background "dark slate blue")
  (set-face-attribute 'lsp-ui-peek-highlight nil
                      :foreground 'unspecified
                      :background "royal blue"
                      :distant-foreground 'unspecified
                      :box '(:line-width -1 :color "white"))

  (setf (alist-get 'no-accept-focus lsp-ui-doc-frame-parameters) t)

  ;; Temporarily bind scroll-up/down keys when child frame is visible.
  (defun my/lsp-ui-doc-scroll (scroll-func &rest args)
    (when (lsp-ui-doc--frame-visible-p)
      (with-selected-frame (lsp-ui-doc--get-frame)
        (lsp-ui-doc--with-buffer
          (apply scroll-func args)))))

  (defun my/lsp-ui-doc-scroll-up (&optional n)
    (interactive "P")
    (my/lsp-ui-doc-scroll 'scroll-up n))

  (defun my/lsp-ui-doc-scroll-down (&optional n)
    (interactive "P")
    (my/lsp-ui-doc-scroll 'scroll-down n))

  (defun my/lsp-ui-doc-scroll-up-by-1 (&optional n)
    (interactive "p")
    (my/lsp-ui-doc-scroll-up n))

  (defun my/lsp-ui-doc-scroll-down-by-1 (&optional n)
    (interactive "p")
    (my/lsp-ui-doc-scroll-down n))

  (defun my/lsp-ui-doc-on-show-frame (&rest args)
    (when (lsp-ui-doc--visible-p)
      (setf (alist-get #'lsp-ui-doc-mode minor-mode-overriding-map-alist)
            lsp-ui-doc-frame-mode-map)))

  (defun my/lsp-ui-doc-on-hide-frame (&rest args)
    (setf (alist-get #'lsp-ui-doc-mode minor-mode-overriding-map-alist
                     nil 'remove) nil))

  (advice-add #'lsp-ui-doc--display :after #'my/lsp-ui-doc-on-show-frame)
  (advice-add #'lsp-ui-doc--hide-frame :after #'my/lsp-ui-doc-on-hide-frame)

  (dolist (sym '( my/lsp-ui-doc-scroll my/lsp-ui-doc-scroll-up
                  my/lsp-ui-doc-scroll-down my/lsp-ui-doc-scroll-up-by-1
                  my/lsp-ui-doc-scroll-down-by-1))
    (put sym 'completion-predicate #'ignore))
  )
#+end_src

*** lsp-pyright

#+begin_src emacs-lisp
(use-package lsp-pyright
  :after lsp-mode
  :custom
  (lsp-pyright-langserver-command "basedpyright"))
#+end_src

*** lsp-eslint

#+begin_src emacs-lisp
(use-package lsp-eslint
  :straight nil
  :after lsp-mode)
#+end_src

*** lsp-tailwindcss

#+begin_src emacs-lisp
(use-package lsp-tailwindcss
  :straight (:type git :host github :repo "merrickluo/lsp-tailwindcss")
  :after lsp-mode
  :custom
  (lsp-tailwindcss-add-on-mode t)
  :config
  (setq lsp-tailwindcss-major-modes
        (append lsp-tailwindcss-major-modes
           '(css-mode
             css-ts-mode
             typescript-mode
             typescript-ts-mode
             tsx-ts-mode
             js2-mode
             js-ts-mode
             clojure-mode))))
#+end_src

*** lsp-treemacs

#+begin_src emacs-lisp
(use-package lsp-treemacs
  :requires lsp-mode)
#+end_src

** eglot

Currently eglot is disabled to try lsp-mode out again.

#+begin_src emacs-lisp
(use-package eglot
  :disabled
  :requires projectile
  :hook ((eglot--managed-mode . (lambda () (flycheck-mode -1)))
         ((c++-ts-mode python-ts-mode) . eglot-ensure))
  :commands (eglot eglot-ensure)
  ;; :config
  ;; Disabled as I don't remember what this is.
  ;; (with-eval-after-load 'project
  ;;   (add-to-list 'project-find-functions
  ;;                #'(lambda (dir)
  ;;                    (let ((root (projectile-project-root dir)))
  ;;                      (and root (cons 'transient root))))))
  )
#+end_src

** Eldoc

Eldoc-box displays eldoc contents in a child frame but is currently disabled.

#+begin_src emacs-lisp
(use-package eldoc-box
  :disabled
  :diminish eldoc-box-hover-mode
  :hook (prog-mode . eldoc-box-hover-mode)
  :bind (:map my/info-map
              ("i" . eldoc-box-eglot-help-at-point))
  :custom
  (eldoc-box-clear-with-C-g t))
#+end_src

** Flycheck & Flymake

*** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :diminish
  :custom (flycheck-indication-mode nil))

(use-package flycheck-popup-tip
  :hook (flycheck-mode . flycheck-popup-tip-mode))

(use-package consult-flycheck
  :diminish)
#+end_src

*** flymake
#+begin_src emacs-lisp
(use-package flymake
  :disabled
  :hook (prog-mode . flymake-mode))

(use-package flymake-diagnostic-at-point
  :hook (flymake-mode . flymake-diagnostic-at-point-mode))
#+end_src

** puni (structured editing)

#+begin_src emacs-lisp
(use-package puni
  :diminish
  :bind (("C-d" . delete-char)  ;; don't override C-d
         ("C-)" . puni-slurp-forward)
         ("C-(" . puni-barf-forward)
         ("C-c '" . my/puni-wrap-single-quote)
         ("C-c \"" . my/puni-wrap-double-quote)
         ("C-c (" . puni-wrap-round)
         ("C-c [" . puni-wrap-square)
         ("C-c {" . puni-wrap-curly)
         ("C-c <" . puni-wrap-angle)
         ("M-SPC" . puni-mark-sexp-at-point)
         :map puni-mode-map
         ("C-<" . puni-raise)
         ("C->" . puni-splice)
         :map my/edit-map
         ("'" . my/puni-wrap-single-quote)
         ("\"" . my/puni-wrap-double-quote)
         ("(" . puni-wrap-round)
         ("[" . puni-wrap-square)
         ("{" . puni-wrap-curly)
         ("<" . puni-wrap-angle))
  :hook (emacs-lisp-mode . puni-mode)
  :custom
  (puni-confirm-when-delete-unbalanced-active-region nil)
  :config
  (defun my/def-pairs (pairs)
    (dolist (wdef pairs)
      (fset (intern (concat
                     "my/puni-wrap-"
                     (symbol-name (car wdef))))
            `(lambda (&optional n)
               (interactive "P")
               (puni-wrap-next-sexps
                (puni--parse-interactive-argument-for-wrap n)
                ,(cadr wdef) ,(cddr wdef))))))

  (my/def-pairs '((single-quote . ("'" . "'"))
                  (double-quote . ("\"" . "\""))))
  )
#+end_src

** Dumb jump

#+begin_src emacs-lisp
(use-package dumb-jump
  :diminish
  :hook (prog-mode . dumb-jump-mode)
  :custom
  (dumb-jump-disable-obsolete-warnings t)
  (dumb-jumb-default-project "")
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

#+end_src

** Aggressive indent

#+begin_src emacs-lisp
(use-package aggressive-indent
  :hook ((go-mode . aggressive-indent-mode)
         (emacs-lisp-mode . aggressive-indent-mode)))
#+end_src

** Formatting

*** Apheleia

#+begin_src emacs-lisp
(use-package apheleia
  :config
  (apheleia-global-mode +1))
#+end_src

** Highlighting

*** Rainbow Mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :diminish
  )
#+end_src

*** Rainbow Delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode)
  :config
  (set-face-background 'rainbow-delimiters-unmatched-face "red")

  ;; Borrowed from https://qiita.com/megane42/items/ee71f1ff8652dbf94cf7.
  (require 'cl-lib)
  (require 'color)
  (defun rainbow-delimiters-using-stronger-colors ()
    (interactive)
    (cl-loop
     for index from 1 to rainbow-delimiters-max-face-count
     do
     (let ((face (intern (format "rainbow-delimiters-depth-%d-face" index))))
       (cl-callf color-saturate-name (face-foreground face) 50))))
  (add-hook 'emacs-startup-hook 'rainbow-delimiters-using-stronger-colors))
#+end_src

*** Show whitespaces

#+begin_src emacs-lisp
(use-package whitespace
  :diminish whitespace-mode
  :hook ((prog-mode conf-mode yaml-mode) . whitespace-mode)
  :custom
  (whitespace-style '(face trailing tabs tab-mark))
  :config
  (set-face-attribute 'whitespace-tab nil
                       :foreground "gray30"
                       :background 'unspecified)
  (set-face-attribute 'whitespace-trailing nil
                       :background "gray25")
  )
#+end_src

*** Symbol overlay

#+begin_src emacs-lisp
(use-package symbol-overlay
  :diminish
  :hook (prog-mode . symbol-overlay-mode)
  :custom (symbol-overlay-idle-time 0.5))
#+end_src

*** Indent-bars

Enable indentation guide bars for some modes.

#+begin_src emacs-lisp
(use-package indent-bars
  :custom
  (indent-bars-color '(highlight :face-bg t :blend 0.2))
  (indent-bars-pattern ".")
  (indent-bars-width-frac 0.1)
  (indent-bars-pad-frac 0.1)
  (indent-bars-zigzag nil)
  (indent-bars-color-by-depth '(:regexp "outline-\\([0-9]+\\)" :blend 1)) ;; blend=1: blend with BG only
  (indent-bars-highlight-current-depth '(:blend 0.5)) ;; pump up the BG blend on current
  (indent-bars-display-on-blank-lines t)
  (indent-bars-no-descend-lists t) ; no extra bars in continued func arg lists
  (indent-bars-treesit-support t)
  (indent-bars-treesit-ignore-blank-lines-types '("module"))
  ;; Add other languages as needed
  (indent-bars-treesit-scope '((python function_definition class_definition for_statement
                                       if_statement with_statement while_statement)))
  ;; Note: wrap may not be needed if no-descend-list is enough
  ;;(indent-bars-treesit-wrap '((python argument_list parameters ; for python, as an example
  ;;                                  list list_comprehension
  ;;                                  dictionary dictionary_comprehension
  ;;                                  parenthesized_expression subscript)))
  :hook ((python-base-mode yaml-mode) . my/indent-bars-mode)
  :config
  (defun my/indent-bars-mode ()
    "Perform pre-checks before enabling indent-bars-mode to avoid some known issues."
    (interactive)
    (unless (string-match-p " \\*org-src-fontification.*" (buffer-name))
      (indent-bars-mode))))
#+end_src

*** Diff HL mode

#+begin_src emacs-lisp
(use-package diff-hl
  :diminish
  :config
  (with-eval-after-load 'magit
    (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

  (global-diff-hl-mode))
#+end_src

** Git

*** Magit

#+begin_src emacs-lisp
(use-package magit
  :commands (magit-status)
  :bind (("C-c m s" . magit-status)
         ("C-c m f" . magit-file-dispatch))
  :config
  (add-hook 'magit-process-find-password-functions 'magit-process-password-auth-source))
#+end_src

*** Forge

Disabled for now. This entry is for future use.

#+begin_src emacs-lisp
(use-package forge
  :after magit
  :config
  ;; patch problematic face
  (custom-set-faces
   '(forge-topic-header-line ((t :inherit magit-header-line)))))
#+end_src

*** Git timemachine

#+begin_src emacs-lisp
(use-package git-timemachine
  :commands (git-timemachine git-timemachine-toggle))
#+end_src

*** Git gutter

Currentl disabled as I'm trying out diff-hl.

#+begin_src emacs-lisp
(use-package git-gutter
  :disabled
  :diminish git-gutter-mode
  :bind (:map my/misc-map
              ("g" . my/hydra-git-gutter/body))
  :config
  (global-git-gutter-mode 1)
  ;; (git-gutter:linum-setup)
  (defhydra my/hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                        :hint nil)
    "
  Git gutter:
    _j_: next hunk        _s_tage hunk     _q_uit
    _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
    ^ ^                   _p_opup hunk
    _h_: first hunk
    _l_: last hunk        set start _R_evision
  "
    ("j" git-gutter:next-hunk)
    ("k" git-gutter:previous-hunk)
    ("h" (progn (goto-char (point-min))
                (git-gutter:next-hunk 1)))
    ("l" (progn (goto-char (point-min))
                (git-gutter:previous-hunk 1)))
    ("s" git-gutter:stage-hunk)
    ("r" git-gutter:revert-hunk)
    ("p" git-gutter:popup-hunk)
    ("R" git-gutter:set-start-revision)
    ("q" nil :color blue)
    ("Q" (progn (git-gutter-mode -1)
                ;; git-gutter-fringe doesn't seem to
                ;; clear the markup right away
                (sit-for 0.1)
                (git-gutter:clear))
     :color blue)))
#+end_src

** Debugging

*** REST Client

#+begin_src emacs-lisp
(use-package restclient
  :mode ("\\.http\\'" . restclient-mode))

(use-package ob-restclient
  :after (restclient org)
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t))))
#+end_src

*** Custom code for URL encoding/decoding

#+begin_src emacs-lisp
;; urlencode
(defvar urlencode-default-coding-system 'utf-8)
(defvar urlencode-exceptional-chars "[a-zA-Z0-9]")

(defun urlencode-region (begin end &optional cdp)
  (interactive "r\nP")
  (let* ((coding-system (and cdp (read-coding-system "Coding-system: ")))
         (encoded (urlencode (buffer-substring begin end) coding-system)))
    (delete-region begin end)
    (insert encoded)))

(defun urldecode-region (begin end &optional cdp)
  (interactive "r\nP")
  (let* ((coding-system (and cdp (read-coding-system "Coding-system: ")))
         (decoded (urldecode (buffer-substring begin end) coding-system)))
    (delete-region begin end)
    (insert decoded)))

(defun urlencode-string (str &optional cdp)
  (interactive "sString: \nP")
  (let ((coding-system (and cdp (read-coding-system "Coding-system: "))))
    (insert (urlencode str coding-system))))

(defun urldecode-string (str &optional cdp)
  (interactive "sString: \nP")
  (let ((coding-system (and cdp (read-coding-system "Coding-system: "))))
    (insert (urldecode str coding-system))))

(defun urlencode (str &optional coding-system)
  (mapconcat
   (lambda (c)
     (format (if (string-match urlencode-exceptional-chars (char-to-string c))
                 "%c" "%%%02X") c))
   (encode-coding-string str
                         (or coding-system urlencode-default-coding-system))
   ""))

(defun urldecode (str &optional coding-system)
  (let (pos
        decoded)
    (while (setq pos (string-match "%.." str))
      (setq decoded
            (concat decoded (substring str 0 pos)
                    (format "%c"
                            (string-to-number (substring str (+ pos 1) (+ pos 3)) 16)))
            str (substring str (+ pos 3))))
    (decode-coding-string (concat decoded str)
                          (or coding-system urlencode-default-coding-system))))
#+end_src

** Code Completion
*** Copilot

~copilot-install-server~ needs to be run after a fresh install. Also, Node.js v18+ is needed.
Manually enable ~copilot-mode~ when needed.

#+begin_src emacs-lisp
(use-package copilot
  :straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
  :bind ( :map copilot-completion-map
          ("C-<return>" . copilot-accept-completion)
          ("C-c C-f" . copilot-accept-completion-by-word)
          ("C-c C-n" . copilot-accept-completion-by-line)
          ("C-c C-p" . copilot-accept-completion-by-paragraph)))
#+end_src

*** Tabnine

#+begin_src emacs-lisp
(use-package tabnine
  :disabled
  :straight (tabnine
             :type git
             :host github
             :repo "shuxiao9058/tabnine")
  :commands (tabnine-start-process)
  :hook (;; (prog-mode . tabnine-mode)
         (kill-emacs . tabnine-kill-process))
  :diminish "⌬"
  :custom
  (tabnine-wait 1)
  (tabnine-minimum-prefix-length 0)
  :init
  (defun my/start-tabnine ()
    (interactive)
    (add-to-list 'completion-at-point-functions #'tabnine-completion-at-point)
    (tabnine-start-process)
    (tabnine-mode))
  :bind
  (:map  tabnine-completion-map
         ("<tab>" . tabnine-accept-completion)
         ("TAB" . tabnine-accept-completion)
         ("M-f" . tabnine-accept-completion-by-word)
         ("M-<return>" . tabnine-accept-completion-by-line)
         ("C-g" . tabnine-clear-overlay)
         ("M-[" . tabnine-previous-completion)
         ("M-]" . tabnine-next-completion)))
#+end_src

*** Codeium

#+begin_src emacs-lisp
(use-package codeium
  :disabled
  :straight '(:type git :host github :repo "Exafunction/codeium.el")
  :commands (codeium-install codeium-diagnose codeium-completion-at-point)
  :init
  (defun my/start-codium ()
    (interactive)
    (add-to-list 'completion-at-point-functions #'codeium-completion-at-point))
  ;; use globally
  ;; or on a hook
  ;; (add-hook 'python-mode-hook
  ;;     (lambda ()
  ;;         (setq-local completion-at-point-functions '(codeium-completion-at-point))))

  ;; if you want multiple completion backends, use cape (https://github.com/minad/cape):
  ;; (add-hook 'python-mode-hook
  ;;     (lambda ()
  ;;         (setq-local completion-at-point-functions
  ;;             (list (cape-capf-super #'codeium-completion-at-point #'lsp-completion-at-point)))))
  ;; an async company-backend is coming soon!

  ;; codeium-completion-at-point is autoloaded, but you can
  ;; optionally set a timer, which might speed up things as the
  ;; codeium local language server takes ~0.2s to start up
  ;; (add-hook 'emacs-startup-hook
  ;;  (lambda () (run-with-timer 0.1 nil #'codeium-init)))

  ;; :defer t ;; lazy loading, if you want
  :config
  ;; if you don't want to use customize to save the api-key
  ;; (setq codeium/metadata/api_key "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")

  ;; get codeium status in the modeline
  (setq codeium-mode-line-enable
        (lambda (api) (not (memq api '(CancelRequest Heartbeat AcceptCompletion)))))
  (add-to-list 'mode-line-format '(:eval (car-safe codeium-mode-line)) t)
  ;; alternatively for a more extensive mode-line
  ;; (add-to-list 'mode-line-format '(-50 "" codeium-mode-line) t)

  ;; use M-x codeium-diagnose to see apis/fields that would be sent to the local language server
  (setq codeium-api-enabled
        (lambda (api)
          (memq api '(GetCompletions Heartbeat CancelRequest GetAuthToken RegisterUser auth-redirect AcceptCompletion))))
  ;; you can also set a config for a single buffer like this:
  ;; (add-hook 'python-mode-hook
  ;;     (lambda ()
  ;;         (setq-local codeium/editor_options/tab_size 4)))

  ;; You can overwrite all the codeium configs!
  ;; for example, we recommend limiting the string sent to codeium for better performance
  (defun my-codeium/document/text ()
    (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (min (+ (point) 1000) (point-max))))
  ;; if you change the text, you should also change the cursor_offset
  ;; warning: this is measured by UTF-8 encoded bytes
  (defun my-codeium/document/cursor_offset ()
    (codeium-utf8-byte-length
     (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (point))))
  (setq codeium/document/text 'my-codeium/document/text)
  (setq codeium/document/cursor_offset 'my-codeium/document/cursor_offset))
#+end_src

** AI Agents

*** Helper functions for aider

#+begin_src emacs-lisp
(defun my/aider-call-function (func)
  "Set known API keys for aider and call a given function."
  (interactive)
  (setenv "GEMINI_API_KEY" (my/get-gemini-api-key))
  (setenv "GROQ_API_KEY" (my/get-groq-api-key))
  (setenv "ANTHROPIC_API_KEY" (my/get-anthropic-api-key))
  (setenv "DEEPSEEK_API_KEY" (my/get-deepseek-api-key))
  (setenv "OPENROUTER_API_KEY" (my/get-deepseek-api-key))
  (funcall func))

(defun my/aider-select-project-root ()
  "Select and return project root to be used with aider."
  (interactive)
  (completing-read "Select project: " (project-known-project-roots) nil 'confirm))

(defun my/aider-in-vterm ()
  "Run aider in vterm."
  (interactive)
  (let ((buf (get-buffer "*aider*")))
    (if buf (progn
              (tab-bar-switch-to-tab "*aider*")
              (select-window (display-buffer buf)))
      (let ((display-buffer-overriding-action '(display-buffer-in-tab))
            (dir (my/aider-select-project-root)))
        (my/aider-call-function (lambda ()
                                  (vterm "*aider*")
                                  (vterm-insert (format "cd %s" dir))
                                  (vterm-send-return)
                                  (vterm-insert "aider")
                                  (vterm-send-return)))))))
#+end_src

*** Aider
#+begin_src emacs-lisp
(use-package aider
  :straight (:host github :repo "tninja/aider.el" :files ("aider.el"))
  :commands (aider-transient-menu)
  :bind ( :map my/ai-map
          ("A" . my/aider-transient-menu))
  :config
  ;; Use claude-3-5-sonnet cause it is best in aider benchmark
  ;; (setq aider-args '("--model" "anthropic/claude-3-5-sonnet-20241022"))
  ;; (setenv "ANTHROPIC_API_KEY" (my/get-anthropic-api-key))
  ;; Or use chatgpt model since it is most well known
  ;; (setq aider-args '("--model" "gpt-4o-mini"))
  ;; (setenv "OPENAI_API_KEY" <your-openai-api-key>)
  ;; Or use gemini v2 model since it is very good and free

  ;; (setq aider-args '("--model" "gemini/gemini-2.0-flash-exp"))
  ;; (setenv "GEMINI_API_KEY" (my/get-gemini-api-key))

  (defun my/aider-transient-menu ()
    "Set known API keys before launching aider."
    (interactive)
    (my/aider-call-function 'aider-transient-menu))

  (setq aider-args '("--model" "anthropic/claude-3-5-sonnet-20241022"))

  ;; Or use your personal config file
  ;; (setq aider-args `("--config" ,(expand-file-name "~/.aider.conf.yml")))
  )
#+end_src
*** aidermacs

A fork of aider.el that seems to have better integration with Emacs.

#+begin_src emacs-lisp
(use-package aidermacs
  :straight (:host github :repo "MatthewZMD/aidermacs" :files ("*.el"))
  :commands (aidermacs-transient-menu)
  :bind ( :map my/ai-map
          ("a" . my/aidermacs))
  :custom
  (aidermacs-default-model "anthropic/claude-3-5-sonnet-20241022")
  (aidermacs-backend 'vterm)
  (aidermacs-auto-commits t)
  :config
  (aidermacs-setup-minor-mode)
  (defun my/aidermacs ()
    "Set known API keys before launching aidermacs."
    (interactive)
    (my/aider-call-function 'aidermacs-transient-menu)))
#+end_src

*** Copilot Chat
#+begin_src emacs-lisp
(use-package copilot-chat
  :straight (:host github :repo "chep/copilot-chat.el" :files ("*.el"))
  :commands (copilot-chat-transient copilot-chat-display)
  :bind ( :map my/ai-map
          ("c" . copilot-chat-transient))
  :custom
  (copilot-chat-backend 'curl)
  (copilot-chat-frontend 'org)
  (copilot-chat-model "claude-3.5-sonnet") ;; "gpt-4o", "o1-preview"
  )
#+end_src

** Jupyter

#+begin_src emacs-lisp
(use-package jupyter
  :custom
  (jupyter-use-zmq nil)
  :config
  ;; Override jupyter-python in org-src-lang-modes.
  (advice-add #'org-babel-jupyter-make-language-alias :after
              (lambda (kernel lang)
                (setf (alist-get "jupyter-python" org-src-lang-modes
                                 nil nil #'equal)
                      'python-ts)))

  ;; Custom function to enable the default virtual env and load ob-jupyter.
  (defun my/setup-jupyter ()
    (interactive)
    (require 'ob-jupyter)
    ;; use jupyter-python for python src block
    ;; (org-babel-jupyter-override-src-block "python")
    ;; (add-to-list 'ob-async-no-async-languages-alist "python")
    (jupyter-refresh-kernelspecs)
    (org-babel-jupyter-aliases-from-kernelspecs)
    ;; For handling ANSI colors in error messages.
    (defun my/display-ansi-colors ()
      (ansi-color-apply-on-region (point-min) (point-max)))
    (add-hook 'org-babel-after-execute-hook #'my/display-ansi-colors)
  ))
#+end_src

** Structural Edciting

#+begin_src emacs-lisp
(use-package combobulate-setup
  :straight (:type git :host github :repo "mickeynp/combobulate"
                   :nonrecursive t)
  :hook (prog-mode . combobulate-mode)
  :custom
  (combobulate-key-prefix "C-c u")
  :config
  (define-key combobulate-key-map (kbd "C-c o") nil)
  (define-key combobulate-key-map (kbd combobulate-key-prefix) combobulate-options-key-map)
  (define-key combobulate-python-map (kbd "C-c o e") nil)
  (define-key combobulate-python-map (kbd "C-c u e") combobulate-python-envelope-map))
#+end_src

* Programming language modes

** C++

Use c++-ts-mode by default.

#+begin_src emacs-lisp
(use-package c++-ts-mode
  :defer t
  :straight (:type built-in)
  :init
  (add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
  )
#+end_src

I adopt Google coding style. ~C-c i [br]~ key bindings should universally work as
formatting commands.

#+begin_src emacs-lisp
(use-package modern-cpp-font-lock
  :diminish modern-c++-font-lock-mode
  :hook
  ((c++-mode c++-ts-mode) . modern-c++-font-lock-mode))

(use-package clang-format
  :custom
  (clang-format-style "google")
  :hook
  ((c-mode-common c++-ts-mode) . (lambda ()
                     (local-set-key (kbd "C-c i b") 'clang-format-buffer)
                     (local-set-key (kbd "C-c i r") 'clang-format-region))))
#+end_src

** Python

#+begin_src emacs-lisp
(use-package python
  :straight (:type built-in)
  :custom
  (python-shell-completion-native-enable nil)
  (python-flymake-command '("ruff" "--quiet" "--stdin-filename=stdin" "-"))
  (python-indent-guess-indent-offset-verbose nil))
#+end_src

#+begin_src emacs-lisp
(use-package lazy-ruff
  :bind (("C-c i f" . lazy-ruff-lint-format-dwim))
  :config
  (lazy-ruff-global-mode t))
#+end_src

Use Black for formatter.

#+begin_src emacs-lisp
(use-package python-black
  :after python
  :hook ((python-mode python-ts-mode) . my/python-black-setup)
  :config
  (defun my/python-black-setup ()
    (python-black-on-save-mode-enable-dwim)
    (local-set-key (kbd "C-c i b") 'python-black-buffer)
    (local-set-key (kbd "C-c i r") 'python-black-region))
  )
#+end_src

Disable yapfify in favor of Black being tried out.

#+begin_src emacs-lisp
(use-package yapfify
  :disabled
  :hook  ((python-mode python-base-mode) . my/setup-yapfify)
  :config
  (defun my/setup-yapfify ()
    (local-set-key (kbd "C-c i b") 'yapfify-buffer)
    (local-set-key (kbd "C-c i r") 'yapfify-region)))
#+end_src

Use pyvenv package to simply support virtualenv.
~$HOME/.venv~ is the the default venv environment.

#+begin_src emacs-lisp
(use-package pyvenv
  :hook (after-init . my/pyvenv-setup)
  :config
  (defun my/pyvenv-activate ()
    "Activate venv at buffer's default directory or home directory."
    (interactive)
    (let ((venv-dir (file-name-concat default-directory ".venv")))
      (pyvenv-activate (if (file-directory-p venv-dir) venv-dir "~/.venv"))))

  (defun my/pyvenv-setup ()
    (require 'esh-mode)  ;; for eshell-mode-map
    (pyvenv-tracking-mode 1)))
#+end_src

** Go

The settings are old (~1.12) and might need an update.

#+begin_src emacs-lisp
(use-package go-mode
  :mode ("\\.go\\'" . go-mode)
  :hook
  (go-mode . (lambda ()
               (setq-local compile-command
                           "go build -v && go test -v && go vet")
               (setq-local gofmt-command "goimports")
               (setq-local fill-column 100)
               (setq-local c-basic-offset 4)
               (setq-local tab-width 4)
               (setq-local indent-tabs-mode t)
               (go-guru-hl-identifier-mode)
               (add-hook 'before-save-hook 'gofmt-before-save nil 'local)
               (local-set-key (kbd "M-.") 'godef-jump)
               (local-set-key (kbd "M-*") 'pop-tag-mark))))

(use-package go-eldoc
  :disabled
  :hook (go-mode . go-eldoc-setup))

(use-package go-guru
  :commands go-guru-hl-identifier-mode)

(use-package golint
  :commands golint)
#+end_src

** Web-mode

TBH this is not maintaned these days.

#+begin_src emacs-lisp
;; Web-mode (HTML+CS/JS)
(use-package web-mode
  :mode ("\\.p?html?\\'" "\\.tpl\\.php\\'" "\\.[agj]sp\\'" "\\.as[cp]x\\'"
         "\\.erb\\'" "\\.mustache\\'" "\\.djhtml\\'")
  :hook ((web-mode . (lambda ()
                       (setq-local indent-tabs-mode nil))))
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-sql-indent-offset 2)
  (web-mode-enable-block-face t)
  (web-mode-enable-part-face t)
  (web-mode-enable-auto-pairing nil)
  (web-mode-enable-auto-closing t)
  (web-mode-enable-auto-opening t)
  (web-mode-enable-auto-quoting t)
  (web-mode-enable-auto-indentation t)
  (web-mode-enable-css-colorization t)
  (web-mode-enable-current-element-highlight nil)
  (web-mode-enable-current-column-highlight nil)
  (web-mode-enable-comment-interpolation t)
  :config
  (define-key web-mode-map (kbd "C-c /") 'web-mode-element-close)

  (set-face-foreground 'web-mode-current-element-highlight-face "orange")
  (set-face-foreground 'web-mode-html-entity-face "yellow")
  (set-face-foreground 'web-mode-html-tag-face "orangered")
  (set-face-foreground 'web-mode-html-tag-bracket-face
                       (color-darken-name (face-foreground 'default) 20))
  (set-face-foreground 'web-mode-html-attr-name-face "orange")
  (set-face-foreground 'web-mode-html-attr-equal-face "cyan")
  (set-face-foreground 'web-mode-html-attr-value-face
                       (face-foreground 'font-lock-constant-face))
  ;; (set-face-foreground 'web-mode-annotation-tag-face "lightblue")
  ;; (set-face-foreground 'web-mode-annotation-type-face "pink")
  ;; (set-face-foreground 'web-mode-annotation-value-face "navy")
  ;; (set-face-foreground 'web-mode-constant-face "limegreen")
  ;; (set-face-foreground 'web-mode-filter-face "darkblue")
  ;; (set-face-foreground 'web-mode-keyword-face "pink")
  ;; (set-face-foreground 'web-mode-symbol-face
  ;;                      (face-foreground 'font-lock-constant-face))
  ;; (set-face-foreground 'web-mode-type-face "navy")
  ;; (set-face-foreground 'web-mode-variable-name-face "lightblue")
)
#+end_src

** Javascript

TBH this is not maintaned these days.

#+begin_src emacs-lisp
(use-package rjsx-mode
  :mode ("\\.js\\'" "\\.jsx\\'")
  :hook (rjsx-mode . (lambda ()
                       (setq-local js-indent-level 2)
                       (setq-local tab-width 2))))
#+end_src

** Typescript & TSX

#+begin_src emacs-lisp
(use-package typescript-ts-mode
  :straight (:type built-in)
  :mode (("\\.ts\\'" . typescript-ts-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package tsx-ts-mode
  :straight (:type built-in)
  :mode (("\\.[jt]sx\\'" . tsx-ts-mode)))
#+end_src

** JSON

#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

** MQL

MQL is a subset of C++.

#+begin_src emacs-lisp
;; MQL4
(add-to-list 'auto-mode-alist '("\\.mq[45h]\\'" . c++-ts-mode))

;; add extensions to dumb-jump
(with-eval-after-load 'dumb-jump
  (dolist (ext '("mq4" "mq5" "mqh"))
    (add-to-list 'dumb-jump-language-file-exts
                 `(:language "c++" :ext ,ext :agtype "cpp" :rgtype "cpp") t)))

;; Add format of compilation error message.
(add-to-list 'compilation-error-regexp-alist
             '("^\\(.+\\)(\\([0-9]+\\),\\([0-9]+\\)) : \\(error\\|warning\\).*$" 1 2 3))
#+end_src

** Java

I don't usually write Java so there's almost nothing here. I'll just rely on
lsp-mode. The formatter is available [[https://github.com/google/google-java-format][here]].

#+begin_src emacs-lisp
(defun my/setup-java-mode ()
  "Used for java-mode hook"
  (interactive)
  (local-set-key (kbd "C-c i b") 'google-java-format-buffer)
  (local-set-key (kbd "C-c i r") 'google-java-format-region))

(add-hook 'java-mode-hook #'my/setup-java-mode)
(add-hook 'java-ts-mode-hook #'my/setup-java-mode)
#+end_src

** Protobuf

#+begin_src emacs-lisp
(use-package protobuf-mode
  :mode "\\.proto\\'")
#+end_src

** Shell scripts

#+begin_src emacs-lisp
(use-package sh-script
  :hook (sh-mode . (lambda ()
                     (setq-local sh-basic-offset 2)
                     (setq-local tab-width 2)
                     (setq-local indent-tabs-mode nil)
                     (setq-local sh-shellcheck-arguments "-x"))))
#+end_src

** Pine Script

#+begin_src emacs-lisp
(use-package pine-script-mode
  :mode (("\\.pine" . pine-script-mode)))
#+end_src

* Org mode

** Basic Config

#+begin_src emacs-lisp
(use-package org
  :diminish (org-indent-mode)
  :commands (org-agenda org-switchb org-capture)
  :bind (("C-c o a" . org-agenda)
         ("C-c o b" . org-switchb)
         ("C-c o c" . org-capture)
         ("C-c o h" . org-insert-heading)
         ("C-c o H" . org-insert-subheading)
         ("C-c o l" . org-store-link)
         ("C-c o A" . my/org-agenda-custom-view)
         :map org-mode-map
         ("M-p" . org-babel-previous-src-block)
         ("M-n" . org-babel-next-src-block))
  :hook ((org-mode . org-indent-mode)
         (org-mode . visual-line-mode)
         (org-agenda-mode . (lambda () (hl-line-mode 1)))
         (org-babel-after-execute . org-redisplay-inline-images))
  :custom
  (org-emphasis-regexp-components
   '("-[:nonascii:][:space:]('\"{" "-[:space:][:nonascii:].,:!?;'\")}\\[" "[:space:]" "." 1))
  (org-agenda-format-date "%b %e (%a)")
  (org-agenda-file-regexp "\\`[^.].*\\.org\\\(\\.gpg\\\)?\\'")
  (org-agenda-sorting-strategy
   '((agenda habit-down time-up priority-down category-keep)
     (todo priority-down todo-state-up category-keep)
     (tags priority-down category-keep)
     (search category-keep)))
  (org-agenda-start-on-weekday calendar-week-start-day)
  (org-agenda-window-setup 'current-window)
  (org-log-into-drawer t)
  (org-list-allow-alphabetical t)
  (org-startup-indented t)
  (org-use-sub-superscripts '{})
  (org-export-with-sub-superscripts '{})
  (org-image-actual-width nil)
  (org-src-preserve-indentation nil)
  (org-edit-src-content-indentation 0)
  (org-src-window-setup 'other-window)
  (org-hide-leading-stars t)
  (org-src-fontify-natively t)
  (org-confirm-babel-evaluate nil)
  (org-hide-emphasis-markers t)
  ;; Work in Progress (WIP) status should be used exclusively for time recording
  ;; and should only be active while actively recording time.
  (org-todo-keywords
   '((sequence "TODO(t)" "NEXT(n!)" "ACTIVE(a!)" "WIP(i!/!)"
               "ONHOLD(h@/!)" "BLOCKED(b@/!)" "|" "DONE(d!)" "CANCELLED(c@)")
     (sequence "SHOPPING(s)" "LATER(l)" "|" "DONE(d!)" "CANCELLED(c@)")))
  (org-log-done 'time)
  (org-capture-templates nil) ;; Migrated to org-roam-capture.
  (org-agenda-files '("~/org/agenda.org" "~/org/economic-calendar.org"))
  (org-tag-alist
   '(("ai")
     ("algo")
     ("blog")
     ("bot")
     ("cloud")
     ("crypto")
     ("device")
     ("emacs")
     ("favorite")
     ("fx")
     ("finance")
     ("investing")
     ("life")
     ("llm")
     ("linux")
     ("ml")
     ("mt")
     ("net")
     ("news")
     ("options")
     ("org")
     ("project")
     ("reddit")
     ("security")
     ("tech")
     ("trading")
     ("youtube")
     ))
  (org-agenda-custom-commands
   '(("d" "Today"
      ((agenda ""
               ((org-agenda-span 'day)))
       (todo ""
             ((org-super-agenda-groups
               `((:name "Work In Progress" :and (:todo "WIP" :not (:children todo))
                        :face (:foreground "#333333" :background "#eecc00"))
                 (:name "Overdue" :and (:deadline past :not (:children todo))
                        :face (:foreground "#ff3300"))
                 (:name "Scheduled Past" :and (:scheduled past :not (:children todo))
                        :face (:foreground "#ff3300"))
                 (:name "Due Today" :and (:deadline today :not (:children todo))
                        :face (:foreground "#ffffff"))
                 (:name "Scheduled Today" :and (:scheduled today :not (:children todo))
                        :face (:foreground "#ffffff"))
                 (:name "Due Within a Week"
                        :deadline (before ,(format-time-string "%Y-%m-%d" (org-read-date nil t "+1w")))
                        :face (:foreground "#888888"))
                 (:name "Scheduled Within a Week"
                        :and ( :scheduled (before ,(format-time-string "%Y-%m-%d" (org-read-date nil t "+1w")))
                               :not (:habit t))
                        :face (:foreground "#888888"))
                 (:name "Active" :and (:todo "ACTIVE" :not (:children todo))
                        :face (:foreground "#ffff00"))
                 (:name "Blocked" :and (:todo "BLOCKED" :not (:children todo))
                        :face (:foreground "#8888bb"))
                 (:discard (:anything t))))
              (org-agenda-prefix-format
               '((todo . " %-2i %-18(my/org-get-todo-date-str)   %-10(my/org-agenda-property \"project\" 10)   ")))
              (org-agenda-overriding-header "Focused Tasks")))
       (tags-todo "+PROJECT=\"personal\"-TODO=\"SHOPPING\"-TODO=\"LATER\"-STYLE=\"habit\""
                  ((org-super-agenda-groups
                    '((:todo "NEXT")
                      (:todo "TODO")
                      (:todo "ONHOLD")
                      (:discard (:anything t))))
                   (org-use-property-inheritance '("project"))
                   (org-agenda-files (list (my/org-roam-project-file "personal" "tasks")))
                   (org-agenda-overriding-header "Personal Tasks Awaiting Processing")
                   (org-agenda-prefix-format
                    '((tags . " %-2i %-18(my/org-get-todo-date-str)   ")))))
       (tags-todo "-PROJECT=\"personal\"-TODO=\"SHOPPING\"-TODO=\"LATER\"-STYLE=\"habit\""
                  ((org-use-property-inheritance '("project"))
                   (org-super-agenda-groups
                    '((:todo "NEXT")
                      (:todo "ONHOLD")
                      (:discard (:anything t))))
                   (org-agenda-files (my/org-roam-projects))
                   (org-agenda-overriding-header "Next Project Tasks")))
       (todo "SHOPPING"
             ((org-use-property-inheritance '("project"))
              (org-super-agenda-groups
               '((:auto-property "project")
                 (:anything t)))
              (org-agenda-overriding-header "Shopping List")
              (org-agenda-prefix-format
               '((todo . " %-2i %-18(my/org-get-todo-date-str)   ")))))
       (todo "LATER"
             ((org-use-property-inheritance '("project"))
              (org-super-agenda-groups
               '((:auto-property "project")
                 (:anything t)))
              (org-agenda-overriding-header "Check Out Later")
              (org-agenda-prefix-format
               '((todo . " %-2i %-18(my/org-get-todo-date-str)   ")))))))
     ("p" "Projects"
      ((tags-todo "-PROJECT=\"personal\"+LEVEL<=4"
                  ((org-use-property-inheritance '("project"))
                   (org-super-agenda-groups
                    '((:auto-property "project")
                      (:discard (:anything t))))
                   (org-agenda-files (my/org-roam-projects))
                   (org-agenda-overriding-header "Projects")
                   (org-agenda-prefix-format
                    '((tags . " %-2i %-18(my/org-get-todo-date-str) %l")))))))
     ("h" "Habits"
      ((tags-todo "+PROJECT=\"personal\"+STYLE=\"habit\""
                  (
                   (org-use-property-inheritance '("project"))
                   (org-agenda-files (list (my/org-roam-project-file "personal" "tasks")))
                   (org-agenda-overriding-header "Habits")
                   (org-agenda-prefix-format
                    '((tags . " %-2i %-18(my/org-get-todo-date-str) ")))))))))
  (org-stuck-projects
   '("+PROJECT/-DONE-SOMEDAY" ("TODO" "WAIT")))

  ;; Moved from org-modern
  (org-auto-align-tags nil)
  (org-tags-column 0)
  (org-fold-catch-invisible-edits 'show-and-error)
  (org-special-ctrl-a/e t)
  (org-insert-heading-respect-content t)
  ;; Org styling, hide markup etc.
  (org-hide-emphasis-markers t)
  (org-pretty-entities t)
  ;; Agenda styling
  (org-agenda-block-separator ?─)
  (org-agenda-time-grid
   '((daily today require-timed remove-match)
     (800 1200 1800 2200)
     " ┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))
  (org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────")
  (org-ellipsis "⇣")
  (org-agenda-prefix-format
   '((agenda . " %-2i %21t%-10(my/org-agenda-property \"project\" 10)   ")
     (todo . " %-2i %-18(my/org-get-todo-date-str)   %-10(my/org-agenda-property \"project\" 10)   ")
     (tags . " %-2i %-18(my/org-get-todo-date-str)   %-10(my/org-agenda-property \"project\" 10)   ")
     (search . " %-2i %-18(my/org-get-todo-date-str)   %-10(my/org-agenda-property \"project\" 10)   ")))
  (org-deadline-warning-days 7)
  :config

  ;; Faces

  (custom-set-faces
   '(org-document-title ((t :height 1.5)))
   '(org-level-1 ((t :height 1.3
                     :weight bold
                     :foreground "LightGray"
                     :inherit org-default)))
   '(org-level-2 ((t :height 1.2
                     :weight bold
                     :foreground "SteelBlue3"
                     :inherit org-default)))
   '(org-level-3 ((t :height 1.1
                     :weight bold
                     :foreground "DarkSeaGreen4"
                     :inherit org-default)))
   '(org-level-4 ((t :foreground "tan3"
                     :inherit org-default)))
   '(org-level-5 ((t :foreground "DarkSlateGray4"
                     :inherit org-default)))
   '(org-level-6 ((t :foreground "IndianRed"
                     :inherit org-default)))
   '(org-level-7 ((t :foreground "DarkOrchid3"
                     :inherit org-default)))
   '(org-level-8 ((t :foreground "OliveDrab4"
                     :inherit org-default)))
   '(org-time-grid ((t :foreground "#666633")))
   '(org-todo ((t :foreground "#ffccaa")))
   '(org-agenda-current-time ((t :foreground "#cccc99" :weight bold)))
   '(org-upcoming-deadline ((t :foreground "#ff8800")))
   '(org-imminent-deadline ((t :foreground "#dd0000" :weight bold)))
   '(org-block-begin-line ((t :background "#2e3652")))
   '(org-block-end-line ((t :background unspecified
                            :inherit org-block-begin-line)))
   '(org-code ((t :foreground "sea green"
                  :family "Inconsolata Nerd Font")))
   '(org-ellipsis ((t  :inherit default :box nil)))
   '(org-scheduled ((t :foreground "#88cc88" :inherit default)))
   '(org-agenda-calendar-event ((t :inherit default)))
   '(org-agenda-date ((t :foreground "#3366aa" :weight bold :height 1.1)))
   '(org-agenda-date-today ((t :foreground "#6699cc" :weight bold :slant italic :inherit org-agenda-date)))
   '(org-agenda-date-weekend ((t :foreground "#aa6633" :inherit org-agenda-date)))
   '(org-agenda-date-weekend-today ((t :foreground "#cc9966" :inherit org-agenda-date-today)))
   '(org-agenda-structure ((t :family "Noto Serif" :foreground "#cccc88" :weight bold :height 1.2)))
   '(org-headline-done ((t :foreground "#999999" :background "#333333"))))
  (unless my/transparent-bg-p
    (set-face-background 'org-block "#252938"))

  (defun my/org-setup-variable-font ()
    "Override default face with variable fonts."
    (interactive)
    ;; Make org-default separate from default face so headers will keep using
    ;; Sans font.
    (set-face-attribute 'org-default nil
                        :font (face-attribute 'default :font)
                        :fontset (face-attribute 'default :fontset)
                        :inherit 'unspecified)
    (variable-pitch-mode))

  (defun my/org-agenda-property (property &optional width)
    "Helper function to retrieve the string representation of a specified property."
    ;; (message "%s" (org-entry-properties))
    (let ((prop
           (when (derived-mode-p 'org-mode)  ;; could be org-agenda buffer (e.g. time-grid entry)
             (let ((value (org-entry-get nil property t)))
               (if (and width (> (length value) width))
                   (concat (substring value 0 (- width 2)) "..")
                 value)))))
      (if prop prop "")))

  (defun my/org-get-todo-date-str ()
    "Get formatted date string from current org todo entry."
    (let* ((timestamp (org-entry-get nil "TIMESTAMP"))
           (scheduled (org-entry-get nil "SCHEDULED"))
           (deadline (org-entry-get nil "DEADLINE"))
           (todo  (org-entry-get nil "TODO"))
           (format-date
            (lambda (date-str)
              (when date-str
                (let* ((time (org-time-string-to-time date-str))
                       (has-time (nth 1 (org-parse-time-string date-str t)))
                       (format-str (if has-time "%Y-%m-%d %k:%M" "%Y-%m-%d")))
                  (format-time-string format-str time))))))
      (cond
       ;; Return timestamp if exists
       (timestamp
        (format "🗓%s" (funcall format-date timestamp)))
       ;; Return combined scheduled and deadline if both exist
       ((and scheduled deadline) 
        (format "🕛%s⏰%s"
                (funcall format-date scheduled)
                (funcall format-date deadline)))
       ;; Return only scheduled if it exists
       (scheduled
        (format "🕛%s" (funcall format-date scheduled)))
       ;; Return deadline with ~ prefix if only deadline exists
       (deadline
        (format "⏰%s" (funcall format-date deadline)))
       ;; Return empty string if no date information exists
       (t ""))))

  ;; Set up category icons using Noto Color Emoji.

  (defvar my/org-agenda-category-emoji-icon-alist
    '(("gcal" . "🗓")
      ("task" . "✅")
      ("journal" . "📃")
      ("Holiday" . "🎌")
      ("us-market-holidays" . "⛔")
      ("economic-calendar" . "📈")))

  (defun my/emoji-icon (emoji &rest props)
    "propertize EMOJI suitable for org-agenda-category-icon-alist."
    (let ((face `(:family "Noto Color Emoji" ,@props)))
      (propertize emoji
                  'face face
                  'font-lock-face face
                  'rear-nonsticky t)))

  (defun my/org-agenda-set-category-emoji-icon ()
    "Set up category icon as per my/org-agenda-category-emoji-icon-alist."
    (dolist (entry my/org-agenda-category-emoji-icon-alist)
      (let ((category (car entry))
            (emoji (cdr entry)))
        (add-to-list 'org-agenda-category-icon-alist
                     (list category
                           (list (my/emoji-icon emoji))
                           nil nil :ascent 'center)))))

  ;; Set up hooks for org-clock
  (org-clock-persistence-insinuate)

  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "D")
                (lambda () (interactive) (org-agenda nil "d")))
    (define-key org-agenda-mode-map (kbd "P")
                (lambda () (interactive) (org-agenda nil "p")))
    (define-key org-agenda-mode-map (kbd "H")
                (lambda () (interactive) (org-agenda nil "h")))
    (define-key org-agenda-mode-map (kbd "p") #'org-agenda-backward-block)
    (define-key org-agenda-mode-map (kbd "n") #'org-agenda-forward-block)
    (my/org-agenda-set-category-emoji-icon))

  ;; Reset org-emp-re and org-verbatim-re to take non ASCII characters into
  ;; account for boundary of emphasis.
  (setopt org-emphasis-alist org-emphasis-alist)  ;; trigger org-set-emph-re

  ;; Patched org-do-emphasis-faces to allow nested emphasis markers.

  (defun my/org-do-emphasis-faces-9.7 (limit)
    "Run through the buffer and emphasize strings."
    (let ((quick-re (format "\\([%s]\\|^\\)\\([~=*/_+]\\)"
                            (car org-emphasis-regexp-components))))
      (catch :exit
        (while (re-search-forward quick-re limit t)
          (let* ((marker (match-string 2))
                 (verbatim? (member marker '("~" "="))))
            (when (save-excursion
                    (goto-char (match-beginning 0))
                    (and
                     ;; Do not match table hlines.
                     (not (and (equal marker "+")
                               (org-match-line
                                "[ \t]*\\(|[-+]+|?\\|\\+[-+]+\\+\\)[ \t]*$")))
                     ;; Do not match headline stars.  Do not consider
                     ;; stars of a headline as closing marker for bold
                     ;; markup either.
                     (not (and (equal marker "*")
                               (save-excursion
                                 (forward-char)
                                 (skip-chars-backward "*")
                                 (looking-at-p org-outline-regexp-bol))))
                     ;; Match full emphasis markup regexp.
                     (looking-at (if verbatim? org-verbatim-re org-emph-re))
                     ;; Do not span over paragraph boundaries.
                     (not (string-match-p org-element-paragraph-separate
                                          (match-string 2)))
                     ;; Do not span over cells in table rows.
                     (not (and (save-match-data (org-match-line "[ \t]*|"))
                               (string-match-p "|" (match-string 4))))))
              (pcase-let ((`(,_ ,face ,_) (assoc marker org-emphasis-alist))
                          (m (if org-hide-emphasis-markers 4 2)))
                (font-lock-prepend-text-property
                 (match-beginning m) (match-end m) 'face face)
                (when verbatim?
                  (org-remove-flyspell-overlays-in
                   (match-beginning 0) (match-end 0))
                  (remove-text-properties (match-beginning 2) (match-end 2)
                                          '(display t invisible t intangible t)))
                (add-text-properties (match-beginning 2) (match-end 2)
                                     '(font-lock-multiline t org-emphasis t))
                (when (and org-hide-emphasis-markers
                           (not (org-at-comment-p)))
                  (add-text-properties (match-end 4) (match-beginning 5)
                                       '(invisible t))
                  ;; https://orgmode.org/list/8b691a7f-6b62-d573-e5a8-80fac3dc9bc6@vodafonemail.de
                  (org-rear-nonsticky-at (match-beginning 5))
                  (add-text-properties (match-beginning 3) (match-end 3)
                                       '(invisible t))
                  ;; FIXME: This would break current behavior with point
                  ;; being adjusted before hidden emphasis marker when
                  ;; using M-b.  A proper fix would require custom
                  ;; syntax function that will mark emphasis markers as
                  ;; word constituents where appropriate.
                  ;; https://orgmode.org/list/87edl41jf0.fsf@localhost
                  ;; (org-rear-nonsticky-at (match-end 3))
                  )
                ;; Perform recursive call to process potential nested markers.
                (save-excursion
                  (save-restriction
                    (let ((start (match-beginning 4))
                          (end (match-end 4)))
                      ;; (message "do recursive call with [%s]" (buffer-substring start end))
                      (narrow-to-region start end)
                      (goto-char start)
                      (org-do-emphasis-faces end))))
                (throw :exit t))))))))

  (defun my/org-do-emphasis-faces-9.6 (limit)
    "Run through the buffer and emphasize strings."
    (let ((quick-re (format "\\([%s]\\|^\\)\\([~=*/_+]\\)"
                            (car org-emphasis-regexp-components))))
      (catch :exit
        (while (re-search-forward quick-re limit t)
          (let* ((marker (match-string 2))
                 (verbatim? (member marker '("~" "="))))
            (when (save-excursion
                    (goto-char (match-beginning 0))
                    (and
                     ;; Do not match table hlines.
                     (not (and (equal marker "+")
                               (org-match-line
                                "[ \t]*\\(|[-+]+|?\\|\\+[-+]+\\+\\)[ \t]*$")))
                     ;; Do not match headline stars.  Do not consider
                     ;; stars of a headline as closing marker for bold
                     ;; markup either.
                     (not (and (equal marker "*")
                               (save-excursion
                                 (forward-char)
                                 (skip-chars-backward "*")
                                 (looking-at-p org-outline-regexp-bol))))
                     ;; Match full emphasis markup regexp.
                     (looking-at (if verbatim? org-verbatim-re org-emph-re))
                     ;; Do not span over paragraph boundaries.
                     (not (string-match-p org-element-paragraph-separate
                                          (match-string 2)))
                     ;; Do not span over cells in table rows.
                     (not (and (save-match-data (org-match-line "[ \t]*|"))
                               (string-match-p "|" (match-string 4))))))
              (pcase-let ((`(,_ ,face ,_) (assoc marker org-emphasis-alist))
                          (m (if org-hide-emphasis-markers 4 2)))
                (font-lock-prepend-text-property
                 (match-beginning m) (match-end m) 'face face)
                (when verbatim?
                  (org-remove-flyspell-overlays-in
                   (match-beginning 0) (match-end 0))
                  (when (and (org-fold-core-folding-spec-p 'org-link)
                             (org-fold-core-folding-spec-p 'org-link-description))
                    (org-fold-region (match-beginning 0) (match-end 0) nil 'org-link)
                    (org-fold-region (match-beginning 0) (match-end 0) nil 'org-link-description))
                  (remove-text-properties (match-beginning 2) (match-end 2)
                                          '(display t invisible t intangible t)))
                (add-text-properties (match-beginning 2) (match-end 2)
                                     '(font-lock-multiline t org-emphasis t))
                (when (and org-hide-emphasis-markers
                           (not (org-at-comment-p)))
                  (add-text-properties (match-end 4) (match-beginning 5)
                                       '(invisible t))
                  (add-text-properties (match-beginning 3) (match-end 3)
                                       '(invisible t)))
                ;; Perform recursive call to process potential nested markers.
                (save-excursion
                  (save-restriction
                    (let ((start (match-beginning 4))
                          (end (match-end 4)))
                      (narrow-to-region start end)
                      (goto-char start)
                      (org-do-emphasis-faces end))
                    )
                  )
                (throw :exit t))))))))

  (advice-add #'org-do-emphasis-faces :override
              (if (= (string-to-number org-version) 9.7)
                  #'my/org-do-emphasis-faces-9.7
                #'my/org-do-emphasis-faces-9.6))

  ;; Enable template expansion with '<' prefix.
  (require 'org-tempo)

  ;; (font-lock-add-keywords 'org-mode
  ;;                         '(("^ *\\([-]\\) "
  ;;                            (0 (prog1 ()
  ;;                                 (compose-region (match-beginning 1)
  ;;                                                 (match-end 1) "•"))))))

  ;; Enable babel for languages.
  (require 'ob-shell)
  (require 'ob-java)
  (require 'ob-python)
  (require 'ob-C)
  (require 'ob-emacs-lisp)
  (require 'ob-org)
  (require 'ob-awk)
  (require 'ob-sed)
  (require 'ob-js)
  (require 'ob-css)

  ;; Additional languages through lang-modes.
  (setq org-src-lang-modes
        (append org-src-lang-modes
                '(("conf" . conf)
                  ("ini" . conf)
                  ("jupyter-python" . python-ts)
                  ("python" . python-ts)
                  ("c++" . c++-ts)
                  ("mql4" . c++-ts)
                  ("mql5" . c++-ts))))

  ;; For Encrypting contents.
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
  ;; GPG key to use for encryption
  ;; Either the Key ID or set to nil to use symmetric encryption.
  (setq org-crypt-key (getenv "ORG_CRYPT_KEY"))

  ;; Open custom agenda view on startup.
  (defun my/org-agenda-custom-view ()
    (interactive)
    (when (file-directory-p my/org-roam-project-root)
      (org-agenda nil "d")))

  (add-hook 'emacs-startup-hook 'my/org-agenda-custom-view))

  ;; add org-roam-directory to consult-omni-notes's source list
  (with-eval-after-load 'consult-omni-notes
    (add-to-list 'consult-omni-notes-files org-directory))
#+end_src

#+begin_src emacs-lisp
(use-package org-habit
  :straight nil
  :after org
  :hook (org-agenda-mode . my/org-habit-set-graph-column)
  :custom
  (org-habit-show-habits nil)  ;; Type K to toggle showing consistency graph.
  (org-habit-show-done-always-green t)
  (org-habit-overdue-glyph ?○)
  (org-habit-alert-glyph ?○)
  (org-habit-today-glyph ?○)
  (org-habit-completed-glyph ?●)
  (org-habit-preceding-days 7)
  (org-habit-following-days 1)
  (org-habit-show-all-today t)
  :config
  (defun my/org-habit-set-graph-column ()
    "Set graph column based on window-width."
    (setq org-habit-graph-column (- (window-width) 10)))

  ;; Borrowed from https://www.reddit.com/r/emacs/comments/1ik87vs/my_edited_orghabit_module/
  (custom-set-faces
   '(org-habit-clear-face
     ((t ( :background "pale green"
           :foreground "#00aa00"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-clear-future-face
     ((t ( :background "gray"
           :foreground "#444444"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-alert-future-face
     ((t ( :background "light coral"
           :foreground "#aa0000"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-alert-face
     ((t ( :background "light coral"
           :foreground "#aa0000"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-overdue-face
     ((t ( :background "light coral"
           :foreground "#aa0000"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-overdue-future-face
     ((t ( :background "gray"
           :foreground "#444444"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-ready-face
     ((t ( :background "pale green"
           :foreground "#00aa00"
           :width expanded
           :height 1.0
           :box (:line-width (1 . 1) :color "white")))))
   '(org-habit-ready-future-face
     ((t (;;:background ""
          :foreground "#444444"
          :width expanded
          :height 1.0
          :box (:line-width (1 . 1) :color "white")))))))
#+end_src

#+begin_src emacs-lisp
(use-package org-clock
  :straight nil
  :commands (my/org-update-clock org-clock-in org-clock-out)
  :hook (org-after-todo-state-change . my/org-update-clock)
  :custom-face
  (org-agenda-clocking ((t :foreground "#ffcc00" :background "unspecified")))
  :custom
  (org-clock-persist t)
  :config
  (defun my/org-update-clock ()
    "Update clock state. Called via org-after-todo-state-change-hook."
    (interactive)
    (if (string= org-state "WIP")
        (unless (org-clocking-p)
          (org-clock-in))
      (when (org-clocking-p)
        (org-clock-out)))))
#+end_src

** org-bebel extensions

#+begin_src emacs-lisp
(use-package ob-go
  :after org)
#+end_src

#+begin_src emacs-lisp
(use-package ob-rust
  :after org)
#+end_src

#+begin_src emacs-lisp
(use-package ob-async
  :after org
  :config
  (setq ob-async-no-async-languages-alist '("jupyter-python" "jupyter-julia")))
#+end_src

** org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :bind (("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n l" . org-roam-buffer-toggle)
         ("C-c n t a" . org-roam-tag-add)
         ("C-c n t r" . org-roam-tag-remove)
         ("C-c o p j" . my/org-roam-project-capture-journal)
         ("C-c o p t" . my/org-roam-project-capture-task)
         ("C-c o j" . my/org-roam-personal-capture-journal)
         ("C-c o t" . my/org-roam-personal-capture-task)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  :hook (after-init . (lambda ()
                        (require 'org-roam-protocol)))
  :custom
  (org-roam-node-display-template (concat "${title:*} " (propertize "${tags:30}" 'face 'org-tag)))
  (org-roam-capture-templates
   '(("c" "add a contact note" entry "* ${title}\n%?" :target
      (file+head "resources/contacts.org" "#+title: Personal Contacts\n")
      :unnarrowed t)
     ("f" "add a fleeting note" plain "%?" :target
      (file+head "fleeting/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("l" "add a literature note" plain "%?" :target
      (file+head "literature/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("r" "add a resource note" plain "%?" :target
      (file+head "resources/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("S" "add a secure note" plain "%?" :target
      (file+head "secure/${slug}.org.gpg" "#+title: ${title}\n")
      :unnarrowed t)))
  (org-roam-capture-ref-templates
   '(("r" "add a note through org-protocol://roam-ref" plain "%?"
      :target (file+head "fleeting/${slug}.org"
                         "#+title: ${title}")
      :unnarrowed t)))
  :init
  (setq org-roam-directory "~/org/roam")
  (setq my/org-roam-project-root "~/org/roam/projects")

  (defun my/org-roam-projects (&optional name-only include-personal)
    (when (file-directory-p my/org-roam-project-root)
      (let ((projects (directory-files my/org-roam-project-root (not name-only) "\\`[^.]")))
        (if include-personal projects
          (seq-filter (lambda (ent)
                        (not (string-match-p "\\(\\`\\|/\\)personal\\'" ent)))
                      projects)))))

  ;; Add project files to org-agenda.
  (setq org-agenda-files
        (append org-agenda-files (my/org-roam-projects nil t)))
  :config
  (unless (file-directory-p org-roam-directory)
    (mkdir org-roam-directory t))
  (org-roam-db-autosync-enable)

  ;; Helper functions for journaling and task management with Org Roam.
  ;; - "project" related org files are stored under projects/ directory.
  ;; - "personal" project is special one for personal daily matters.

  (defun my/org-roam-project-add-properties (prj &optional props)
    "A hook for org-roam-capture-new-node-hook to add project
 property and additional properties to the new file."
    (let ((pos (point)))
      (org-entry-put (point) "project" prj)
      (when props
        (dolist (entry props)
          (org-entry-put pos (car entry) (cdr entry))))))

  (defun my/org-roam-project-dir (prj)
    (file-name-concat my/org-roam-project-root prj))

  (defun my/org-roam-project-file (prj basename)
    (format "%s/%s.org" (my/org-roam-project-dir prj) basename))

  (defun my/org-roam-project-target (prj plist)
    "Return org-capture target."
    (let* ((basename (plist-get plist :basename))
           (file (my/org-roam-project-file prj basename))
           (node-headline (or (plist-get plist :node-headline) (capitalize basename)))
           (target (plist-get plist :target)))
      (pcase target
        ('file+olp+datetree `(,target ,file))
        ('file+headline `(,target ,file ,node-headline))
        (_ `(file ,file)))))

  (defun my/org-roam-project-create-new-file (prj plist)
    "Set up a new file node for the project.
     - create a project directory under projects/ if needed.
     - setup a new file node."
    (let* ((prj-dir (my/org-roam-project-dir prj))
           (basename (plist-get plist :basename))
           (file (my/org-roam-project-file prj basename))
           (title (or (plist-get plist :title) (format "Project %s: %s" prj basename)))
           (props (plist-get plist :property))
           (org-roam-capture-templates
            `(("d" "default - create a new node"
               plain "%?"
               :target (file+head ,file "#+title: ${title}\n")
               :immediate-finish t)))
           (node (org-roam-node-create :file file :title title))
           (hook (lambda ()
                   (my/org-roam-project-add-properties prj props))))
      (unless (file-directory-p prj-dir)
        (mkdir prj-dir t))
      (add-hook 'org-roam-capture-new-node-hook hook)
      (org-roam-capture- :node node)
      (remove-hook 'org-roam-capture-new-node-hook hook)))

  (defun my/org-roam-project-read ()
    (interactive)
    (completing-read "Project: " (my/org-roam-projects t) nil 'confirm))

  (defun my/org-roam-project-capture (prj plist)
    "Capture new task for the selected project."
    (let* ((basename (plist-get plist :basename))
           (target (my/org-roam-project-target prj plist))
           (org-capture-templates
            `(("d" "capture a new entry to the selected project"
               entry ,target ,(plist-get plist :headline)
               :unnarrowed t :kill-buffer t))))
      (unless (file-exists-p (my/org-roam-project-file prj basename))
        (my/org-roam-project-create-new-file prj plist))
      (org-capture nil "d")))

  (defun my/org-roam-project-capture-journal (prj)
    "Capture new journal for the selected project."
    (interactive (list (my/org-roam-project-read)))
    (my/org-roam-project-capture prj '( :basename "journal"
                                        :target file+olp+datetree
                                        :headline "* %<%H:%M> %?")))

  (defun my/org-roam-project-capture-task (prj &optional node-headline headline)
    "Capture new task for the selected project."
    (interactive (list (my/org-roam-project-read)))
    (my/org-roam-project-capture prj `( :basename "tasks"
                                        :target file+headline
                                        :node-headline ,(or node-headline "Tasks")
                                        :headline ,(or headline "* TODO %?")
                                        :property (("category" . "task")))))

  (defun my/org-roam-personal-capture-journal ()
    "Capture new journal for personal project."
    (interactive)
    (my/org-roam-project-capture-journal "personal"))

  (defun my/org-roam-personal-capture-task (task-type)
    "Capture new task for personal project."
    (interactive (list (completing-read "Task Type: " '("Task" "Shopping" "Later"))))
    (let ((node-headline (cond
                          ((string= task-type "Shopping") "Shopping List")
                          ((string= task-type "Later") "Check Out Later")))
          (headline (cond
                     ((string= task-type "Shopping") "* SHOPPING %?")
                     ((string= task-type "Later") "* LATER %u %?"))))
      (my/org-roam-project-capture-task "personal" node-headline headline)))

  ;; Comment out as org-mode config adds org-directory (parent of org-roam-directory).
  ;; ;; add org-roam-directory to consult-omni-notes's source list
  ;; (with-eval-after-load 'consult-omni-notes
  ;;   (add-to-list 'consult-omni-notes-files org-roam-directory))
  )
#+end_src

*** org-roam-ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :diminish
  :straight ( :host github
              :repo "org-roam/org-roam-ui"
              :branch "main"
              :files ("*.el" "out"))
  :after org-roam
  :bind ("C-c n g" . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src

*** org-roam-timestamps

add ctime and mtime properties to org-roam nodes.

#+begin_src emacs-lisp
(use-package org-roam-timestamps
  :diminish
  :after org-roam
  :custom
  (org-roam-timestamps-remember-timestamps nil)
  :config
  (org-roam-timestamps-mode))
#+end_src

** org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :hook ((org-mode . org-modern-mode)
         (org-agenda-finalize . org-modern-agenda)
         (org-modern-mode . my/org-modern-mode-hook))
  ;; :custom
  ;; Uncomment if org-modern-table conflicts with valign-mode.
  ;; (org-modern-table nil)
  :config
  ;; borrowed from https://misohena.jp/blog/2022-08-27-fix-org-table-lines-using-org-modern-and-org-indent.html

  (defun my/org-modern-mode-hook ()
    (set-face-foreground 'org-hide "black"))

  (defun my/org-indent--compute-prefixes-after ()
    ;; org-indent--text-line-prefixes is line-prefix at each level。
    ;; This function is called after org-indent--compute-prefixes calculates the prefixes.
    (let ((prefixes org-indent--text-line-prefixes))
      ;; Fix prefix at each level.
      (dotimes (i (length prefixes))
        (let* ((space-str (aref prefixes i))
               (space-length (length space-str)))
          (when (> space-length 0)
            (aset prefixes i
                  ;; Add the text property `display (space :width i :height
                  ;; (1))`.  This displays a 1px high space instead of a blank
                  ;; character as the line prefix, correctly reflecting line
                  ;; height. Previously, lines wouldn't shrink below the height
                  ;; of the blank prefix.
                  (org-add-props
                      space-str
                      nil
                    'display (cons 'space
                                   (list :width space-length
                                         ;; (list (* space-length
                                         ;;          (frame-char-width)))
                                         :height '(1))))))))))
  ;; (advice-add #'org-indent--compute-prefixes :after
  ;;             #'my/org-indent--compute-prefixes-after))
)
#+end_src

** org-modern-indent

Disabled for now as it's not working well with some Org buffers (e.g. copilot-chat).

#+begin_src emacs-lisp
(use-package org-modern-indent
  :straight (org-modern-indent
             :type git
             :host github
             :repo "jdtsmith/org-modern-indent")
  :config
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+end_src

** org-cliplink

#+begin_src emacs-lisp
(use-package org-cliplink
  :custom
  (org-cliplink-transport-implementation 'curl)
  (org-cliplink-curl-transport-arguments '("--http2" "-L"))
  :bind (("C-c o L" . org-cliplink)))
#+end_src

** ox-hugo

#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox
  :custom
  (org-hugo-default-section-directory "posts"))
#+end_src

** ox-pandoc

#+begin_src emacs-lisp
(use-package ox-pandoc
  :after ox)
#+end_src

** org-download

As of 3/19/2022, this does not work with Chrome. Works well with Firefox.

#+begin_src emacs-lisp
(use-package org-download
  :hook ((org-mode . org-download-enable)
         (dired-mode . org-download-enable))
  :bind ("C-c o s" . org-download-screenshot)
  :custom
  (org-download-screenshot-method "spectacle -b -r -o %s")
  (org-download-image-dir "./images")
  (org-download-heading-lvl nil))
#+end_src

** org-appear

#+begin_src emacs-lisp
(use-package org-appear
  :straight (org-appear :type git :host github :repo "awth13/org-appear")
  :hook (org-mode . org-appear-mode))
#+end_src

** org-remoteimg

Display remote images specified by URLs inline in org-mode.

#+begin_src emacs-lisp
(use-package org-remoteimg
  :straight (org-remoteimg :type git :host github :repo "gaoDean/org-remoteimg")
  :custom
  (org-display-remote-inline-images 'cache) ;; enable caching
  )
#+end_src

** org-fragtog

Disabled at the moment in favor of xenops.

#+begin_src emacs-lisp
(use-package org-fragtog
  :disabled
  :after org
  :straight (org-fragtog
             :type git
             :host github
             :repo "io12/org-fragtog"
             :files ("*.el"))
  :hook (org-mode . org-fragtog-mode))
#+end_src

** Latex support

#+begin_src emacs-lisp
(use-package org
  :custom
  (org-preview-latex-default-process 'dvisvgm)
  (org-latex-default-class "bxjsarticle")
  (org-latex-pdf-process '("latexmk -xelatex %f"))
  ;; (org-latex-pdf-process '("latexmk -e '$lualatex=q/lualatex %%S/' -e '$bibtex=q/bibtexu %B/' -e '$biber=q/biber --bblencoding=utf8 -u -U --output_safechars %B/' -e '$makeindex=q/upmendex -o %%D %%S/' -norc -gg -pdflua %f"))
  ;; (org-latex-pdf-process '("latexmk -e '$latex=q/uplatex -kanji=utf8 -no-guess-input-enc %%S/' -e '$bibtex=q/bibtexu %B/' -e '$biber=q/biber --bblencoding=utf8 -u -U --output_safechars %B/' -e '$makeindex=q/upmendex -o %%D %%S/' -e '$dvipdf=q/dvipdfmx -o %%D %%S/' -norc -gg -pdfdvi %f"))
  :config
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes
                 '("jlreq-article"
                   "\\ifdefined\\kanjiskip
  \\documentclass[uplatex,dvipdfmx,11pt,paper=a4]{jlreq}
\\else
  \\documentclass[11pt,paper=a4]{jlreq}
\\fi
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\usepackage{mathtools}
\\usepackage{newtxtext,newtxmath}
\\ifdefined\\kanjiskip
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\hypersetup{pdfencoding=auto,colorlinks=true}
\\fi"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    (add-to-list 'org-latex-classes
                 '("jlreq-article-tate"
                   "\\ifdefined\\kanjiskip
  \\documentclass[uplatex,dvipdfmx,tate,11pt,paper=a4]{jlreq}
\\else
  \\documentclass[tate,11pt,paper=a4]{jlreq}
\\fi
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\usepackage{mathtools}
\\usepackage{newtxtext,newtxmath}
\\ifdefined\\kanjiskip
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\hypersetup{pdfencoding=auto,colorlinks=true}
\\fi"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    (add-to-list 'org-latex-classes
                 '("bxjsarticle"
                   "\\documentclass[autodetect-engine,dvi=dvipdfmx,11pt,a4paper,ja=standard]{bxjsarticle}
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\usepackage{mathtools}
\\usepackage{mathcomp}
\\usepackage{newtxtext,newtxmath}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\ifdefined\\kanjiskip
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\ifdefined\\XeTeXversion
      \\hypersetup{colorlinks=true}
  \\else
    \\ifdefined\\directlua
      \\hypersetup{pdfencoding=auto,colorlinks=true}
    \\else
      \\hypersetup{unicode,colorlinks=true}
    \\fi
  \\fi
\\fi"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    )

  ;;
  ;; Adjust line prefix and vertical margin on overlay equations.
  ;;

  (defun my/org-adjust-preview-overlay (beg end image &optional imagetype)
    "Adjust latex preview images as follows:
       1) vertically align them with the text on the same line.
       2) center equations in latex environments."
    (let* ((ov (car (overlays-at beg end)))
           (ovlbp (car (overlays-at (line-beginning-position))))
           (disp (overlay-get ov 'display))
           (img (cdr disp)))
      (when (and (string-match-p "\\`\\s-*\\'" (buffer-substring
                                                (line-beginning-position) beg))
                 (string-match-p "\\(\\`\\|[\]$}]\\)\\s-*\\'"
                                 (buffer-substring end (line-end-position))))
        ;; Center equations in latex environments.
        (overlay-put ov 'before-string (propertize " " 'display
                                                   `(space :align-to (- center (0.5 . ,disp)))))

        ;; Another option: Add 4 spaces to the current indentation level.
        ;; (let* ((prefix-len (length (get-text-property beg 'line-prefix)))
        ;;        (indent-width (+ prefix-len
        ;;                         (length (buffer-substring
        ;;                                  (line-beginning-position) beg))
        ;;                         4)))
        ;;   (overlay-put ov 'before-string (propertize " " 'display
        ;;                                              `(space :width ,indent-width))))
        )

      ;; add vertical margin
      (let ((margin
             (if (string-match-p "\\([sS]erif\\|[mM]incho\\)" (face-attribute 'default :family))
                 4 1)))
        (plist-put img :margin `(0 . ,margin)))
      ))

  (advice-add 'org--make-preview-overlay :after 'my/org-adjust-preview-overlay)

  ;;
  ;; Config for latex preview which supports Japanese text in math mode with \text{}.
  ;;

  ;; Product svgs to have transparent fg/bg colors.
  (plist-put org-format-latex-options :foreground nil)
  (plist-put org-format-latex-options :background nil)

  ;; Header for xelatex supporting Japanese text.
  (setq org-format-latex-header "\\documentclass[a4paper,xelatex,12pt,ja=standard]{bxjsarticle}
\\usepackage[usenames]{color}
\[DEFAULT-PACKAGES]
\[PACKAGES]
\\usepackage{amsmath}
\\usepackage{mathtools}
\\usepackage{mathcomp}
\\usepackage{newtxtext,newtxmath}
\\usepackage{graphicx}
\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}")

  ;; Use xelatex to produce svgs supporting Japanese text.
  (setf (alist-get 'dvisvgm org-preview-latex-process-alist)
        '( :programs
           ("xelatex" "dvisvgm")
           :description "xdv > svg" :message "you need to install the programs: latex and dvisvgm." :image-input-type "xdv" :image-output-type "svg" :image-size-adjust
           (1.7 . 1.5)
           :latex-compiler
           ("xelatex -no-pdf -interaction nonstopmode -output-directory %o %f")
           :image-converter
           ("dvisvgm %f --no-fonts --exact-bbox --scale=%S --output=%O")))
  )
#+end_src

Install cdlatex to enable some useful features. cdlatex depends on texmathp.el in AUCTeX hence AUCTeX as well.

#+begin_src emacs-lisp
(use-package cdlatex
  :hook ((LaTeX-mode . turn-on-cdlatex)
         (latex-mode . turn-on-cdlatex)
         (cdlatex-mode . my/setup-cdlatex-mode)
         (org-cdlatex-mode . my/setup-cdlatex-mode))
  :bind ( :map org-cdlatex-mode-map
          ("$" . cdlatex-dollar)
          ("(" . cdlatex-pbb)
          ("{" . cdlatex-pbb)
          ("[" . cdlatex-pbb)
          ("|" . cdlatex-pbb)
          ("<" . cdlatex-pbb))
  :custom
  (cdlatex-paired-parens "$([{")
  :config
  (defun my/setup-cdlatex-mode ()
    "Setup config suitable for cdlatex-mode and org-cdlatex-mode."
    (require 'auctex)
    (setq-local org-pretty-entities-include-sub-superscripts nil)
    (electric-pair-mode -1))
)
#+end_src

Here is a Workaround for latex preview scaling issues that I borrow from [[https://karthinks.com/software/scaling-latex-previews-in-emacs/]].

#+begin_src emacs-lisp
(use-package org
  :hook (text-scale-mode . my/text-scale-adjust-latex-previews)
  :config
  (defun my/text-scale-adjust-latex-previews ()
    "Adjust the size of latex preview fragments when changing the buffer's text scale."
    (pcase major-mode
      ('latex-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'category)
                 'preview-overlay)
             (my/text-scale--resize-fragment ov))))
      ('org-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'org-overlay-type)
                 'org-latex-overlay)
             (my/text-scale--resize-fragment ov))))))

  (defun my/text-scale--resize-fragment (ov)
    (overlay-put
     ov 'display
     (cons 'image
           (plist-put
            (cdr (overlay-get ov 'display))
            :scale (+ 1.0 (* 0.25 text-scale-mode-amount))))))
  )
#+end_src

Seeme like Xenops can replace slow latex preview. Trying it out now.

#+begin_src emacs-lisp
(use-package xenops
  :after org
  :hook ((cdlatex-mode org-cdlatex-mode) . xenops-mode)
  :config

  (setq xenops-reveal-on-entry t)
  (setq xenops-math-image-scale-factor 1.2)

  ;; Override xenops specific latex processs alist with org-preview-latex one.
  (setq xenops-math-latex-process-alist org-preview-latex-process-alist)

  ;; Override xenops-math-reveal to prevent unwanted cursor jump.
  ;; https://github.com/dandavison/xenops/issues/59
  (defun xenops-math-reveal (element)
    "Remove image overlay for ELEMENT.
If a prefix argument is in effect, also delete its cache file."
    (xenops-element-overlays-delete element)
    (if current-prefix-arg
        (delete-file (xenops-math-get-cache-file element)))
    ;; TODO: is :begin-content for block math off by one?
    (let ((element-type (plist-get element :type))
          (begin-content (plist-get element :begin-content)))
      )
    (xenops-math-render-below-maybe element))

  ;; Fix background color issues with fragment images.
  (defun my/xenops-tweak-latex-document (orig-fn &rest args)
    "Delete \\pagecolor and \\color directives from the output so latex fragment will have transparent background."
    (let ((output (apply orig-fn args)))
      (replace-regexp-in-string "\\\\\\(page\\)?color{\\w+}" "" output)))

  (advice-add 'xenops-math-latex-make-latex-document :around #'my/xenops-tweak-latex-document))
#+end_src

** Citation

Citar provides a rich UI frontend for org-cite. citar-org-roam provides more integration with org-roam.

#+begin_src emacs-lisp
(use-package citar
  :no-require
  :bind ("C-c n n" . citar-create-note)
  :hook (org-mode . citar-capf-setup)
  :custom
  (require 'bibtex)
  (org-cite-global-bibliography '("~/lib/bib/references.bib"))
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-notes-paths '((file-name-concat org-roam-directory "literature")))
  (citar-bibliography org-cite-global-bibliography))

(use-package citar-embark
  :after (citar embark)
  :no-require
  :config (citar-embark-mode))

(use-package citar-org-roam
  :diminish
  :after (citar org-roam)
  :custom
  (citar-org-roam-subdir "literature")
  (citar-org-roam-note-title-template "[${author}] ${title}")
  (citar-org-roam-capture-template-key "n")
  :config
  (add-to-list
   'org-roam-capture-templates
   '("n" "add literature note through Citar" plain
     "%?"
     :target
     (file+head
      "%(expand-file-name (or citar-org-roam-subdir \"\") org-roam-directory)/${citar-citekey}.org"
      "#+title: ${note-title}\n#+author: ${citar-author}\n#+released_on: ${citar-date}\n\n")
     :unnarrowed t) 'append)
  (citar-org-roam-mode))
#+end_src

** org-gcal

#+begin_src emacs-lisp
(use-package org-gcal
  :straight (:type git :host github :repo "kidd/org-gcal.el")
  :commands (org-gcal-fetch org-gcal-reload-client-id-secret)
  :init
  (setq org-agenda-files (append
                          org-agenda-files
                          '("~/org/gcal.org"
                            "~/org/family-calendar.org"
                            "~/org/us-market-holidays.org")))
  (defun my/org-gcal-setup ()
    (interactive)
    (let* ((authinfo (car (auth-source-search :host "org-gcal")))
           (client (plist-get authinfo :client))
           (secret (auth-source-pick-first-password :host "org-gcal"))
           (calendar (plist-get authinfo :calendar))
           (family-calendar (plist-get authinfo :family-calendar)))
      (setq org-gcal-client-id client)
      (when org-gcal-client-id
        (setq org-gcal-client-secret secret)
        (setq org-gcal-fetch-file-alist
              `((,calendar . "~/org/gcal.org")
                (,family-calendar . "~/org/family-calendar.org")
                ("monex.co.jp_hkslb9v1kj95se5r8ag2mms4k8@group.calendar.google.com" . "~/org/us-market-holidays.org")))
        (org-gcal-reload-client-id-secret))))

  (defun my/org-gcal-fetch ()
    "Import calendar events to Org files from Google Calendar."
    (interactive)
    (unless (getenv "NO_ORG_GCAL_FETCH")
      (my/org-gcal-setup)
      (when org-gcal-client-id
        (org-gcal-fetch))))

  (defvar my/org-gcal-fetch-timer (run-with-idle-timer 3600 nil #'my/org-gcal-fetch)))
#+end_src

** org-super-agenda

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after org-agenda
  :config
  ;; Faces
  (custom-set-faces
   '(org-super-agenda-header ((t :foreground "#cc8888" :box (:line-width 1 :color "#000000")) :weight bold)))

  (org-super-agenda-mode))
#+end_src

** calfw

Want monthly view.

#+begin_src emacs-lisp
(use-package calfw
  :straight ( :type git
              :host github
              :repos "kiwanami/emacs-calfw"
              :files (:defaults "*.el"))
  :custom
  (cfw:render-line-breaker 'cfw:render-line-breaker-none)
  :config

  (custom-set-faces
   '(cfw:face-title ((t (:foreground "#f0dfaf" :weight bold :height 2.0 :inherit variable-pitch))))
   '(cfw:face-header ((t (:foreground "#cccccc" :background "#666666" :weight bold))))
   '(cfw:face-sunday ((t :foreground "#cc9393" :background "#662222" :weight bold)))
   '(cfw:face-saturday ((t :foreground "#8cd0d3" :background "RoyalBlue" :weight bold)))
   '(cfw:face-holiday ((t :foreground "#cccccc" :background "#662222" :weight bold)))
   '(cfw:face-grid ((t :foreground "DarkGrey")))
   '(cfw:face-default-content ((t :foreground "#bfebbf")))
   '(cfw:face-periods ((t :foreground "cyan")))
   '(cfw:face-day-title ((t :background "#333333")))
   '(cfw:face-default-day ((t :weight bold :inherit cfw:face-day-title)))
   '(cfw:face-annotation ((t :foreground "PalmGreen" :inherit cfw:face-day-title)))
   '(cfw:face-disable ((t :foreground "DarkGray" :inherit cfw:face-day-title)))
   '(cfw:face-today-title ((t :foreground "white" :weight bold)))
   '(cfw:face-today ((t :background: "white" :weight bold)))
   '(cfw:face-select ((t :background "#666666")))
   '(cfw:face-toolbar ((t :foreground "Steelblue4")))
   '(cfw:face-toolbar-button-off ((t :foreground "gray" :weight bold)))
   '(cfw:face-toolbar-button-on ((t :foreground "gray" :weight bold))))

  ;; (setq cfw:fchar-junction ?╋
  ;;       cfw:fchar-vertical-line ?┃
  ;;       cfw:fchar-horizontal-line ?━
  ;;       cfw:fchar-left-junction ?┣
  ;;       cfw:fchar-right-junction ?┫
  ;;       cfw:fchar-top-junction ?┯
  ;;       cfw:fchar-top-left-corner ?┏
  ;;       cfw:fchar-top-right-corner ?┓)
  )

(use-package calfw-org
  :after (calfw org)
  :straight nil
  :bind (("C-c o C" . cfw:open-org-calendar))
  :commands (cfw:open-org-calendar)
  :init
  (setq cfw:org-overwrite-default-keybinding t)
  (setq cfw:org-face-agenda-item-foreground-color "#abb2bf"))
#+end_src

** org-pandoc-import

#+begin_src emacs-lisp
(use-package org-pandoc-import
  :after org
  :straight (:type git :host github :repo "tecosaur/org-pandoc-import"
             :files ("*.el" "filters" "preprocessors")))
#+end_src

Tiny function to convert Markdown text in region to Org.
source: http://yummymelon.com/devnull/converting-a-markdown-region-to-org-revisited.html

#+begin_src emacs-lisp
(defun my/markdown-to-org-region (start end)
    "Convert Markdown formatted text in region (START, END) to Org.

This command requires that pandoc (man page `pandoc(1)') be
installed."
    (interactive "r")
    (shell-command-on-region
     start end
     "pandoc -f markdown -t org --wrap=preserve" t t))
#+end_src

** verb

#+begin_src emacs-lisp
(use-package verb
  :after org
  :config
  (define-key org-mode-map (kbd "C-c C-r") verb-command-map)
  (org-babel-do-load-languages
   'org-babel-load-languages '((verb . t))))
#+end_src

** org-remark

#+begin_src emacs-lisp
(use-package org-remark
  :bind (;; :bind keyword also implicitly defers org-remark itself.
         ;; Keybindings before :map is set for global-map. Adjust the keybinds
         ;; as you see fit.
         ("C-c N m" . org-remark-mark)
         ("C-c N l" . org-remark-mark-line)
         :map org-remark-mode-map
         ("C-c N o" . org-remark-open)
         ("C-c N ]" . org-remark-view-next)
         ("C-c N [" . org-remark-view-prev)
         ("C-c N r" . org-remark-remove)
         ("C-c N d" . org-remark-delete))
  :hook ((after-init . org-remark-global-tracking-mode)
         (Info-mode . org-remark-info-mode)
         (eww-mode . org-remark-eww-mode))
  :config
  (org-remark-create "dark-pastel-green" '(:background "#3a6b35"))
  (org-remark-create "dark-pastel-blue" '(:background "#34547a"))
  (org-remark-create "dark-pastel-red" '(:background "#7a453a"))
  (org-remark-create "dark-pastel-purple" '(:background "#6a4b7b"))
  (org-remark-create "dark-pastel-orange" '(:background "#b56c49"))
  (org-remark-create "dark-pastel-teal" '(:background "#3b7165"))
  (org-remark-create "dark-pastel-brown" '(:background "#7b6046"))
  (org-remark-create "dark-pastel-yellow" '(:background "#a6954e")))
#+end_src

* Docker / Containers

** Docker Tramp
#+begin_src emacs-lisp
(use-package docker-tramp
  :disabled
  :after tramp
  :custom
  (docker-tramp-use-names t)
  (docker-tramp-docker-executable "podman"))
#+end_src
* EXWM

#+begin_src emacs-lisp
(use-package-if-exwm
 exwm
 :config
 (require 'exwm-config)

 ;; Allow non-floating resizing with mouse.
 (setq window-divider-default-bottom-width 2
       window-divider-default-right-width 2)
 (window-divider-mode)

 (setq exwm-workspace-number 1)

 ;; Try to isolate EXWM buffers per frame.
 (setq exwm-workspace-show-all-buffers nil)
 (setq exwm-layout-show-all-buffers nil)

 ;; Enable char-mode by default.
 (setq exwm-manage-configurations '((t char-mode t)))

 ;; Rename buffer to window title.
 (add-hook 'exwm-update-title-hook
           #'(lambda () (exwm-workspace-rename-buffer exwm-title)))
 ;; (add-hook 'exwm-update-class-hook
 ;;           #'(lambda () (exwm-workspace-rename-buffer exwm-class-name)))

 ;; Do not show mode-line for floating windows.
 (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
 (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

 ;; Make sure that modeline is updated for the active window.
 (add-hook 'exwm-workspace-switch-hook
           #'(lambda ()
               (run-with-idle-timer 0.1 nil
                                    #'my/exwm-set-input-focus)))

 (defun my/exwm-layout-toggle-fullscreen-or-single-window ()
   (interactive)
   (if (derived-mode-p 'exwm-mode)
       (call-interactively 'exwm-layout-toggle-fullscreen)
     (require 'functions)
     (my/toggle-single-window)))

 (defun my/exwm-set-input-focus ()
   "Workaround for losing input focus after switch-to-next/prev-buffer"
   (interactive)
   (when (and (eq window-system 'x)
              (not (active-minibuffer-window)))
     (let ((window (selected-window)))
       (select-window window)
       (x-focus-frame (window-frame window))
       (exwm-input--set-focus
        (exwm--buffer->id (window-buffer window))))))

 (defvar my/single-window--last-configuration nil
   "Last window configuration before calling `delete-other-windows'.")
 (defun my/toggle-single-window ()
   "Un-maximize current window.
    If multiple windows are active, save window configuration and
    delete other windows.  If only one window is active and a window
    configuration was previously save, restore that configuration."
   (interactive)
   (if (= (count-windows) 1)
       (when my/single-window--last-configuration
         (set-window-configuration my/single-window--last-configuration))
     (setq my/single-window--last-configuration (current-window-configuration))
     (delete-other-windows)))

 (defun my/switch-to-last-buffer ()
   "Switch to last open buffer in current window."
   (interactive)
   (let* ((b (other-buffer (current-buffer) 1))
          (w (get-buffer-window b)))
     (if w (select-window w)
       (progn
         (switch-to-buffer b)
         (my/exwm-set-input-focus)))))

 ;; Add a new EXWM window to the current perspective.
 (when (and (featurep 'persp-mode) persp-mode)
   (add-hook 'exwm-manage-finish-hook
             #'(lambda () (persp-add-buffer
                           (current-buffer) (get-current-persp)))))

 ;; === Key bindings working in line-mode. ===

 ;; Clear key bindings for line-mode to unmap C-c.
 (setq exwm-mode-map (make-sparse-keymap))

 ;; Make C-c a prefix key.
 (push ?\C-c exwm-input-prefix-keys)
 ;; Send C-c by typing C-c C-c.
 (define-key exwm-mode-map (kbd "C-c C-c") #'(lambda () (interactive)
                                               (exwm-input--fake-key 3)))

 ;; Send C-x (cut) by typing C-x C-x.
 (define-key exwm-mode-map (kbd "C-x C-x") #'(lambda () (interactive)
                                               (exwm-input--fake-key 24)))
 ;; Make C-z a prefix key.
 (push ?\C-z exwm-input-prefix-keys)
 ;; Send C-z (undo) by typing C-z C-z.
 (defun my/send-ctrl-z () (interactive) (exwm-input--fake-key 26))
 (define-key exwm-mode-map (kbd "C-z C-z") #'my/send-ctrl-z)
 (when (eq (lookup-key (current-global-map) (kbd "C-z")) 'suspend-frame)
   (global-set-key (kbd "C-z") #'my/send-ctrl-z))

 ;; Make C-q a quoted insert.
 (push ?\C-q exwm-input-prefix-keys)
 (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

 ;; === Key bindings working in both char-mode and line-mode. ===

 (exwm-input-set-key (kbd "s-'") #'exwm-input-toggle-keyboard)

 (exwm-input-set-key (kbd "s-h") #'windmove-left)
 (exwm-input-set-key (kbd "s-j") #'windmove-down)
 (exwm-input-set-key (kbd "s-k") #'windmove-up)
 (exwm-input-set-key (kbd "s-l") #'windmove-right)

 (exwm-input-set-key (kbd "s-`") #'my/switch-to-last-buffer)
 (exwm-input-set-key (kbd "s-<return>")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "lxterminal")))
 (exwm-input-set-key (kbd "s-b")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "google-chrome")))
 (exwm-input-set-key (kbd "s-B")
                     #'(lambda ()
                         (interactive)
                         (split-window-right)
                         (redisplay)
                         (windmove-right)
                         (start-process "" nil "google-chrome")))
 (exwm-input-set-key (kbd "s-L")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil
                                        "xscreensaver-command" "-lock")))
 (exwm-input-set-key (kbd "s-S")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil
                                        "gnome-screenshot" "-i")))
 ;; 's-r': Reset
 (exwm-input-set-key (kbd "s-r") #'exwm-reset)
 ;; 's-w': Move window to other workspace
 (exwm-input-set-key (kbd "s-w") #'exwm-workspace-move-window)
 ;; 's-<tab>': Switch to next workspace
 (defun my/exwm-cycle-workspace ()
   "Cycle workspace to the next one."
   (interactive)
   (let ((next-idx (1+ exwm-workspace-current-index)))
     (if (>= next-idx (length exwm-workspace--list))
         (setq next-idx 0))
     (exwm-workspace-switch next-idx)))
 (exwm-input-set-key (kbd "s-<tab>") #'my/exwm-cycle-workspace)

 ;; 's-N': Switch to Nth workspace
 (dotimes (i 10)
   (exwm-input-set-key (kbd (format "s-%d" i))
                       `(lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i)
                          (my/exwm-set-input-focus))))

 ;; 's-!': Launch application
 (exwm-input-set-key (kbd "s-!")
                     #'(lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

 (exwm-input-set-key (kbd "s-n") #'(lambda ()
                                     (interactive)
                                     (switch-to-next-buffer)
                                     (my/exwm-set-input-focus)))
 (exwm-input-set-key (kbd "s-p")  #'(lambda ()
                                      (interactive)
                                      (switch-to-prev-buffer)
                                      (my/exwm-set-input-focus)))
 (exwm-input-set-key (kbd "s-C") #'kill-buffer-and-window)
 (exwm-input-set-key (kbd "s-F") #'exwm-floating-toggle-floating)
 (exwm-input-set-key (kbd "s-f")
                     #'my/exwm-layout-toggle-fullscreen-or-single-window)

 (exwm-input-set-key (kbd "s-m") #'consult-buffer)

 (exwm-input-set-key (kbd "s-o") #'find-file-other-window)

 (defvar my/exwm-workspace-previous-index 0
   "The previous active workspace index.")
 (defun my/exwm-workspace--current-to-previous-index
     (frame-or-index &optional force)
   "Save the current active workspace index."
   (if (numberp frame-or-index)
       (setq my/exwm-workspace-previous-index exwm-workspace-current-index)))
 (add-hook 'exwm-init-hook
           #'(lambda ()
               (advice-add 'exwm-workspace-switch :before
                           #'my/exwm-workspace--current-to-previous-index)))
 (defun my/exwm-workspace-switch-to-previous ()
   (interactive)
   "Switch to the previous active workspace."
   (let ((index my/exwm-workspace-previous-index))
     (exwm-workspace-switch index)))

 (exwm-input-set-key (kbd "s-;") #'my/exwm-workspace-switch-to-previous)
 (exwm-input-set-key (kbd "s-N") #'(lambda () (interactive)
                                     (switch-to-buffer-other-frame
                                      (get-buffer-create "*scratch*"))))
 (exwm-input-set-key (kbd "s-s") #'my/get-vterm)
 (exwm-input-set-key (kbd "s-e") #'my/get-eshell)
 ;; Note that s-t does not work in exwm mode for some unknown reason.
 (exwm-input-set-key (kbd "s-t") #'my/get-term)

 ;; Other configurations
 (exwm-config-misc)

 ;; systemtray
 (when (member (getenv "use_exwm_systray") '("1" "yes"))
   (require 'exwm-systemtray)
   (exwm-systemtray-enable))

 ;; xrandr
 (when (getenv "CHROME_REMOTE_DESKTOP_SESSION")
   (require 'exwm-randr)
   (setq exwm-randr-workspace-output-plist '(0 "Screen"))
   (exwm-randr-enable))

 ;; Enable EXWM at the end of the initialization.
 (with-eval-after-load "emacs-init"
   (exwm-enable))

 (defun my/inactive-exwm-buffer-p (buf)
   "Return t if BUF is an inactive exwm buffer."
   (let ((window (get-buffer-window buf t)))
     (and
      (null window)
      (not (string-prefix-p " " (buffer-name buf)))
      (with-current-buffer buf
        (derived-mode-p 'exwm-mode)))))

 (defun my/get-inactive-exwm-buffers ()
   "Return a list of inactive EXWM buffers or nil if none."
   (cl-remove-if-not #'my/inactive-exwm-buffer-p
                     (buffer-list)))

 (defun my/get-inactive-exwm-buffer-names ()
   "Return a list of inactive EXWM buffers or nil if none."
   (mapcar
    #'buffer-name
    (my/get-inactive-exwm-buffers)))

 ;; Select inactive EXWM buffers with Vertico/Consult.
 (defvar my/consult-source-inactive-exwm-buffer
   `(:name "EXWM"
           :hidden t
           :narrow ?x
           :category buffer
           :face consult-buffer
           :history  buffer-name-history
           :state ,#'consult--buffer-state
           :items
           ,(lambda () (consult--buffer-query :sort 'visibility
                                              :as #'buffer-name
                                              :predicate
                                              #'my/inactive-exwm-buffer-p
                                              ))))

 (setq my/consult-exwm-buffer-source
       (list
        `(:hidden nil :narrow ?x ,@my/consult-source-inactive-exwm-buffer)))

 (defun my/consult-inactive-exwm-buffers ()
   (interactive)
   (let ((buflist (my/get-inactive-exwm-buffers)))
     (cl-case (length buflist)
       (0 (message "No inactive EXWM buffers found"))
       (1 (switch-to-buffer (car buflist))
          (my/exwm-set-input-focus))
       (t (consult-buffer my/consult-exwm-buffer-source)))))

 ;; Override s-i.
 (exwm-input-set-key (kbd "s-i") #'my/consult-inactive-exwm-buffers)
 )
#+end_src

* Device Control and Management

** PulseAudio

Disabled atm as new distro is adopting pipewire.

#+begin_src emacs-lisp
(use-package-if-exwm
 pulseaudio-control
 :requires exwm
 :config
 (push 'XF86AudioMute exwm-input-prefix-keys)
 (push 'XF86AudioLowerVolume exwm-input-prefix-keys)
 (push 'XF86AudioRaiseVolume exwm-input-prefix-keys)

 (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>") #'pulseaudio-control-increase-volume)
 (exwm-input-set-key (kbd "<XF86AudioLowerVolume>") #'pulseaudio-control-decrease-volume)
 (exwm-input-set-key (kbd "<XF86AudioMute>") #'pulseaudio-control-toggle-current-sink-mute)
 )
#+end_src

** Brightness

#+begin_src emacs-lisp
(when-use-exwm
 (push 'XF86MonBrightnessDown exwm-input-prefix-keys)
 (push 'XF86MonBrightnessUp exwm-input-prefix-keys)

 (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "light" "-U" "10")))

 (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "light" "-A" "10")))
 )
#+end_src

* LLM

** Common Settings

Macros to retrive API keys for LLM servce providers.

#+begin_src emacs-lisp
(defvar my/llm-provider-alist
  '((gemini :auth-source "gemini-api-key" :envvar "GEMINI_API_KEY")
    (openrouter :auth-source "openrouter-api-key" :envvar "OPENROUTER_API_KEY")
    (anthropic :auth-source "api.anthropic.com" :envvar "ANTHROPIC_API_KEY")
    (deepseek :auth-source "deepseek-api-key" :envvar "DEEPSEEK_API_KEY")
    (xai :auth-source "xai-api-key" :envvar "XAI_API_KEY")
    (groq :auth-source "groq-api-key" :envvar "GROQ_API_KEY")
    (cohere :auth-source "cohere-api-key" :envvar "COHERE_API_KEY")
    (sambanova :auth-source "sambanova-api-key")
    (huggingface :auth-source "huggingface-api-key")
    (deepl :auth-source "deepl-api-key")))

;; Generate my/get-<provider>-api-key function
(dolist (conf my/llm-provider-alist)
  (let ((name (car conf))
        (host (plist-get (cdr conf) :auth-source)))
    (fset (intern (format "my/get-%s-api-key" name))
          `(lambda ()
            (auth-source-pick-first-password :host ,host)))))

(defun my/llm-get-api-key (provider)
  "Get the API KEY for a specified provider."
  (let* ((conf (alist-get provider my/llm-provider-alist))
         (host (plist-get conf :auth-source)))
    (auth-source-pick-first-password :host host)))

(defun my/llm-set-api-key (provider)
  "Set the environment variable with the API key for each specified provider.
   PROVIDER can be a symbol or a list of symbols.
   'ALL represents all registered providers."
  (interactive (list (intern (completing-read "Provider: "
                                              (mapcar 'car my/llm-provider-alist)))))
  (let ((provider-list (if (eq provider 'ALL) nil
                         (if (listp provider) provider (list provider)))))
    (dolist (p my/llm-provider-alist)
      (let ((name (car p))
            (envvar (plist-get (cdr p) :envvar)))
        (when (or (null provider-list)
                  (member name provider-list))
          (if envvar
              (setenv envvar (my/llm-get-api-key name))
            (message "my/llm-set-api-key: could not get :envvar for %s" name)))))))
#+end_src

** Ellama - Emacs client for ollama

#+begin_src emacs-lisp
(use-package ellama
  :bind (("C-x m" . ellama-chat)
         :map my/ai-map
         ("e" . my/ellama-transient-menu))
  :bind-keymap
  ("C-c L" . ellama-command-map)
  :custom
  (llm-warn-on-nonfree nil)
  (ellama-fill-paragraphs nil)
  (ellama-long-lines-length 1024)
  :config
  (transient-define-prefix my/ellama-transient-menu ()
    "Transient menu for Ellama."
    [["Ask"
      ("c" "Chat" ellama-chat)
      ("r" "Ask about region/buffer" ellama-ask-about)
      ("d" "Add definition" ellama-define-word)]
     ["Text"
      ("s" "Summarize" ellama-summarize)
      ("t" "Translate" ellama-translate)
      ("w" "Improve wording" ellama-improve-wording)
      ("g" "Improve grammar" ellama-improve-grammar)]
     ["Misc"
      ("m" "Change model" ellama-provider-select)
      ("x" "Context" ellama-transient-context-menu)
      ("S" "Session" ellama-transient-session-menu)]
     ["Quit" ("q" "Quit" transient-quit-one)]])

  ;; (defhydra my/hydra-ellama (:hint nil)
  ;;   "
  ;; Ask:      _c_: chat _r_: ask with region _d_: definition
  ;; Text:     _s_: summarize  _t_: translate _w_: improve wording _g_: improve grammar
  ;; Other:    _m_: change model _x_: context menu _S_: session "
  ;;   ("c" ellama-chat)
  ;;   ("d" ellama-define-word)
  ;;   ("g" ellama-improve-grammar)
  ;;   ("m" ellama-provider-select)
  ;;   ("r" ellama-ask-about)
  ;;   ("s" ellama-summarize)
  ;;   ("S" ellama-transient-session-menu)
  ;;   ("t" ellama-translate)
  ;;   ("w" ellama-improve-wording)
  ;;   ("x" ellama-transient-context-menu)
  ;;   ("q" nil))

  ;; setup key bindings
  (setopt ellama-keymap-prefix "C-c L")
  ;; language you want ellama to translate to
  (setopt ellama-language "Japanese")
  ;; could be llm-openai for example
  ;; (require 'llm-ollama)
  (require 'llm-openai)

  ;; custom macro for local OpenAI compatible server
  (defmacro my/make-llm-local-server (&rest args)
    `(make-llm-openai-compatible
      :url "http://localhost:8000/v1/"
      :embedding-model "nomic-embed-text"
      ,@args))

  (defmacro my/make-llm-groq (&rest args)
    `(make-llm-openai-compatible
      :url "https://api.groq.com/openai/v1/"
      :key (my/get-groq-api-key)
      ,@args))

  (defmacro my/make-llm-sambanova (&rest args)
    `(make-llm-openai-compatible
      :url "https://api.sambanova.ai/v1/"
      :key (my/get-sambanova-api-key)
      ,@args))

  (defmacro my/make-llm-cohere (&rest args)
    `(make-llm-openai-compatible
      :url "http://localhost:6600/v1/"
      :key (my/get-cohere-api-key)
      ,@args))

  (defmacro my/make-llm-huggingface (&rest args)
    `(make-llm-openai-compatible
      :url "https://api-inference.huggingface.co/v1/"
      :key (my/get-huggingface-api-key)
      ,@args))

  (require 'llm-gemini)
  (defmacro my/make-llm-gemini (&rest args)
    `(make-llm-gemini
      :key (my/get-gemini-api-key)
      ,@args))

  ;; (setopt ellama-provider
  ;;         (my/make-llm-local-server
  ;;          :chat-model "deepseek-coder-v2:latest"))

  (setopt ellama-provider (my/make-llm-gemini
                           :chat-model "gemini-2.5-flash-lite"))
  ;; Predefined llm providers for interactive switching.
  ;; You shouldn't add ollama providers here - it can be selected interactively
  ;; without it. It is just example.
  (setopt ellama-providers
          '(("gemini-2.0-flash" . (my/make-llm-gemini
                                   :chat-model "gemini-2.0-flash"))
            ("gemini-2.5-flash-image-preview" . (my/make-llm-gemini
                                           :chat-model "gemini-2.5-flash-image-preview"))
            ("gemini-2.5-flash-lite" . (my/make-llm-gemini
                                                :chat-model "gemini-2.5-flash-lite"))
            ("gemini-2.5-flash" . (my/make-llm-gemini
                                           :chat-model "gemini-2.5-flash"))
            ("gemini-2.5-pro" . (my/make-llm-gemini
                                         :chat-model "gemini-2.5-pro"))
            ("groq-llama-3.3-versatile" . (my/make-llm-groq
                                           :chat-model "llama-3.3-70b-versatile"))
            ("groq-gpt-oss-120b" . (my/make-llm-groq
                                    :chat-model "openai/gpt-oss-120b"))
            ("groq-kimi-k2" . (my/make-llm-groq
                                    :chat-model "moonshotai/kimi-k2-instruct-0905"))
            ("sambanova-qwen3" . (my/make-llm-sambanova
                                      :chat-model "Qwen3-32B"))
            ("sambanova-gpt-oss-120b" . (my/make-llm-sambanova
                                     :chat-model "gpt-oss-120b"))))

  ;; Change AI's nickname as per the selected model.
  (defun my/ellama-update-assistant-nick ()
    (setq ellama-assistant-nick
          (format-message
           "AI (%s)"
           (capitalize (cl-struct-slot-value (type-of ellama-provider)
                                             'chat-model ellama-provider)))))

  (advice-add #'ellama-provider-select :after #'my/ellama-update-assistant-nick)
  (my/ellama-update-assistant-nick)

  ;; Disabled ellama-naming-provider and ellama-translation-provider to take
  ;; into account the situation where no local LLM server is running on the
  ;; host.

  ;; ;; Naming new sessions with llm
  ;; (setopt ellama-naming-provider
  ;;         (my/make-llm-local-server
  ;;          :chat-model "elyza"
  ;;          :default-chat-non-standard-params '(("stop" . ("\n")))))
  ;; (setopt ellama-naming-scheme 'ellama-generate-name-by-llm)
  ;; ;; Translation llm provider
  ;; (setopt ellama-translation-provider (my/make-llm-local-server
  ;;                                      :chat-model "ezo-common"))
  )
#+end_src

** gptel

#+begin_src emacs-lisp
(use-package gptel
  :bind ( :map my/ai-map
          ("g" . my/gptel-new)
          ("G" . gptel-send)
          :map gptel-mode-map
          ("C-c i h" . my/gptel-insert-new-chat)
          ("C-c i p" . my/gptel-insert-prompt-prefix))
  :commands (gptel gptel-send gptel-menu my/gptel-new)
  :hook (gptel-mode . (lambda () (goggles-mode -1)))
  :init
  ;; Change default system prompt.
  (defvar my/gptel-system-prompt-file "~/.gptel-system-prompt")
  (defun my/gptel-system-prompt ()
    "Return system prompt."
    (if (file-exists-p my/gptel-system-prompt-file)
        (my/get-file-contents my/gptel-system-prompt-file)
      "You are a helpful assistant. Always respond in Japanese."))

  (setq gptel-directives
        `((default . ,(my/gptel-system-prompt))))

  :custom
  (gptel-default-mode #'org-mode)
  (gptel-use-tools t)
  (gptel-temperature 0.7)
  :config

  ;; Enable branching to limit context (requires >= Org 9.7).
  (when (fboundp 'org-element-lineage-map)
    (setq-default gptel-org-branching-context t)
    (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "- @me :: ")
    (setf (alist-get 'org-mode gptel-response-prefix-alist) "- @ai :: "))

  (defvar my/gptel-save-directory "~/org/gptel")
  (unless (file-directory-p my/gptel-save-directory)
    (mkdir my/gptel-save-directory t))

  (defun my/gptel-insert-new-chat-heading ()
    "Insert new chat heading."
    (interactive)
    (org-insert-heading-respect-content)
    (insert (format-time-string "[%Y-%m-%d %H:%M] New Chat\n")))

  (defun my/gptel-insert-prompt-prefix ()
    "Insert prompt prefix."
    (interactive)
    (insert (concat "\n" (gptel-prompt-prefix-string))))

  (defun my/gptel-insert-new-chat ()
    "Insert new chat heading and prompt prefix."
    (interactive)
    (my/gptel-insert-new-chat-heading)
    (my/gptel-insert-prompt-prefix))

  (defun my/gptel-new (&optional arg)
    "Create a new buffer backed by a file and start gptel there.."
    (interactive "P")
    (let ((buf (find-file-noselect
                (if arg
                    (let ((default-directory (file-name-as-directory
                                              my/gptel-save-directory)))
                      (car (find-file-read-args "Select file: " t)))
                  (file-name-concat
                   my/gptel-save-directory
                   (format-time-string "gptel-%Y%m%d.org"))) t)))
      (pop-to-buffer buf)
      (local-set-key (kbd "S-<return>") #'gptel-send)
      (org-mode)
      (gptel-mode)
      ;; (face-remap-set-base 'org-level-1 :height 1.0)
      ;; (face-remap-set-base 'org-level-2 :height 1.0)
      ;; (face-remap-set-base 'org-level-3 :height 1.0)
      ;; (face-remap-set-base 'org-level-4 :height 1.0)
      ;; (face-remap-set-base 'org-level-5 :height 1.0)
      (goto-char (point-max))
      (when gptel-org-branching-context
        (my/gptel-insert-new-chat-heading))
      (my/gptel-insert-prompt-prefix)
      (not-modified)))

  (add-hook 'gptel-post-stream-hook 'gptel-auto-scroll)
  (add-hook 'gptel-post-response-functions 'gptel-end-of-response)

  ;;
  ;; Define backends.
  ;;

  (gptel-make-gemini "Gemini"
    :key #'my/get-gemini-api-key
    :models '(gemini-2.0-flash
              gemini-2.5-flash-image-preview
              gemini-2.5-pro
              gemini-2.5-flash-lite
              gemini-2.5-flash)
    :stream t)

  (gptel-make-openai "Groq"
    :host "api.groq.com"
    :endpoint "/openai/v1/chat/completions"
    :stream t
    :key #'my/get-groq-api-key
    :models '(
              llama-3.3-70b-versatile
              openai/gpt-oss-120b
              moonshotai/kimi-k2-instruct-0905))

  (gptel-make-ollama "Ollama"
    :host "localhost:11434"
    :stream t
    :models '(qwen2.5-coder:latest
              deepseek-coder-v2:latest
              ezo-common-gemma2:9b
              mistral-nemo-instruct:latest
              llama3.1:latest))

  (gptel-make-openai "SambaNova"
    :host "api.sambanova.ai"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-sambanova-api-key
    :models '(Qwen3-32B
              gpt-oss-120b))

  (gptel-make-openai "Cohere"
    :host "localhost:6600"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-cohere-api-key
    :models '(command-r-plus
              command-r-plus-08-2024))

  ;; (gptel-make-openai "HuggingFace"
  ;;   :host "api-inference.huggingface.co"
  ;;   :endpoint "/v1/chat/completions"
  ;;   :stream t
  ;;   :key #'my/get-huggingface-api-key
  ;;   :models '(Qwen/Qwen2.5-Coder-32B-Instruct
  ;;             Qwen/Qwen2.5-72B-Instruct
  ;;             Qwen/QwQ-32B
  ;;             black-forest-labs/FLUX.1-dev))

  (gptel-make-anthropic "Anthropic"
    :stream t
    :key #'my/get-anthropic-api-key
    :models '(claude-3-7-sonnet-latest
              claude-sonnet-4-0
              claude-opus-4-1
              claude-sonnet-4-5))

  (gptel-make-openai "DeepSeek"
    :host "api.deepseek.com"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-deepseek-api-key
    :models '(deepseek-chat
              deepseek-reasoner))

  (gptel-make-openai "OpenRouter"
    :host "openrouter.ai"
    :endpoint "/api/v1/chat/completions"
    :stream t
    :key #'my/get-openrouter-api-key
    :models '(openai/gpt-5-nano
              openai/gpt-5-mini
              openai/gpt-5
              openai/gpt-5-chat
              openai/gpt-5-codex
              openai/gpt-5-codex
              openai/gpt-oss-20b:free
              z-ai/glm-4.5-air:free
              tngtech/deepseek-r1t2-chimera:free
              meituan/longcat-flash-chat:free
              moonshotai/kimi-k2:free
              qwen/qwen3-coder:free))

  (defun my/gptel-get-backend (key)
    (alist-get key gptel--known-backends nil nil 'string=))

  ;; Set default backend.
  (setq gptel-backend (my/gptel-get-backend "Gemini"))
  (setq gptel-model 'gemini-2.5-flash-lite)

  ;;
  ;; Tools - mostly copied from https://github.com/karthink/gptel/issues/514
  ;;

  (gptel-make-tool
   :function (lambda (city state country)
               (let ((url (format "https://api.openweathermap.org/geo/1.0/direct?q=%s,%s,%s&limit=1&appid=%s"
                                  (if city city "")
                                  (if state state "")
                                  (if country country "")
                                  (auth-source-pick-first-password :host "weather-api-key"))))
                 (message "get_coordinates: city=%s state=%s country=%s" city state country)
                 (with-current-buffer (url-retrieve-synchronously url)
                   (let ((data
                          (save-excursion
                            (goto-char (point-min))
                            (forward-paragraph)
                            (forward-char)
                            (delete-region (point-min) (point))
                            (buffer-string))))
                     (run-at-time 0 nil #'kill-buffer (current-buffer))
                     (json-parse-string data)))))
   :name "get_coordinates"
   :description "Retrieve geographical coordinates (latitude and longitude) for a given location in JSON format."
   :args (list '(:name "city"
                       :type "string"
                       :description "The name of the city for the location.")
               '(:name "state"
                       :type "string"
                       :description
                       "The name of the state for the location. Optional."
                       :optional t)
               '(:name "country"
                       :type "string"
                       :description "The name of the country for the location."))
   :category "web")

  (gptel-make-tool
   :function (lambda (lat lon units lang)
               (let ((url (format "https://api.openweathermap.org/data/2.5/forecast?lat=%s&lon=%s%s%s&mode=json&appid=%s"
                                  lat lon
                                  (if (member units '("metric" "imperial")) (format "&units=%s" units) "")
                                  (if (= (length lang) 2) (format "&lang=%s" lang) "")
                                  (auth-source-pick-first-password :host "weather-api-key"))))
                 (message "get_weather_forecast: lat=%s lon=%s units=%s lang=%s" lat lon units lang)
                 (with-current-buffer (url-retrieve-synchronously url)
                   (let ((data
                          (save-excursion
                            (goto-char (point-min))
                            (forward-paragraph)
                            (forward-char)
                            (delete-region (point-min) (point))
                            (buffer-string))))
                     (run-at-time 0 nil #'kill-buffer (current-buffer))
                     (json-parse-string data)))))
   :name "get_weather_forecast"
   :description "Get 5-day, 3-hour step weather forecast for a given location in JSON format. Timestamps in the response are in UTC."
   :args (list '(:name "lat"
                       :type "string"
                       :description "The latitude of the location.")
               '(:name "lon"
                       :type "string"
                       :description "The longitude of the location.")
               '(:name "units"
                       :type "string"
                       :enum ("metric" "imperial")
                       :description
                       "Units of measurement, either 'metric' or 'imperial'. Use imperial for temperature in Fahrenheit. Use metric for temperature in Celsius"
                       :optional t)
               '(:name "lang"
                       :type "string"
                       :description
                       "2-character language code. e.g. 'en' for English, 'ja' for Japanese"
                       :optional t))
   :category "web")

  (gptel-make-tool
   :function (lambda (url)
               (message "get_url_content: %s" url)
               (with-current-buffer (url-retrieve-synchronously url)
                 (goto-char (point-min)) (forward-paragraph)
                 (let ((dom (libxml-parse-html-region (point) (point-max))))
                   (run-at-time 0 nil #'kill-buffer (current-buffer))
                   (with-temp-buffer
                     (shr-insert-document dom)
                     (buffer-substring-no-properties (point-min) (point-max))))))
   :name "get_url_content"
   :description "Fetch the content from a URL."
   :args (list '(:name "url"
                       :type "string"
                       :description "The URL from which to retrieve the content."))
   :category "web")

  (gptel-make-tool
   :function (lambda (buffer text)
               (with-current-buffer (get-buffer-create buffer)
                 (save-excursion
                   (goto-char (point-max))
                   (insert text)))
               (format "Appended text to buffer %s" buffer))
   :name "append_to_buffer"
   :description "Append text to the an Emacs buffer.  If the buffer does not exist, it will be created."
   :args (list '(:name "buffer"
                       :type "string"
                       :description "The name of the buffer to append text to.")
               '(:name "text"
                       :type "string"
                       :description "The text to append to the buffer."))
   :category "emacs")

  ;; Message buffer logging tool
  (gptel-make-tool
   :function (lambda (text)
               (message "%s" text)
               (format "Message sent: %s" text))
   :name "echo_message"
   :description "Send a message to the *Messages* buffer"
   :args (list '(:name "text"
                       :type "string"
                       :description "The text to send to the messages buffer"))
   :category "emacs")

  ;; buffer retrieval tool
  (gptel-make-tool
   :function (lambda (buffer)
               (unless (buffer-live-p (get-buffer buffer))
                 (error "Error: buffer %s is not live." buffer))
               (with-current-buffer  buffer
                 (buffer-substring-no-properties (point-min) (point-max))))
   :name "read_buffer"
   :description "Return the contents of an Emacs buffer"
   :args (list '(:name "buffer"
                       :type "string"
                       :description "The name of the buffer whose contents are to be retrieved"))
   :category "emacs")


  (gptel-make-tool
   :function (lambda (directory)
               (mapconcat #'identity
                          (directory-files directory)
                          "\n"))
   :name "list_directory"
   :description "List the contents of a given directory"
   :args (list '(:name "directory"
                       :type "string"
                       :description "The path to the directory to list"))
   :category "filesystem")

  (gptel-make-tool
   :function (lambda (parent name)
               (condition-case nil
                   (progn
                     (make-directory (expand-file-name name parent) t)
                     (format "Directory %s created/verified in %s" name parent))
                 (error (format "Error creating directory %s in %s" name parent))))
   :name "make_directory"
   :description "Create a new directory with a given name in a specified parent directory"
   :args (list '(:name "parent"
                       :type "string"
                       :description "The parent directory where the new directory should be created, e.g. /tmp")
               '(:name "name"
                       :type "string"
                       :description "The name of the new directory to create, e.g. testdir"))
   :category "filesystem")

  (gptel-make-tool
   :function (lambda (path filename content)
               (let ((full-path (expand-file-name filename path)))
                 (with-temp-buffer
                   (insert content)
                   (write-file full-path))
                 (format "Created file %s in %s" filename path)))
   :name "create_file"
   :description "Create a new file with a specified content"
   :args (list '(:name "path"
                       :type "string"
                       :description "The directory where to create the file")
               '(:name "filename"
                       :type "string"
                       :description "The name of the file to create")
               '(:name "content"
                       :type "string"
                       :description "The content to write to the file"))
   :category "filesystem")

  (gptel-make-tool
   :function (lambda (filepath)
               (with-temp-buffer
                 (insert-file-contents (expand-file-name filepath))
                 (buffer-string)))
   :name "read_file"
   :description "Read and display the contents of a file"
   :args (list '(:name "filepath"
                       :type "string"
                       :description "Path to the file to read.  Supports relative paths and ~."))
   :category "filesystem")

  ;;
  ;; Local Tools
  ;;
  (defun my/gptel-tool-web-search (callback keyword)
    "Launch web search process and return results in JSON format."
    (message "calling web_search with keyword %s" keyword)
    (let* ((outbuf (get-buffer-create (concat (make-temp-name " *gptel-tool-web-search-") "*")))
           (process
            (make-process :name "curl"
                          :command `("curl" "-X" "GET" "-L" "--no-progress-meter"
                                     "http://localhost:8081"
                                     "--data-urlencode" ,(concat "q=" keyword)
                                     "--data" "format=json")
                          :buffer outbuf
                          :sentinel `(lambda (proc status)
                                       (funcall ,callback
                                                (with-current-buffer ,outbuf
                                                  (buffer-string)))
                                       (run-at-time 0 nil #'kill-buffer ,outbuf)))))
      (message "web_search process created with buffer %s for keyword '%s'" outbuf keyword)))

  (gptel-make-tool
   :function #'my/gptel-tool-web-search
   :name "web_search"
   :description "Search the Web for a given keyword and return results in JSON format"
   :args (list '(:name "keyword"
                       :type "string"
                       :description "The search keyword"))
   :category "web"
   :async t)

  ;;
  ;; Tweak request data
  ;;
  (defun my/gptel-addtional-system-message ()
    (concat
     "\nThe following is supplementary information.\n"
     (format-time-string  "The current time in %Z is %r on %B %d, %Y." nil t)
     ))

  (defun my/gptel-tweak-request-data-advice (orig-fn &rest args)
    "Advice to tweak request data before sending it."
    (let* ((plist (apply orig-fn args))
           (genconfig (plist-get plist :generationConfig))
           (sysmsg-place (map-nested-elt plist '(:system_instruction :parts)))
           (sysmsg (plist-get sysmsg-place :text)))
      ;; Set temperature since the original function enforces a minimum temperature of 1.0 for some reason...
      (plist-put genconfig :temperature gptel-temperature)
      ;; Inject additional information to system prompt message.
      (plist-put sysmsg-place :text (concat sysmsg (my/gptel-addtional-system-message)))
      plist))

  (advice-add #'gptel--request-data :around #'my/gptel-tweak-request-data-advice)

  ;;
  ;; Hooks to enable Google Search with Gemini
  ;;

  (defcustom my/gptel-gemini-use-google-search t
    "Whether Google Search should be enabled with Gemini.")

  (defun my/gptel-gemini-use-google-search-advice (orig-fn &rest args)
    "Advice to add Google Search tool to request data."
    (let* ((plist (apply orig-fn args))
           (tools (plist-get plist :tools)))
      (if (and my/gptel-gemini-use-google-search
               (string-match-p "gemini.*" (symbol-name gptel-model))
               (not (cl-some (lambda (pl) (plist-member pl :function_declarations)) tools)))
          (progn
            (unless (cl-some (lambda (pl) (plist-member pl :google_search)) tools)
              (plist-put plist :tools
                         (if tools (vconcat '[(:google_search ())] tools)
                           '[(:google_search ())])))
            plist)
        (setq tools (seq-remove (lambda (pl) (equal pl '(:google_search nil))) tools))
        (if tools
            (plist-put plist :tools (vconcat tools))
          (map-delete plist :tools)))))

  (advice-add #'gptel--request-data :around #'my/gptel-gemini-use-google-search-advice)

  (defvar my/gptel-gemini-grounding-web-force-mode nil)
  (defun my/gptel-gemini-format-grounding-web (web)
    "Return a formatted link suitable for gptel-default-mode."
    (let ((uri (plist-get web :uri))
          (title (plist-get web :title)))
      (pcase (or my/gptel-gemini-grounding-web-force-mode gptel-default-mode)
        ('org-mode (format "[[%s][%s]]" uri title))
        ('markdown-mode (format "[%s](%s)" uri title))
        (_ title))))

  (defun my/gptel-gemini-add-grounding-info-advice (orig-fn backend response info &optional include-text)
    "Advice to attach grounding information."
    (let* ((text (funcall orig-fn backend response info include-text))
           (cand0 (map-nested-elt response '(:candidates 0)))
           (chunks (map-nested-elt cand0 '(:groundingMetadata :groundingChunks)))
           (queries (map-nested-elt cand0 '(:groundingMetadata :webSearchQueries)))
           (src-info
            (cl-loop
             for chunk across chunks
             when (plist-get chunk :web) collect it into webs
             finally return webs))
           ;; HACK to forcibly format source links in text mode for requests from gptel-quick.
           (my/gptel-gemini-grounding-web-force-mode
            (eq (plist-get info :callback) #'gptel-quick--callback-posframe))
           )
      (concat text
              (when src-info
                (format "\n\nGrounding Sources:\n%s"
                        (apply #'concat
                               (mapcar (lambda (src)
                                         (format "- %s\n" (my/gptel-gemini-format-grounding-web src)))
                                       src-info))))
              (when queries
                (format "\nSearch Queries:\n%s"
                        (apply #'concat
                               (mapcar (lambda (kw) (format "- %s\n" kw)) queries)))))))

  (advice-add #'gptel--parse-response :around #'my/gptel-gemini-add-grounding-info-advice)

  ;; (setq gptel-log-level 3)
  ;; (setq test-response '(:candidates [(:groundingMetadata (:groundingChunks [(:web (:uri "url1" :title "title1")) (:web (:uri "url2" :title "title2"))] :searchQueries ["query1" "query2"]))]))
  ) ;; use-package gptel
#+end_src

** gptel-quick

#+begin_src emacs-lisp
(use-package gptel-quick
  :straight (:type git :host github :repo "karthink/gptel-quick")
  :bind-keymap ("C-c q" . my/gptel-quick-map)
  :bind ( :map my/gptel-quick-map
          ("e" . my/gptel-quick-explain)
          ("t" . my/gptel-quick-translate)
          ("s" . my/gptel-quick-summarize))
  :init
  (define-prefix-command 'my/gptel-quick-map)
  :custom-face
  (vertical-border ((t :foreground "gray")))
  :config
  ;; Setting these here as somehow :custom does not work...
  (setq gptel-quick-word-count 150)
  (setq gptel-quick-timeout 180)

  (defun my/make-gptel-quick (action &optional system-message count google-search use-tools)
    "Create a gptel-quick wrapper with given system message."
    (fset (intern (format "my/gptel-quick-%s" action))
          `(lambda () (interactive)
             (let ((my/gptel-gemini-use-google-search ,google-search)
                   (gptel-use-tools ,use-tools)
                   (gptel-quick-word-count ,(or count gptel-quick-word-count))
                   (gptel-quick-system-message
                    (lambda (count)
                      (format ,(or system-message
                                   (concat (capitalize action) " in %d words or fewer. Provide only the answer without any greetings.")) count))))
               (call-interactively #'gptel-quick)))))

  (my/make-gptel-quick "explain" "日本語で%d文字以内で説明して。回答のみで挨拶等省略すること。" nil t)
  (my/make-gptel-quick "translate" "%d文字以内で日本語に訳して。回答のみで挨拶等省略すること。")
  (my/make-gptel-quick "summarize" "日本語で%d文字以内に要約して。回答のみで挨拶等省略すること。" 800)

  (defun my/gptel-request-advice (orig-fn &rest args)
    "Quick patch gptel-request to forcibly enable curl disabled in
gptel-quick. Apparently responses become empty if gptel-use-curl is nil
and stream is t."
    (let ((gptel-use-curl t))
      (apply orig-fn args)))
  (advice-add #'gptel-request :around #'my/gptel-request-advice))
#+end_src

#+RESULTS:
: my/gptel-quick-summarize

** mcp

#+begin_src emacs-lisp
(use-package mcp-hub
  :straight (:type git :host github :repo "lizqwerscott/mcp.el")
  ;; :hook (gptel-mode . my/gptel-enable-mcp-tools)
  :custom
  (mcp-hub-servers
   `(("filesystem" . (:command "npx" :args ("-y" "@modelcontextprotocol/server-filesystem" ,(file-name-concat (getenv "HOME") "prj"))))
     ("playwright" . (:command "npx" :args ("-y" "@playwright/mcp@latest")))
     ;; ("firecrawl" . (:command "npx" :args ("-y" "firecrawl-mcp")
     ;;                       :env (:FIRECRAWL_API_KEY ,(auth-source-pick-first-password :host "firecrawl-api-key"))))
     ("tavily" . (:command "npx" :args ("-y" "tavily-mcp@0.1.4")
                           :env (:TAVILY_API_KEY ,(auth-source-pick-first-password :host "tavily-api-key"))))))
  :config

  (defun gptel-mcp-register-tool ()
    "A function for registering all MCP tools."
    (interactive)
    (let ((tools (mcp-hub-get-all-tool :asyncp t :categoryp t)))
      (mapcar #'(lambda (tool)
                  (apply #'gptel-make-tool
                         tool))
              tools)))

  (defun gptel-mcp-use-tool ()
    "Activate all MCP tools using gptel."
    (interactive)
    (let ((tools (mcp-hub-get-all-tool :asyncp t :categoryp t)))
      (mapcar #'(lambda (tool)
                  (let ((path (list (plist-get tool :category)
                                    (plist-get tool :name))))
                    (push (gptel-get-tool path)
                          gptel-tools)))
              tools)))
  (defun my/gptel-enable-mcp-tools ()
    "Setup MCP servers as tools for gptel."
    (interactive)
    (mcp-hub-start-all-server)
    (run-with-timer 5 nil #'gptel-mcp-register-tool)
    ))
#+end_src

* Internet Information and Media Tools

** elfeed

#+begin_src emacs-lisp
(use-package elfeed
  :bind (("C-c F" . elfeed)
         ("<f12>" . elfeed)
         :map elfeed-search-mode-map
         ("<mouse-1>" . elfeed-search-show-entry)
         ("S" . my/elfeed-search-toggle-sort)
         ("b" . my/elfeed-search-browse-url-with-eww)
         ("B" . elfeed-search-browse-url)
         ("m" . elfeed-search-untag-all-unread)
         ("SPC" . elfeed-search-show-entry)
         :map elfeed-show-mode-map
         (";" . elfeed-kill-buffer)
         ("j" . scroll-up-command)
         ("k" . scroll-down-command)
         ("v" . my/elfeed-show-visit-with-eaf)
         ("." . browse-url-at-point)
         ("b" . my/elfeed-show-visit-with-eww)
         ("B" . elfeed-show-visit)
         ("c" . my/elfeed-org-roam-capture)
         ("SPC" . my/elfeed-show-scroll-up-then-quit)
         ("RET" . my/elfeed-show-visit-with-eww))
  ;; :custom
  ;; (elfeed-search-remain-on-entry t)  ;; for navigation from split entry pane.
  :config
  ;; Faces
  (custom-set-faces
   '(elfeed-search-title-face ((t :foreground "#aaaaaa")))
   '(elfeed-search-unread-title-face ((t :foreground "#eeeeee"))))

  ;; Set external program to retrieve a URL.
  (setq my/eww-retrieve-command '("curl-gnews" "--http2" "-LSs" "--compressed" "--user-agent" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"))
  ;; (setq my/eww-retrieve-command
  ;;       '("google-chrome" "--headless" "--dump-dom" "--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"))

  ;; Show an feed entry in a split pane using display-buffer-alist.
  (setq elfeed-show-entry-switch #'pop-to-buffer)
  (add-to-list 'display-buffer-alist
               '("\\`\\*elfeed-entry\\*"
                 (display-buffer-reuse-mode-window display-buffer-in-direction)
                 (direction . right)
                 (window-width . 0.5)))

  ;; Close the window when q is pressed in the elfeed-entry buffer.
  (advice-add #'elfeed-kill-buffer :after
              (lambda () (delete-window)))
  ;; Close the other windows when elfeed-entry buffer is opened.
  (advice-add #'elfeed-search-show-entry :before
              (lambda (entry) (delete-other-windows)))

  (defun my/elfeed-eww-scroll-up-then-quit (&optional arg)
    "Scroll up then kill eww buffer and window if at the bottom."
    (interactive "^P")
    (let ((old-point (point))
          (scroll-error-top-bottom t))
      (scroll-up-command arg)
      (when (eobp)
        (kill-buffer-and-window))))

  (defun my/elfeed-eww-browse-url (url &optional new-window)
    "My elfeed specific eww-browse-url."
    (eww-browse-url url new-window)
    (local-set-key (kbd "SPC") #'my/elfeed-eww-scroll-up-then-quit)
    (local-set-key (kbd "q") #'kill-buffer-and-window)
    (local-set-key (kbd ";") #'kill-buffer-and-window))

  (defun my/elfeed-search-browse-url-with-eww (entry)
    (interactive (list (elfeed-search-selected :ignore-region)))
    (let ((browse-url-browser-function #'my/elfeed-eww-browse-url)
          (eww-retrieve-command my/eww-retrieve-command))
      (elfeed-search-show-entry entry)
      (elfeed-show-visit)))

  (defun my/elfeed-show-scroll-up-then-quit (&optional arg)
    "Scroll up and kill the buffer if the position is at the bottom."
    (interactive "^P")
    (let ((old-point (point))
          (scroll-error-top-bottom t))
      (scroll-up-command arg)
      (when (eobp)
        (elfeed-kill-buffer))))

  (defun my/elfeed-show-visit-with-eaf (&optional use-generic-p)
    (interactive "P")
    (let ((browse-url-browser-function #'eaf-open-browser))
      (elfeed-show-visit use-generic-p)))

  (defun my/elfeed-show-visit-with-eww (&optional use-generic-p)
    (interactive "P")
    (let ((browse-url-browser-function #'my/elfeed-eww-browse-url)
          (eww-retrieve-command my/eww-retrieve-command))
      (elfeed-show-visit use-generic-p)))

  (defun my/elfeed-org-roam-capture ()
    "Capture metadata of the current elfeed-entry to org-roam."
    (interactive)
    (let* ((title (elfeed-entry-title elfeed-show-entry))
           (link (elfeed-entry-link elfeed-show-entry))
           (node (org-roam-node-create :title title))
           (body (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (org-roam-capture-templates
            `(("d" "default - capture the current elfeed show entry"
               plain ,(format "\n%%?\nlink: [[%s][%s]]\n\n%s" link title
                              (with-temp-buffer
                                (insert body)
                                (shr-render-region (point-min) (point-max))
                                (buffer-substring-no-properties (point-min) (point-max))))
               :target (file+head "fleeting/${slug}.org"
                                  "#+title: ${title}\n")
               :unnarrowed t
               :kill-buffer t))))
      (org-roam-capture- :keys "d" :node node :info `(:ref ,link))))

  ;; Sort feed entries by source.
  ;; https://www.reddit.com/r/emacs/comments/xwmnyv/is_it_possible_to_sort_elfeed_entries_by_source/
  (defun my/elfeed-search-sort--feed-url (a b)
    (string-lessp
     (elfeed-feed-url (elfeed-entry-feed a))
     (elfeed-feed-url (elfeed-entry-feed b))))

  (defun my/elfeed-search-toggle-sort (&optional order)
    "Toggle sort function or order for elfeed search"
    (interactive "P")
    (if order
        (setq elfeed-sort-order
              (if (eq elfeed-sort-order 'descending) 'ascending 'descending))
      (setq elfeed-search-sort-function
            (if elfeed-search-sort-function
                nil #'my/elfeed-search-sort--feed-url)))
    (elfeed-search-update t))

  ;; Enable sort by source by default
  (setq elfeed-sort-order 'ascending
        elfeed-search-sort-function #'my/elfeed-search-sort--feed-url))

(use-package elfeed-goodies
  :disabled
  :after elfeed
  :custom
  (elfeed-goodies/feed-source-column-width 20)
  (elfeed-goodies/tag-column-width 20)
  (elfeed-goodies/entry-pane-position 'right)
  (elfeed-goodies/entry-pane-size 0.5)
  :config
  (elfeed-goodies/setup))

(use-package elfeed-org
  :after (elfeed org)
  :custom
  (rmh-elfeed-org-files (list "~/.elfeed.org"))
  :config
  (elfeed-org))
#+end_src

*** elfeed-tube

#+begin_src emacs-lisp
(use-package elfeed-tube
  :after elfeed
  :commands (elfeed-tube-add-feeds)
  :custom
  (elfeed-tube-auto-save-p t)
  (elfeed-tube-auto-fetch-p t)
  (elfeed-tube-captions-languages
   '("ja" "japanese" "japanese (auto generated)" "en" "english" "english (auto generated)"))
  :bind (:map elfeed-show-mode-map
              ("F" . elfeed-tube-fetch)
              ([remap save-buffer] . elfeed-tube-save)
              :map elfeed-search-mode-map
              ("F" . elfeed-tube-fetch)
              ([remap save-buffer] . elfeed-tube-save))
  :config
  (elfeed-tube-setup)
  )

(use-package elfeed-tube-mpv
  :after elfeed
  :bind (:map elfeed-show-mode-map
              ("C-c C-f" . elfeed-tube-mpv-follow-mode)
              ("C-c C-w" . elfeed-tube-mpv-where)))
#+end_src

** engine-mode
#+begin_src emacs-lisp
(use-package engine-mode
  :config
  (defengine amazon-jp
    "https://amazon.co.jp/s?k=%s"
    :keybinding "a")

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :term-transformation-hook (lambda (term) (if current-prefix-arg
                                                 (concat "\"" term "\"")
                                               term)))

  (defengine deepl
    "https://www.deepl.com/ja/translator#en/ja/%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s")

  (defengine google
    "https://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :term-transformation-hook (lambda (term) (if current-prefix-arg
                                                 (concat "\"" term "\"")
                                               term))
    :keybinding "g")

  (defengine google-images
    "https://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s")

  (defengine google-maps
    "https://maps.google.com/maps?q=%s"
    :docstring "Mappin' it up."
    :keybinding "m")

  (defengine google-translate
    "https://translate.google.com/?sl=auto&tl=ja&text=%s&op=translate"
    :keybinding "t")

  (defengine twitter
    "https://twitter.com/search?q=%s"
    :keybinding "x")

  (defengine wikipedia
    "https://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w"
    :docstring "Searchin' the wikis.")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine wolfram-alpha
    "https://www.wolframalpha.com/input/?i=%s")

  (defengine youtube
    "https://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y")

  (engine-mode t))
#+end_src

** go-translate

#+begin_src emacs-lisp
(use-package plz)
(use-package gt
  :bind (("C-c y" . gt-translate)
         ("C-c Y" . gt-switch-translator))
  :config
  (setq gt-langs '(en ja))

  (defun my/gt-strip-linebreak (ts)
    (with-slots (text) ts
      (setf text
            (mapcar (lambda (s) (string-replace "\n" " " s)) text))
      ))

  (setq my/gt-deepl
        (gt-translator :taker (gt-taker
                               :langs '(en ja)
                               :text 'word
                               :then #'my/gt-strip-linebreak)
                       :engines (gt-deepl-engine
                                 :key (my/get-deepl-api-key))
                       :render (gt-buffer-render
                                :name "*gt-result*"
                                :window-config '((display-buffer-at-bottom))
                                :then (lambda (_) (pop-to-buffer "*gt-result*"))))
        my/gt-google-translate
        (gt-translator :taker (gt-taker
                               :langs '(en ja)
                               :text 'word
                               :then #'my/gt-strip-linebreak)
                       :engines (gt-google-engine)
                       :render (gt-buffer-render
                                :name "*gt-result*"
                                :window-config '((display-buffer-at-bottom))
                                :then (lambda (_) (pop-to-buffer "*gt-result*"))))
        my/gt-groq-llama-3.3
        (gt-translator :taker (gt-taker
                               :langs '(en ja)
                               :text 'sentence
                               :then #'my/gt-strip-linebreak)
                       :engines (gt-chatgpt-engine
                                 :host "https://api.groq.com/openai"
                                 :model "llama-3.3-70b-versatile"
                                 :key (my/get-groq-api-key))
                       :render (gt-buffer-render
                                :name "*gt-result*"
                                :window-config '((display-buffer-at-bottom))
                                :then (lambda (_) (pop-to-buffer "*gt-result*")))))

  (setq gt-preset-translators
        `((google-translate . ,my/gt-google-translate)
          (deepl . ,my/gt-deepl)
          (groq-llama-3.3 . ,my/gt-groq-llama-3.3)))

  ;; Add key bindings for the render buffer.
  (advice-add #'gt-keybinds :after
              (lambda (fn &rest args)
                (gt-buffer-render-key ("SPC")  #'scroll-up-command)
                (gt-buffer-render-key ("N")  #'scroll-up-command)
                (gt-buffer-render-key ("S-SPC")  #'scroll-up-command)
                (gt-buffer-render-key ("P")  #'scroll-down-command)))
  )
#+end_src

** consult-omni

#+begin_src emacs-lisp
;; consult-omni depends on browser-hist.
(use-package browser-hist
  :config
  (setq browser-hist-default-browser 'chrome)
  :commands (browser-hist-search))

(use-package consult-gh
  :straight (consult-gh :type git :host github :repo "armindarvish/consult-gh")
  :commands (consult-gh-search-repos))

(use-package consult-omni
  :straight (consult-omni :type git
                          :host github
                          :repo "armindarvish/consult-omni"
                          :files (:defaults "sources/*.el"))
  :bind ( :map my/search-map
          ("/" . consult-omni-multi)
          ("a" . consult-omni-apps)
          ("e" . consult-omni-elfeed)
          ("g" . consult-omni-google)
          ("G" . consult-omni-github)
          ("l" . consult-omni-locate)
          ("n" . consult-omni-notes-search)
          ("s" . consult-omni-multi-static)
          ("w" . consult-omni-wikipedia)
          ("y" . consult-omni-youtube))
  :custom
  ;; General settings that apply to all sources
  (consult-omni-show-preview t) ;;; show previews
  (consult-omni-preview-key "C-o") ;;; set the preview key to C-o
  (consult-omni-default-count 20)  ;; get search results up to 20
  :config
  ;; Load Sources Core code
  (require 'consult-omni-sources)
  (require 'consult-omni-apps)
  (require 'consult-omni-bing)
  (require 'consult-omni-browser-history)
  (require 'consult-omni-elfeed)
  (require 'consult-omni-invidious)
  (require 'consult-omni-notes)
  (require 'consult-omni-gh)
  (require 'consult-omni-google)
  (require 'consult-omni-google-autosuggest)
  (require 'consult-omni-locate)
  (require 'consult-omni-wikipedia)
  (require 'consult-omni-youtube)

  ;; Load Embark Actions
  (require 'consult-omni-embark)

  ;; Either load all source modules or a selected list

  ;;; Select a list of modules you want to aload, otherwise all sources all laoded
  ;; (setq consult-omni-sources-modules-to-load (list 'consult-omni-wkipedia 'consult-omni-notes))
  (consult-omni-sources-load-modules)
  ;;; set multiple sources for consult-omni-multi command. Change these lists as
  ;;; needed for different interactive commands. Keep in mind that each source
  ;;; has to be a key in `consult-omni-sources-alist'.
  (setq consult-omni-multi-sources '(;; "calc"
                                     ;; "File"
                                     ;; "Buffer"
                                     ;; "Bookmark"
                                     "Apps"
                                     ;; "gptel"
                                     ;; "Brave"
                                     ;; "Dictionary"
                                     "Org Agenda"
                                     "locate"
                                     "Notes Search"
                                     "Browser History"
                                     "Google"
                                     "Wikipedia"
                                     "elfeed"
                                     ;; "mu4e"
                                     ;; "buffers text search"
                                     "GitHub"
                                     "YouTube"
                                     ;; "Invidious"
                                     ))

  ;; Per source customization

  ;;; Set API KEYs. It is recommended to use a function that returns the string for better security.
  (setq consult-omni-google-customsearch-key
        (auth-source-pick-first-password :host "google-cse-api-key"))
  (setq consult-omni-google-customsearch-cx
        (auth-source-pick-first-password :host "google-cse-id"))
  (setq consult-omni-youtube-search-key
        (auth-source-pick-first-password :host "google-youtube-api-key"))

  ;; (setq consult-omni-brave-api-key "YOUR-BRAVE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-stackexchange-api-key "YOUR-STACKEXCHANGE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-pubmed-api-key "YOUR-PUBMED-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-openai-api-key "YOUR-OPENAI-API-KEY-OR-FUNCTION")

  ;;; Pick you favorite autosuggest command.
  (setq consult-omni-default-autosuggest-command #'consult-omni-google-autosuggest)

  ;;; Set your shorthand favorite interactive command
  (setq consult-omni-default-interactive-command #'consult-omni-multi)

  ;; Set symbol in region or at point as initial input.
  (dolist (cmd '( consult-omni-multi consult-omni-apps consult-omni-elfeed
                  consult-omni-google consult-omni-github consult-omni-locate
                  consult-omni-notes-search consult-omni-multi-static
                  consult-omni-wikipedia consult-omni-youtube))
    (eval
     `(consult-customize
       ,cmd
       :initial (if (use-region-p)
                    (buffer-substring (region-beginning) (region-end))
                  (thing-at-point 'symbol)))))
  )
#+end_src

* Emacs Application Framework

#+begin_src emacs-lisp
(use-package eaf
  :straight (eaf :type git :host github
                 :repo "emacs-eaf/emacs-application-framework"
                 :depth 1 :branch "master"
                 :files (:defaults "*.el" "*.py" "*.json"
                                   ("extension" "extension/*") ("core" "core/*")))
  :preface
  ;; Launch initial install script.
  (unless (file-directory-p (format "%s/straight/%s/eaf/app" straight-base-dir straight-build-dir))
    (eaf-install-and-update))
  :custom
  (eaf-python-command "/usr/bin/python3"))
#+end_src

** eaf-browser

#+begin_src emacs-lisp
(use-package eaf-browser
  :after eaf
  :straight nil
  :commands (eaf-open-browser)
  :custom
  (eaf-browser-continue-where-left-off t)
  (eaf-browser-enable-adblocker t)
  (eaf-browser-translate-language "ja")
  :config
  (defalias 'browse-web #'eaf-open-browser)
  (eaf-bind-key insert_or_scroll_down_page "<backspace>" eaf-browser-keybinding)
  (eaf-bind-key nil "M-q" eaf-browser-keybinding) ;; unbind, see more in the Wiki
  (eaf-bind-key insert_or_scroll_down_page "<backspace>" eaf-browser-keybinding)
  (eaf-bind-key insert_or_close_buffer ";" eaf-browser-keybinding)
  (eaf-bind-key insert_or_close_buffer "q" eaf-browser-keybinding)
  (eaf-bind-key insert_or_history_backward "b" eaf-browser-keybinding)
  (eaf-bind-key insert_or_edit_url "C-l" eaf-browser-keybinding)

  (defun my/toggle-eaf-browser ()
    "Toggle setting eaf-browser to browse-url-browser-function."
    (interactive)
    (defvar my/browse-url-saved-browser-function)
    (setq browse-url-browser-function
          (if (eq browse-url-browser-function #'eaf-open-browser)
              my/browse-url-saved-browser-function
            (setq my/browse-url-saved-browser-function browse-url-browser-function)
            #'eaf-open-browser))))
#+end_src

** eaf-pdf-viewer

#+begin_src emacs-lisp
(use-package eaf-pdf-viewer
  :after eaf
  :straight nil
  :config
  (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)

  (with-eval-after-load 'tex
    (add-to-list 'TeX-view-program-list '("eaf" eaf-pdf-synctex-forward-view))
    (add-to-list 'TeX-view-program-selection '(output-pdf "eaf"))))
#+end_src


** eaf-pyqterminal

#+begin_src emacs-lisp
(use-package eaf-pyqterminal
  :after eaf
  :straight nil
  :commands (eaf-open-pyqterminal))
#+end_src

** eaf-markdown-previewer

#+begin_src emacs-lisp
(use-package eaf-markdown-previewer
  :after eaf
  :straight nil
  :config
  (with-eval-after-load 'markdown-mode
    (defun my/markdown-preview (&optional output-buffer-name)
      "Advice to launch eaf-markdown-previewer with the current buffer."
      (interactive)
      (when (derived-mode-p 'markdown-mode)
        (eaf-open-this-buffer)))

    (advice-add #'markdown-preview :override #'my/markdown-preview)))
#+end_src

** eaf-org-previewer

#+begin_src emacs-lisp
(use-package eaf-org-previewer
  :after eaf
  :straight nil)
#+end_src

* Post Init Config

Load postinit.org if exists.

#+begin_src emacs-lisp
(let ((postinit-file (expand-file-name "~/.emacs.d/postinit.org")))
  (when (file-exists-p postinit-file)
    (org-babel-load-file postinit-file)))
#+end_src

* Post post-init config

** GC settings

Set GC parameters here to reset the initial value set in early-init.el.
Also, add measurement of GC time with the code borrowed by https://akrl.sdf.org/#orgc15a10d.

#+begin_src emacs-lisp
(setq garbage-collection-messages nil)
(setq gc-cons-threshold (* 100 1024 1024))

(defmacro my/k-time (&rest body)
  "Measure and return the time it takes evaluating BODY."
  `(let ((time (current-time)))
     ,@body
     (float-time (time-since time))))

(defvar my/show-gc-time nil)
(defun my/gc ()
  (let ((gc-time (my/k-time (garbage-collect))))
    (when my/show-gc-time
      (message "Garbage Collector has run for %.06fsec" gc-time))))

(defvar my/k-gc-timer (run-with-idle-timer 15 t #'my/gc))
(add-function :after after-focus-change-function #'my/gc)
#+end_src

* EOF

#+begin_src emacs-lisp
(provide 'emacs-init)
#+end_src
