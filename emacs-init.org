#+title: Emacs configuration
#+startup: content indent
#+property: header-args :tangle yes

*Note: This Emacs configuration required Emacs 29.1 or above.*

* Use-package integration with straight.el

Load ~use-package~ using straight.el

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+end_src

* Pre Init Config

Load preinit.org if exists.

#+begin_src emacs-lisp
(let ((preinit-file (expand-file-name "~/.emacs.d/preinit.org")))
  (when (file-exists-p preinit-file)
    (org-babel-load-file preinit-file)))
#+end_src

* Macros

Some tiny macros to increase code readability and take care of the issue with
:if keyword not working with straight.el.

#+begin_src emacs-lisp
  (defmacro use-package-if (cond name &rest args)
    `(when ,cond
       (use-package ,name ,@args)))

  (defmacro when-use-exwm (&rest body)
    `(when (and (eq window-system 'x)
                (member (getenv "use_exwm") '("1" "yes")))
       (progn ,@body)))

  (defmacro when-not-use-exwm (&rest body)
    `(unless (and (eq window-system 'x)
                  (member (getenv "use_exwm") '("1" "yes")))
       (progn ,@body)))

  (defmacro use-package-if-exwm (name &rest args)
    `(when-use-exwm
      (use-package ,name ,@args)))

  (defmacro use-package-if-not-exwm (name &rest args)
    `(when-not-use-exwm
      (use-package ,name ,@args)))

  (defmacro use-package-if-gui (name &rest args)
    `(when window-system
       (use-package ,name ,@args)))
#+end_src

* Basic config

Miscellaneous built-in features are configured and customzied here.

** Server

Start emacs server function so emacsclient processes can connect to this
instance. ~restart-server~ is a helper function to restart the server process.

#+begin_src emacs-lisp
  (require 'server)
  (defun my/restart-server ()
    "Restarts server."
    (interactive)
    (message "restarting server...")
    (server-force-stop)
    (server-force-delete)
    (server-start))

  ;; Workaround for the env where another Emacs instance is running on CRD.
  (when (getenv "CHROME_REMOTE_DESKTOP_SESSION")
    (setq server-name "crd"))

  (my/restart-server)
#+end_src

** Dired

A few tweaks to make dired work better for me.

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :custom
  ;; make file size format human-friendly
  (dired-listing-switches "-alh")
  :bind (:map dired-mode-map
              ("k" . dired-kill-subdir)))

(use-package wdired
  :straight (:type built-in)
  :custom
  (wdired-allow-to-change-permissions t))
#+end_src

** General editor preferences

Customization for miscellaneous built-in features.

#+begin_src emacs-lisp
;; Increase read buffer.
(setq read-process-output-max (* 8 1024 1024))
(setq process-adaptive-read-buffering t)

;; Use spaces for indentation.
(setq-default indent-tabs-mode nil)

;; Disable native-comp warnings.
(setq native-comp-async-report-warnings-errors 'silent)

;; Auto-save visited files every 30sec.
(setq auto-save-visited-interval 30)
(auto-save-visited-mode +1)

;; Set additional load-path.
(add-to-list 'load-path "~/lib/elisp")

;; No warning message when function is redefined by advice.
(setq ad-redefinition-action 'accept)

;; No duplicates in history.
(setq history-delete-duplicates t)

;; C-u SPC pops the last mark, afterwords no C-u is needed for further pops.
(setq set-mark-command-repeat-pop t)

(global-auto-revert-mode)
(transient-mark-mode t)
(show-paren-mode 1)

;; Show the paired paren at the top-right corner when it's off screen.
(setq show-paren-context-when-offscreen 'overlay)

;; Allows yanking text into an isearch without moving the mouse cursor to the
;; echo area.
(setq mouse-yank-at-point t)

;; Inhibit backups.
(setq backup-inhibited t)

;; Kill the whole line at start of line.
(setq kill-whole-line t)

:; Do not automatically add a newline.
(setq require-final-newline nil)

;; Increase size of log and history.
(setq message-log-max 10000)
(setq history-length 1000)

;; Disable novice restrictions.
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)

;; Fit within 80 columns by default.
(setq-default fill-column 80)
;; (add-hook 'text-mode-hook '(lambda () (auto-fill-mode 1)))

;; Do not truncate lines. I'd prefer wrapping lines.
(setq truncate-partial-width-windows nil)
(setq truncate-line nil)

;; Resolve symlinks.
(setq find-file-visit-truename t)

;; Shift key enables accelerated cursor movement on a per-word basis.
(require 'misc)
(global-set-key (kbd "C-S-f") 'forward-to-word)
(global-set-key (kbd "C-S-b") 'backward-word)

;; Display function name in mode line.
;; (which-function-mode 1)

;; Set UTF-8 as the language environment.
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)

;; Enable winner-mode which does undo/redo of window configuration with C-c
;; left/right.
(winner-mode 1)

;; Automatically focus help and man windows when displayed.
(setq help-window-select t)
(setq Man-notify-method 'aggressive)

;; Add word-wrap-whitespace-mode to visual line mode so line wrapping works as
;; expected for non English text.
(add-hook 'visual-line-mode-hook #'word-wrap-whitespace-mode)
#+end_src

Change the format of buffer name to /<unique dir suffix>/<filename>/.

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t)
(setq uniquify-ignore-buffers-re "^\\*")
#+end_src

** Electric Pair Mode
Enable electric pair mode not that I'm moving away from smartparens.

#+begin_src emacs-lisp
(use-package elec-pair
  :straight (:type built-in)
  :config
  (electric-pair-mode 1))
#+end_src

** Run chmod +x on save for script files

Emacs now has built-in function for this so I'll just use it instead of custom
code which is copied from [[http://www.namazu.org/~tsuchiya/elisp/][here]].

#+begin_src emacs-lisp
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

;; Keep old code for now, but it'll be deleted in the future.
;; #'(lambda ()
;;     (save-restriction
;;       (widen)
;;       (if (string= "#!" (buffer-substring 1 (min 3 (point-max))))
;;           (let ((name (buffer-file-name)))
;;             (or
;;              (char-equal ?. (string-to-char
;;                              (file-name-nondirectory name)))
;;              (let ((mode (file-modes name)))
;;                (set-file-modes name
;;                                (logior mode (logand (/ mode 4) 73)))
;;                (message (concat "Wrote " name " (+x)"))))
;;             ))))
#+end_src

** Tramp

#+begin_src emacs-lisp
;; tramp to access remote files transparently
(use-package tramp
  :straight (:type built-in)
  :defer t
  :custom
  (tramp-default-method "ssh"))
#+end_src

** Ediff

TODO: watch [[https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/][this video]].

#+begin_src emacs-lisp
(use-package ediff
  :commands (ediff ediff3)
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally))
#+end_src

** Authinfo

#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg"))
#+end_src

*** EasyPG

IIRC this is a workaround for some issues with authinfo that I don't
remember. Not sure if this is still needed to make authinfo work in my
environment.

#+begin_src emacs-lisp
(require 'epa-file)
(setq epa-pinentry-mode 'loopback)
#+end_src

** Plstore

#+begin_src emacs-lisp
(use-package plstore
  :straight (:type built-in)
  :custom
  (plstore-encrypt-to (getenv "PLSTORE_GPG_KEY")))
#+end_src

** EWW

#+begin_src emacs-lisp
(use-package eww
  :bind ( :map eww-mode-map
          ("j" . scroll-up-command)
          ("k" . scroll-down-command)
          ("N" . scroll-up-command)
          ("P" . scroll-down-command)
          ("v" . eww-browse-with-external-browser)
          ("T" . my/eww-toggle-auto-readable)
          :map eww-link-keymap
          ("v" . my/browse-url-at-point))
  :hook ((eww-after-render . my/eww-maybe-auto-readable)
         (eww-after-render . my/eww-set-initial-position))
  :config

  ;; Controls behaviour of auto readable feature.
  (defvar my/eww-enable-auto-readable t)
  (defun my/eww-toggle-auto-readable ()
    (interactive)
    (setq my/eww-enable-auto-readable (not my/eww-enable-auto-readable))
    (when (derived-mode-p 'eww-mode)
      (eww-reload)))

  ;; Regexp of URLS that readable mode should be automatically enabled for.
  (defvar my/eww-auto-readable-urls
    '("cnn.co.jp" "apnews.com" "doorblog.jp" "mql5.com" "gizmodo.jp"))

  ;; Automatically enable readable mode for the sites specified above.
  (defun my/eww-maybe-auto-readable ()
    (let ((url (eww-current-url))
          (pat-list my/eww-auto-readable-urls))
      (while-let ((pat (car pat-list)))
        (when (and my/eww-enable-auto-readable
                   (string-match-p pat url))
          (eww-readable)
          (setq pat-list nil))
        (setq pat-list (cdr pat-list)))))

  ;; alist of (<URL pattern> . <text pattern>).
  (defvar my/eww-set-initial-position-alist
    '(("reddit.com/" . "submitted .+ ago \\(\\* \\)?by ")))

  ;; Set initial position to directly get to the text of interest for the sites
  ;; specified above. (e.g. a site with many skippable lines at the top)
  (defun my/eww-set-initial-position ()
    (let ((url (eww-current-url))
          (alist my/eww-set-initial-position-alist))
      (while-let ((site-data (car alist)))
        (let ((url-pat (car site-data))
              (text-pat (cdr site-data)))
          (when (string-match-p url-pat url)
            (let ((p (search-forward-regexp text-pat nil t)))
              (when p
                (goto-char p)
                (beginning-of-line)
                (set-window-start nil (window-point))
                (setq alist nil))))
          (setq alist (cdr alist))))))
  )
#+end_src

** SHR

This is a temporary measure. Set variables to try to avoid unwanted line breaks.

#+begin_src emacs-lisp
(use-package shr
  :bind (:map shr-map
              ("j" . scroll-up-command)
              ("k" . scroll-down-command)
              ("RET" . my/shr-browse-url-with-eww))
  :custom
  (shr-use-fonts nil)
  (shr-max-width 100000)
  :config

  ;; Forcibly use EWW to browse a URL.
  (defun my/shr-browse-url-with-eww (&optional external mouse-event new-window)
    (interactive (list current-prefix-arg last-nonmenu-event))
    (let ((url (get-text-property (point) 'shr-url))
          (browse-url-browser-function #'eww-browse-url))
      (browse-url url)))
  )
#+end_src

** Browse URL

Add small wrappers so that I can launch intended browser as needed.

#+begin_src emacs-lisp
(defun my/browse-url-at-point-with-default-browser ()
  (interactive)
  (let ((browse-url-browser-function #'browse-url-default-browser))
    (call-interactively #'browse-url-at-point)))

(defun my/browse-url-at-point-with-eww ()
  (interactive)
  (let ((browse-url-browser-function #'eww-browse-url))
    (call-interactively #'browse-url-at-point)))

(defun my/browse-url-at-point (&optional arg)
  (interactive "P")
  (if arg (my/browse-url-at-point-with-eww)
    (my/browse-url-at-point-with-default-browser)))
#+end_src

** Image Converter

#+begin_src emacs-lisp
(setq image-use-external-converter t)
(setq image-converter--converters '((imagemagick :command "magick-elfeed" :probe ("-list" "format"))))
(setq image-converter 'imagemagick)
(setq image-converter-file-name-extensions '("avif"))

;; Add support of avif to take care of some sites returning missing
;; content-type header for avif.
(add-to-list 'image-type-header-regexps '("\\`\0\0\0 ftypavif" . image-convert))
(defun my/image-convert (orig image &optional format)
  (apply orig (list image (or (and (eq format t) 'image/avif) format))))
(advice-add 'image-convert :around #'my/image-convert)
#+end_src

** recentf

#+begin_src emacs-lisp
(use-package recentf
  :custom
  (recentf-max-saved-items 100)
  (recentf-exclude '("/org/roam/"))
  :config
  (recentf-mode))
#+end_src

** project and xref

If eglot is used, project and xref need to be loaded from built-in packages.

#+begin_src emacs-lisp
(use-package project
  :disabled
  :straight (:type built-in))

(use-package xref
  :disabled
  :straight (:type built-in))
#+end_src

* User Interface

Configure different features and settings that are related to user interface.

** Fonts and Faces

Face related settings are always in progress. The ~unless (daemonp)~ part is
probably a workaround to avoid errors when emacs is launched in daemon mode, but
I don't remember the reason.

Fonts and face settings are grouped into helper functions so that they can be
called in hooks.

#+begin_src emacs-lisp
(require 'font-lock)
(setq font-lock-maximum-decoration t)
(global-font-lock-mode t)

(defun my/setup-faces ()
  "Set faces for my preference."
  (interactive)
  (set-face-attribute 'default nil
                      :foreground "#abb2bf"
                      :background (if window-system "#282c34" "#000000"))
  (set-face-attribute 'region nil
                      :foreground 'unspecified
                      :background "RoyalBlue4")
  (set-face-foreground 'show-paren-match "orange")
  (set-face-attribute 'font-lock-doc-face nil
                      :foreground "azure3"
                      :background 'unspecified)
  (set-face-attribute 'font-lock-comment-face nil
                      :foreground "azure4"
                      :background 'unspecified
                      :slant 'italic)
  (set-face-attribute 'font-lock-comment-delimiter-face nil
                      ;; :weight 'bold
                      :inherit 'font-lock-comment-face)
  (set-face-attribute 'font-lock-constant-face nil
                      :weight 'unspecified)
  (set-face-attribute 'highlight nil
                      ;; :foreground "orange"
                      ;; :background 'unspecified
                      :background "dark slate gray"
                      :weight 'bold)
  (set-face-attribute 'ansi-color-blue nil
                      :foreground "DodgerBlue")
  (set-face-attribute 'tab-bar nil
                      :family "Monospace"
                      :background "gray15"
                      :inherit 'unspecified)
  (set-face-attribute 'tab-bar-tab-inactive nil
                      :foreground "gray"
                      :background "gray15")
  (set-face-attribute 'tab-bar-tab nil
                      :foreground "white"
                      :background "gray20")
  (set-face-foreground 'font-lock-variable-name-face "khaki")
  (set-face-foreground 'font-lock-function-name-face "dodger blue")

  (set-face-attribute 'outline-1 nil :height 1.2)
  (set-face-attribute 'outline-2 nil :height 1.05)

  (unless (daemonp)
    (set-face-attribute 'mode-line-inactive nil
                        :foreground "darkgray"
                        :background "gray10"
                        :inherit 'mode-line)))

(defun my/set-default-font (font)
  "Set font for default face."
  (interactive "sFont: ")
  (let ((font (if (string= font "")
                    my/default-font font)))
    (set-face-attribute 'default nil :font (my/make-font-str font))
    (setq my/default-font font)))

(defun my/set-fontset-emoji-font (&optional fset)
  "Set up color emoji font to the given FONTSET or fontset for default face."
  (let ((emoji-font (font-spec :family "Noto Color Emoji"))
        (fontset (or fset (face-attribute 'default :fontset))))
    (dolist (charset '((#x3200 . #x32ff) symbol emoji))
      (set-fontset-font fontset charset emoji-font nil 'prepend))))

(defun my/set-fontset-jp-font (family &optional fset)
  "Set up japanse font to the given FONTSET or fontset for default face."
  (let ((fontset (or fset (face-attribute 'default :fontset))))
    (dolist (charset '((#x3000 . #x30ff)
                       (#x31f0 . #x31ff)
                       (#x3400 . #x4dbf)
                       (#x4e00 . #x9fff)
                       (#xff65 . #xff9f)
                       (#x20000 . #x2ebef)))
      (set-fontset-font fontset charset
                        `(,family . "iso10646-1") nil `prepend))))

(defun my/setup-fonts ()
  "Set up fontsets for my preference."
  (interactive)
  (setq use-default-font-for-symbols nil)
  (my/set-fontset-emoji-font))

;; Set up variable-pictch and fixed-pitch for mixed font environments.
(custom-theme-set-faces
 'user
 `(variable-pitch ((t (:font ,(my/make-font-str "Noto Serif CJK JP"))))))
#+end_src

** Misc display tweaks

Different tweaks on appearance.

#+begin_src emacs-lisp
  ;; Display time and load in the mode line.
  (when-use-exwm
   (display-time-mode +1))

  ;; Display line and column numbers in the mode line.
  (line-number-mode +1)
  (column-number-mode +1)

  ;; Enable visual bell.
  (setq visible-bell t)

  ;; Highlight line mode.
  ;; (use-package hl-line
  ;;   :hook ((org-mode-hook
  ;;          prog-mode-hook
  ;;          text-mode-hook
  ;;          yaml-mode-hook) . hl-line-mode)
  ;;   :config
  ;;   (set-face-attribute 'hl-line nil
  ;;                       :foreground 'unspecified
  ;;                       :background "gray15")
  ;;   )

  ;; Disable unnecessary features for some performance optimization.
  (setq use-dialog-box nil)
  (setq bidi-inhibit-bpa t)
  (setq redisplay-skip-fontification-on-input t)
  (setq-default indicate-empty-lines t)
  (setq-default bidi-display-reordering 'left-to-right)

  ;; Somehow pixel scrolling does not work well yet.
  ;; (setq pixel-scroll-precision-use-momentum t)
  ;; (pixel-scroll-precision-mode)
#+end_src

** Icons

*** nerd-icons

#+begin_src emacs-lisp
(use-package nerd-icons
  :straight (nerd-icons
             :type git
             :host github
             :repo "rainstormstudio/nerd-icons.el"
             :files (:defaults "data"))
  :custom
  ;; The Nerd Font you want to use in GUI
  ;; "Symbols Nerd Font Mono" is the default and is recommended
  ;; but you can use any other Nerd Font if you want
  (nerd-icons-font-family "Symbols Nerd Font Mono")
  )
#+end_src

** Keymaps

Create a dedicated keymap to group various commands with the same key
prefix. This way which-key will be more useful.

*** Editing

#+begin_src emacs-lisp
(define-prefix-command 'my/edit-map)
(global-set-key (kbd "C-c SPC") 'my/edit-map)
(define-key my/edit-map " " #'set-mark-command)
#+end_src

*** Window/Workspace Management

#+begin_src emacs-lisp
(define-prefix-command 'my/wm-map)
(global-set-key (kbd "C-c w") 'my/wm-map)
#+end_src

*** Information

#+begin_src emacs-lisp
(define-prefix-command 'my/info-map)
(global-set-key (kbd "C-c i") 'my/info-map)
#+end_src

*** Search

#+begin_src emacs-lisp
(define-prefix-command 'my/search-map)
(global-set-key (kbd "M-s /") 'my/search-map)
#+end_src

*** AI map

#+begin_src emacs-lisp
(define-prefix-command 'my/ai-map)
(global-set-key (kbd "C-c a") 'my/ai-map)
#+end_src

*** Misc

#+begin_src emacs-lisp
(define-prefix-command 'my/misc-map)
(global-set-key (kbd "C-q") 'my/misc-map)
(define-key my/misc-map (kbd "C-q") 'quoted-insert)
#+end_src

** Key bindings

#+begin_src emacs-lisp
;; Bind C-z to tab bar prefix to replace persp-mode with tab bar.
(global-set-key (kbd "C-z") tab-prefix-map)
 ;; Remap tab-rename as C-z r will be bound to my/consult-recent-file-other-tab
(define-key tab-prefix-map "R" #'tab-rename)
(defun my/new-tab-with-scratch ()
  (interactive)
  (switch-to-buffer-other-tab (get-scratch-buffer-create)))
(define-key tab-prefix-map "s" #'my/new-tab-with-scratch)

;; Change key translation map
;; - bind function of C-? (DEL) to C-h
;; - bind function of C-h (help) to C-]
(define-key key-translation-map [?\C-h] [?\C-?])
(define-key key-translation-map [?\C-\]] [?\C-h])

;; ibuffer
(global-set-key (kbd "C-x B") 'ibuffer)

;; Bind tabify and untabify.
(global-set-key (kbd "M-T") 'tabify)
(global-set-key (kbd "C-x T") 'untabify)

;; Make find-file-other-window the default behavior for find-file.
;; (global-set-key (kbd "C-x C-f") 'find-file-other-window)

;; Bind some commands often used under C-x keymap.
(global-set-key (kbd "C-x 5 k") 'delete-frame)
(global-set-key (kbd "C-x K") 'kill-buffer-and-window)
(global-set-key (kbd "C-x U") 'revert-buffer)
(global-set-key (kbd "C-x %") 'query-replace-regexp)

;; Make switch to next/prev buffer easier.
(global-set-key (kbd "C-x C-n") 'switch-to-next-buffer)
(global-set-key (kbd "C-x C-p") 'switch-to-prev-buffer)

;; Make switch to scratch buffer easier, but often I forgot the key binding.
(defun my/toggle-popup-scratch-buffer ()
  (interactive)
  (let* ((buf (get-scratch-buffer-create))
         (win (get-buffer-window buf)))
    (if win (delete-window win)
        (pop-to-buffer buf))))
(global-set-key (kbd "M-S") #'my/toggle-popup-scratch-buffer)

;; To be used along with scroll-other-window-up (M-C-v).
(global-set-key (kbd "M-V") #'scroll-other-window-down)

;; Comment out in favor of org-mode key bindings.
;; Move to another window with S-<arrow>.
;; (when (fboundp 'windmove-default-keybindings)
;;   (windmove-default-keybindings))

;; Move to another window with C-<arrow>.
(when window-system
  ;; (global-set-key (kbd "C-<left>") #'windmove-left)
  ;; (global-set-key (kbd "C-<down>") #'windmove-down)
  ;; (global-set-key (kbd "C-<up>") #'windmove-up)
  ;; (global-set-key (kbd "C-<right>") #'windmove-right)
  (global-set-key (kbd "s-h") #'windmove-left)
  (global-set-key (kbd "s-j") #'windmove-down)
  (global-set-key (kbd "s-k") #'windmove-up)
  (global-set-key (kbd "s-l") #'windmove-right)
  (global-set-key (kbd "s-n") #'switch-to-next-buffer)
  (global-set-key (kbd "s-p") #'switch-to-prev-buffer)
  (global-set-key (kbd "s-C") #'kill-buffer-and-window)
  (global-set-key (kbd "s-f") #'find-file-other-window))

;; Bind some commands often used under C-c keymap.
(global-set-key (kbd "C-c c") #'compile)
(global-set-key (kbd "C-c v") #'view-mode)
(global-set-key (kbd "C-c B") #'my/browse-url-at-point)
(global-set-key (kbd "C-c K") #'bury-buffer)
#+end_src

** Input Method

Specify Japanese input method ~Mozc~ (which bases Google Japanese Input method).
Currently it is disabled as I don't want to build emacs-mozc on Arch.

#+begin_src emacs-lisp
(use-package mozc
  :disabled
  :custom
  (default-input-method "japanese-mozc")
  (mozc-candidate-style 'echo-area)
  :bind (("<muhenkan>" . toggle-input-method)
         ("M-SPC" . toggle-input-method)  ;; temporary measure
         :map mozc-mode-map
         ("<muhenkan>" . my/deactivate-input-method))
  :config
  (defun my/deactivate-input-method ()
    (interactive)
    (deactivate-input-method))

  (set-face-attribute 'mozc-preedit-selected-face nil
                      :foreground "#c0c0c0" :background "RoyalBlue4"))
#+end_src

#+begin_src emacs-lisp
(use-package mozc-cand-posframe
  :disabled
  :after mozc
  :config
  (setq mozc-candidate-style 'posframe)
  (set-face-attribute 'mozc-cand-posframe-normal-face nil
                      :foreground "#c0c0c0" :background "gray15")
  (set-face-attribute 'mozc-cand-posframe-focused-face nil
                      :foreground "#c0c0c0" :background "RoyalBlue4"))
#+end_src

** Misc input tweaks

#+begin_src emacs-lisp
;; wheel mouse support
(when window-system
  ;; enable wheelmouse support by default
  (mwheel-install)

  ;; make pasting utf8 text work
  (set-selection-coding-system 'utf-8))

;; Use shorter answer form (y or n).
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Modeline

#+begin_src emacs-lisp
;; Hide unnecessary mode information with Diminish.
(use-package diminish
  :config
  (diminish 'eldoc-mode))
#+end_src


*** doom-modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-mode))
#+end_src

** Setup UI look & feel

When running as daemon, apparently these functions need to be called whenever a
new emacsclient is connected hence ~server-after-make-frame-hook~ is set here.
Otherwise the same UI setup functions are called via ~emacs-startup-hook~.

#+begin_src emacs-lisp
(defun my/setup-ui ()
  "Sets up UI apperance."
  (interactive)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (when window-system
    (scroll-bar-mode -1)
    (fringe-mode 10))
  (my/setup-faces)
  (my/setup-fonts))

;; Hooks to forcibly reset UI for new frames by emacsclient.
(add-hook 'server-after-make-frame-hook 'my/setup-ui)

;; Initialize UI appearance for my preference.
(my/setup-ui)
#+end_src

** Key binding guidance

*** Which Key

I'm trying out which-key to see how useful key guidance is for me.

#+begin_src emacs-lisp
(use-package which-key
  :diminish
  :config
  ;; Enable which-key through manual activation with C-h only.
  (setq which-key-show-early-on-C-h t)
  (setq which-key-idle-delay 10000)
  (setq which-key-idle-secondary-delay 0.05)
  (which-key-mode))
#+end_src

*** Hydra

Hydra provides modal feature with key guidance, which is sometimes very useful
as you don't have to keep holding ctrl key.

#+begin_src emacs-lisp
(use-package hydra
  :bind (("C-c v" . my/hydra-move/body)
         ("M-g n" . my/hydra-next-error/body)
         :map my/wm-map
         ("r" . my/hydra-rectangle/body)
         ("w" . my/hydra-window/body)
         :map dired-mode-map
         ("." . my/hydra-dired/body))
  :config
  (require 'hydra-examples)

  ;; Here is my lazy cursor navigation setting I use when viewing a long file.

  (defun my/forward-to-symbol (arg)
    "Move forward until encountering the beginning of a symbol.
  With argument, do this that many times."
    (interactive "^p")
    (or (re-search-forward "\\W\\_<" nil t arg)
        (goto-char (if (> arg 0) (point-max) (point-min)))))

  (defun my/backward-to-symbol (arg)
    "Move backward until encountering the end of a symbol.
  With argument, do this that many times."
    (interactive "^p")
    (my/forward-to-symbol (- arg)))

  ;; Cursor movement
  (defhydra my/hydra-move (nil nil)
    "move"
    ("l" my/forward-to-symbol)
    ("h" my/backward-to-symbol)
    ("e" move-end-of-line)
    ("a" move-beginning-of-line)
    ("j" next-line)
    ("k" previous-line)
    ("n" forward-paragraph)
    ("p" backward-paragraph)
    ("SPC" scroll-up-command)
    ("N" scroll-up-command)
    ("S-SPC" scroll-down-command)
    ("P" scroll-down-command)
    ("q" nil))

  ;; window management
  (defun my/window-split-vertical ()
    (interactive)
    (split-window-right)
    (windmove-right))

  (defun my/window-split-horizontal ()
    (interactive)
    (split-window-below)
    (windmove-down))

  (defhydra my/hydra-window (nil nil :color red :hint nil)
    "
   Split: _v_ert _x_:horz
  Delete: _o_nly  _da_ce  _dw_indow  _db_uffer  _df_rame
    Move: _s_wap
  Frames: _f_rame new  _df_ delete
    Misc: _a_ce  _u_ndo  _r_edo"
    ("h" windmove-left)
    ("j" windmove-down)
    ("k" windmove-up)
    ("l" windmove-right)
    ("H" (hydra-move-splitter-left 4))
    ("J" (hydra-move-splitter-down 4))
    ("K" (hydra-move-splitter-up 4))
    ("L" (hydra-move-splitter-right 4))
    ("|" my/window-split-vertical)
    ("_" my/window-split-horizontal)
    ("v" split-window-right)
    ("x" split-window-below)
    ;; winner-mode must be enabled
    ("u" winner-undo)
    ("r" winner-redo) ;;Fi
    ("o" delete-other-windows :exit t)
    ("a" ace-window :exit t)
    ("f" make-frame :exit t)
    ("s" ace-swap-window)
    ("da" ace-delete-window)
    ("dw" delete-window)
    ("db" kill-this-buffer)
    ("df" delete-frame :exit t)
    ("q" nil))

  (defhydra my/hydra-rectangle (nil nil
                                    :body-pre (rectangle-mark-mode 1)
                                    :color pink
                                    :hint nil
                                    :post (deactivate-mark))
    "
    ^_k_^       _w_ copy      _o_pen       _N_umber-lines            |\\     -,,,--,,_
  _h_   _l_     _y_ank        _t_ype       _e_xchange-point          /,`.-'`'   ..  \-;;,_
    ^_j_^       _d_ kill      _c_lear      _r_eset-region-mark      |,4-  ) )_   .;.(  `'-'
  ^^^^          _u_ndo        _q_ quit     ^ ^                     '---''(./..)-'(_\_)
  "
    ("k" rectangle-previous-line)
    ("j" rectangle-next-line)
    ("h" rectangle-backward-char)
    ("l" rectangle-forward-char)
    ("d" kill-rectangle)                    ;; C-x r k
    ("y" yank-rectangle)                    ;; C-x r y
    ("w" copy-rectangle-as-kill)            ;; C-x r M-w
    ("o" open-rectangle)                    ;; C-x r o
    ("t" string-rectangle)                  ;; C-x r t
    ("c" clear-rectangle)                   ;; C-x r c
    ("e" rectangle-exchange-point-and-mark) ;; C-x C-x
    ("N" rectangle-number-lines)            ;; C-x r N
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("u" undo nil)
    ("q" nil))

  (defhydra my/hydra-next-error (nil nil)
    "
  Compilation errors:
  _j_: next error        _h_: first error    _q_uit
  _k_: previous error    _l_: last error
  "
    ("`" next-error     nil)
    ("j" next-error     nil :bind nil)
    ("k" previous-error nil :bind nil)
    ("h" first-error    nil :bind nil)
    ("l" (condition-case err
             (while t
               (next-error))
           (user-error nil))
     nil :bind nil)
    ("q" nil            nil :color blue))

  (defhydra my/hydra-dired (nil nil
                             :hint nil
                             :color pink)
    "
  _+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
  _C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
  _D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
  _R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
  _Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
  _S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
  _r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
  _z_ compress-file  _A_ find regexp
  _Z_ compress       _Q_ repl regexp

  T - tag prefix
  "
    ("\\" dired-do-ispell)
    ("(" dired-hide-details-mode)
    (")" dired-omit-mode)
    ("+" dired-create-directory)
    ("=" diredp-ediff)         ;; smart diff
    ("?" dired-summary)
    ("$" diredp-hide-subdir-nomove)
    ("A" dired-do-find-regexp)
    ("C" dired-do-copy)        ;; Copy all marked files
    ("D" dired-do-delete)
    ("E" dired-mark-extension)
    ("e" dired-ediff-files)
    ("F" dired-do-find-marked-files)
    ("G" dired-do-chgrp)
    ("g" revert-buffer)        ;; read all directories again (refresh)
    ("i" dired-maybe-insert-subdir)
    ("l" dired-do-redisplay)   ;; relist the marked or singel directory
    ("M" dired-do-chmod)
    ("m" dired-mark)
    ("O" dired-display-file)
    ("o" dired-find-file-other-window)
    ("Q" dired-do-find-regexp-and-replace)
    ("R" dired-do-rename)
    ("r" dired-do-rsynch)
    ("S" dired-do-symlink)
    ("s" dired-sort-toggle-or-edit)
    ("t" dired-toggle-marks)
    ("U" dired-unmark-all-marks)
    ("u" dired-unmark)
    ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
    ("w" dired-kill-subdir)
    ("Y" dired-do-relsymlink)
    ("z" diredp-compress-this-file)
    ("Z" dired-do-compress)
    ("q" nil)
    ("." nil :color blue))
  )
#+end_src

** Highlighting

*** goggles

goggles is now used instead of volatile-highlights.

#+begin_src emacs-lisp
(use-package goggles
  :hook ((prog-mode text-mode) . goggles-mode)
  :config
  (setq-default goggles-pulse t)) ;; set to nil to disable pulsing
#+end_src

** Narrowing

#+begin_src emacs-lisp
(use-package fancy-narrow
  :disabled
  :bind (:map my/edit-map
              ("n" . my/hydra-narrow/body))
  :hook (prog-mode . fancy-narrow-mode)
  :commands (fancy-narrow-to-region
             fancy-widen
             fancy-narrow-to-page
             org-fancy-narrow-to-block
             org-fancy-narrow-to-element
             org-fancy-narrow-to-subtree)
  :config
  (defhydra my/hydra-narrow (:hint nil)
    "
  Narrow To: _r_: region _p_: page    _d_: defun
  Org: _b_: block  _e_: element _s_: subtree
       _w_: widen   _q_: quit
  "
    ("r" fancy-narrow-to-region)
    ("w" fancy-widen)
    ("p" fancy-narrow-to-page)
    ("d" fancy-narrow-to-defun)
    ("b" org-fancy-narrow-to-block)
    ("e" org-fancy-narrow-to-element)
    ("s" org-fancy-narrow-to-subtree)
    ("q" nil)))
#+end_src

** Tab bar

#+begin_src emacs-lisp
(use-package tab-bar
  :bind ( :map tab-prefix-map
          ("C-n" . tab-next)
          ("C-p" . tab-previous)
          ("k" . my/tab-bar-kill-buffer-and-tab)
          ("o" . tab-bar-switch-to-recent-tab)
          ("w" . tab-bar-move-window-to-tab)
          ("!" . tab-close-other)
          ("1" . my/tab-bar-switch-to-1)
          ("2" . my/tab-bar-switch-to-2)
          ("3" . my/tab-bar-switch-to-3)
          ("4" . my/tab-bar-switch-to-4)
          ("5" . my/tab-bar-switch-to-5)
          ("6" . my/tab-bar-switch-to-6)
          ("7" . my/tab-bar-switch-to-7)
          ("8" . my/tab-bar-switch-to-8)
          ("9" . my/tab-bar-switch-to-9))
  :config

  (defun my/tab-bar-kill-buffer-and-tab ()
    "Kill current buffer and its tab."
    (interactive)
    (kill-buffer)
    (tab-close))

  ;; Create shortcuts for switching to a specified tab.
  (dotimes (num 9 t)
    (fset (intern (format "my/tab-bar-switch-to-%d" (1+ num)))
          `(lambda () (interactive)
             (ignore-errors
               (tab-bar-select-tab ,(1+ num)))))))
#+end_src

* Completion

vertico and related packages are used for completion framework.

** Vertico

#+begin_src emacs-lisp
(use-package vertico
  :diminish vertico-mode
  :init
  (vertico-mode)
  :config
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
  ;; Vertico commands are hidden in normal buffers.
  ;; (setq read-extended-command-predicate
  ;;       #'command-completion-default-include-p)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t))

(use-package vertico-directory
  :straight (:type built-in)
  :after vertico
  :bind (:map vertico-map
              ("C-l" . vertico-directory-up)
              ("\d" . vertico-directory-delete-char)))

(use-package vertico-repeat
  :straight (:type built-in)
  :after vertico
  :bind ("C-c -" . vertico-repeat)
  :hook (minibuffer-setup . vertico-repeat-save))

(use-package vertico-multiform
  :straight (:type built-in)
  :after vertico
  :config
  (vertico-multiform-mode))

(use-package savehist
  :diminish savehist-mode
  :init
  (savehist-mode))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  ;; Replace bindings. Lazily loaded due by `use-package'.
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c r" . my/consult-recent-file)
         ("C-c R" . consult-recent-file)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c k" . consult-kmacro)
         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings (goto-map)
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flycheck)
         ("M-g F" . consult-flymake)
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ("M-s d" . consult-find)
         ("M-s D" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s i" . consult-info)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history)                 ;; orig. previous-matching-history-element
         :map tab-prefix-map
         ("r" . my/consult-recent-file-other-tab)
         )

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :commands (consult-buffer consult-xref consult--read)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Disable live preview when EXWM is enabled as it does not work well.
  (when-use-exwm
   (setq consult-preview-key "M-."))

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key (kbd "M-."))
  ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-ripgrep consult-git-grep consult-grep
   consult-recent-file
   consult--source-recent-file consult--source-project-recent-file
   :preview-key "M-.")

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; By default `consult-project-function' uses `project-root' from project.el.
  ;; Optionally configure a different project root function.
  ;; There are multiple reasonable alternatives to chose from.
  ;;;; 1. project.el (the default)
  ;; (setq consult-project-function #'consult--default-project--function)
  ;;;; 2. projectile.el (projectile-project-root)
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))
  ;;;; 3. vc.el (vc-root-dir)
  ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
  ;;;; 4. locate-dominating-file
  ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))

  (when-use-exwm
   (defun consult-exwm-preview-fix (buf-or-name &optional norecord force-same-window)
     "Kludge to stop EXWM buffers from stealing focus during Consult previews."
     (when (derived-mode-p 'exwm-mode)
       (when-let ((mini (active-minibuffer-window)))
         (select-window (active-minibuffer-window)))))

   (advice-add
    #'switch-to-buffer :after #'consult-exwm-preview-fix)
   )

  ;; Set symbol in region or at point as initial input.
  (dolist (cmd '(consult-line consult-line-multi consult-keep-lines consult-focus-lines
                              consult-grep consult-ripgrep consult-git-grep))
    (eval
     `(consult-customize
       ,cmd
       :initial (if (use-region-p)
                    (buffer-substring (region-beginning) (region-end))
                  (thing-at-point 'symbol)))))

  (defun my/consult-recent-file ()
    "Find recent file using `completing-read'."
    (interactive)
    (let* ((filename
            (consult--read
             (or
              (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
              (user-error "No recent files, `recentf-mode' is %s"
                          (if recentf-mode "enabled" "disabled")))
             :prompt "Find recent file in other window: "
             :sort nil
             :require-match t
             :category 'file
             :state (consult--file-preview)
             :history 'file-name-history))
           (value (find-file-noselect filename nil nil nil)))
      (if (listp value)
          (mapcar 'display-buffer (nreverse value))
        (let ((win (display-buffer value)))
          (when win
            (select-window win))))))

  (defun my/consult-recent-file-other-window ()
    "Find recent file using `completing-read'."
    (interactive)
    (find-file-other-window
     (consult--read
      (or
       (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
       (user-error "No recent files, `recentf-mode' is %s"
                   (if recentf-mode "enabled" "disabled")))
      :prompt "Find recent file in other window: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history)))

  (defun my/consult-recent-file-new-window ()
    "Find recent file using `completing-read'."
    (interactive)
    (my/find-file-new-window
     (consult--read
      (or
       (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
       (user-error "No recent files, `recentf-mode' is %s"
                   (if recentf-mode "enabled" "disabled")))
      :prompt "Find recent file in new window: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history)))

  (defun my/consult-recent-file-other-tab ()
    "Find recent file in other tab using `completing-read'."
    (interactive)
    (find-file-other-tab
     (consult--read
      (or
       (mapcar #'consult--fast-abbreviate-file-name (bound-and-true-p recentf-list))
       (user-error "No recent files, `recentf-mode' is %s"
                   (if recentf-mode "enabled" "disabled")))
      :prompt "Find recent file in other tab: "
      :sort nil
      :require-match t
      :category 'file
      :state (consult--file-preview)
      :history 'file-name-history)))

  (consult-customize
   my/consult-recent-file my/consult-recent-file-new-window
   my/consult-recent-file-other-window my/consult-recent-file-other-tab
   :preview-key "M-.")
  )
#+end_src

** Marginalia

#+begin_src emacs-lisp
;; Enable richer annotations using the Marginalia package
(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init configuration is always executed (Not lazy!)
  :init

  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))
#+end_src

** Embark

Disabling embark-prefix-help-command for now as I prefer which-key's compact layout.

#+begin_src emacs-lisp
(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  ;; (setq prefix-help-command #'embark-prefix-help-command)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))

  ;; TODO: uncomment if I get used to use this package.
  ;; (setq embark-indicators
  ;;       '(embark-minimal-indicator  ; default is embark-mixed-indicator
  ;;         embark-highlight-indicator
  ;;         embark-isearch-highlight-indicator))

  ;; TODO: uncomment in case I want to replace which-key with this package.
  ;; (vertico-multiform-mode)
  ;; (add-to-list 'vertico-multiform-categories '(embark-keybinding grid))
  )

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Orderless

#+begin_src emacs-lisp
(use-package orderless
  :config
  ;; https://github.com/oantolin/orderless?tab=readme-ov-file#defining-custom-orderless-styles
  (orderless-define-completion-style orderless+initialism
    (orderless-matching-styles '(orderless-initialism
                                 orderless-prefixes
                                 ;; orderless-literal
                                 ;; orderless-regexp
                                 )))

  (with-eval-after-load 'company
    ;; Enable highlighting of candidates.
    ;; https://github.com/oantolin/orderless?tab=readme-ov-file#company
    (defun just-one-face (fn &rest args)
      (let ((orderless-match-faces [completions-common-part]))
        (apply fn args)))
    (advice-add 'company-capf--candidates :around #'just-one-face)
    ;; Use literal matching for in-buffer completion with Company.
    (defun company-completion-styles (capf-fn &rest args)
      (let ((completion-styles '(basic partial-completion)))
        (apply capf-fn args)))
    (advice-add 'company-capf :around #'company-completion-styles)
    )

  :custom
  (orderless-matching-styles '(orderless-prefixes orderless-flex))
  (completion-styles '(orderless basic))
  (completion-category-overrides
   '((file (styles basic partial-completion))
     (command (styles orderless+initialism)))))
#+end_src

** Cape

#+begin_src emacs-lisp
(use-package cape
  :custom
  (dabbrev-case-fold-search t)
  (dabbrev-case-replace nil)

  ;; Bind dedicated completion commands
  ;; Alternative prefix keys: C-c p, M-p, M-+, ...
  :bind (("C-c p p" . completion-at-point) ;; capf
         ("C-c p t" . complete-tag)        ;; etags
         ("C-c p d" . cape-dabbrev)        ;; or dabbrev-completion
         ("C-c p h" . cape-history)
         ("C-c p f" . cape-file)
         ("C-c p k" . cape-keyword)
         ("C-c p s" . cape-elisp-symbol)
         ("C-c p e" . cape-elisp-block)
         ("C-c p a" . cape-abbrev)
         ("C-c p l" . cape-line)
         ("C-c p w" . cape-dict)
         ("C-c p :" . cape-emoji)
         ("C-c p \\" . cape-tex)
         ("C-c p _" . cape-tex)
         ("C-c p ^" . cape-tex)
         ("C-c p &" . cape-sgml)
         ("C-c p r" . cape-rfc1345))
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-emoji)
  ;; (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
  )
#+end_src

** Corfu

Corfu is used for in-buffer/minibuffer completion.

#+begin_src emacs-lisp
(use-package corfu
  :straight (corfu :files (:defaults "extensions/*"))
  :custom
  (corfu-cycle t)
  ;; (completion-cycle-threshold 1)
  (tab-always-indent 'complete)
  (corfu-preselect 'prompt)
  :bind (("C-q <tab>" . completion-at-point)
         ("C-q TAB" . completion-at-point)
         :map corfu-map
         ("C-f" . corfu-expand)
         ("C-i" . corfu-next)
         ("C-l" . my/corfu-backward-word)
         ("<tab>" . my/corfu-next-or-expand)
         ([tab] . my/corfu-next-or-expand)
         ("<backtab>" . corfu-previous)
         ([backtab] . corfu-previous))
  :init
  (global-corfu-mode)

  :config
  ;; Emacs 28 and newer: Hide commands in M-x which do not apply to the current
  ;; mode.  Corfu commands are hidden, since they are not used via M-x. This
  ;; setting is useful beyond Corfu.
  (setq read-extended-command-predicate #'command-completion-default-include-p)

  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer."
    (when (local-variable-p 'completion-at-point-functions)
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)

  ;; Comment out as this dose not seem to work as expected.
  ;; (add-to-list 'completion-styles-alist
  ;;              '(tab completion-basic-try-completion ignore
  ;;                    "Completion style which provides TAB completion only."))
  ;; (setq completion-styles '(tab orderless basic))


  (defun my/corfu-next-or-expand (&optional n)
    "Do corfu-expand when only one candidate exists otherwise move to next candidate."
    (interactive "p")
    (if (= corfu--total 1)
        (corfu-expand)
      (corfu-next n)))
  (add-to-list 'corfu-continue-commands 'my/corfu-next-or-expand)

  (defun my/corfu-backward-word (&optional n)
    "Delete the word prior to the point."
    (interactive "p")
    (dotimes (i (or n 1))
      (let ((end (point)))
        (backward-word)
        (delete-region (point) end))))
  (add-to-list 'corfu-continue-commands 'my/corfu-backward-word)
  )
#+end_src

Dabbrev settings copied from the GitHub Corfu page.

#+begin_src emacs-lisp
;; Use Dabbrev with Corfu
(use-package dabbrev
  ;; ;; Swap M-/ and C-M-/
  ;; :bind (("M-/" . dabbrev-completion)
  ;;        ("C-M-/" . dabbrev-expand))
  :config
  (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
  ;; Since 29.1, use `dabbrev-ignored-buffer-regexps' on older.
  (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
  (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
#+end_src

*** corfu-terminal

#+begin_src emacs-lisp
(use-package corfu-terminal
 :straight
 (corfu-terminal
  :type git
  :repo "https://codeberg.org/akib/emacs-corfu-terminal.git")
 :config
 (defun my/start-corfu-terminal-mode ()
   (unless (display-graphic-p)
     (corfu-terminal-mode +1)))

 (add-hook 'server-after-make-frame-hook #'my/start-corfu-terminal-mode)
 (my/start-corfu-terminal-mode)
 )
#+end_src

*** corfu-doc-terminal

#+begin_src emacs-lisp
(use-package corfu-doc-terminal
 :straight (corfu-doc-terminal
            :type git
            :repo "https://codeberg.org/akib/emacs-corfu-doc-terminal.git")
 :config
 (defun start-corfu-doc-terminal-mode ()
   (unless (display-graphic-p)
     (corfu-doc-terminal-mode +1)))

 (add-hook 'server-after-make-frame-hook #'start-corfu-doc-terminal-mode)
 (start-corfu-doc-terminal-mode)
 )
#+end_src

*** corfu-popupinfo

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :straight nil
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :config

  ;; Scroll up/down by half frame-height by default.
  (defun my/corfu-popupinfo-scroll-wrapper (orig-fn &optional n)
    (interactive "P")
    (let ((half-frame-height (with-selected-frame
                                 corfu-popupinfo--frame
                               (/ (window-height
                                   (get-buffer-window " *corfu-popupinfo*")) 2))))
      (funcall orig-fn (or n half-frame-height))))

  (advice-add #'corfu-popupinfo-scroll-up
              :around #'my/corfu-popupinfo-scroll-wrapper)
  (advice-add #'corfu-popupinfo-scroll-down
              :around #'my/corfu-popupinfo-scroll-wrapper)
  )
#+end_src

*** nerd-icons-corfu

#+begin_src emacs-lisp
(use-package nerd-icons-corfu
 :config
 (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

*** corfu-candidate-overlay

#+begin_src emacs-lisp
(use-package corfu-candidate-overlay
  :straight (:type git
                   :repo "https://code.bsdgeek.org/adam/corfu-candidate-overlay"
                   :files (:defaults "*.el"))
  :after corfu
  :bind ("C-c p o" . corfu-candidate-overlay-mode)  ;; toggle overlay mode.
  :config
  (set-face-attribute 'corfu-candidate-overlay-face nil
                      :foreground "wheat2")
  ;; Hack to enable corfu-candidate-overlay-mode in certain modes only.
  ;; (defun my/corfu-candidate-overlay-mode (&optional win-or-frame)
  ;;   (let* ((b (current-buffer))
  ;;          (w (get-buffer-window b))
  ;;          (enabled-mode-list '(prog-mode)))
  ;;     ;; (message "arg:%s, buf:%s, win:%s, livep:%s" win-or-frame b w (window-live-p w))
  ;;     (when (and
  ;;            (window-live-p w)
  ;;            (not (or
  ;;                  (window-minibuffer-p w)
  ;;                  (minibufferp b))))
  ;;       (if (apply #'derived-mode-p enabled-mode-list)
  ;;           (progn
  ;;             ;; (message "enabling corfu...")
  ;;             (unless (member 'corfu-candidate-overlay--post-command post-command-hook)
  ;;               (add-hook 'post-command-hook #'corfu-candidate-overlay--post-command)
  ;;               (add-hook 'pre-command-hook  #'corfu-candidate-overlay--pre-command)))
  ;;         (progn
  ;;           ;; (message "disabling corfu...")
  ;;           (when (member 'corfu-candidate-overlay--post-command post-command-hook)
  ;;             (remove-hook 'post-command-hook #'corfu-candidate-overlay--post-command)
  ;;             (remove-hook 'pre-command-hook  #'corfu-candidate-overlay--pre-command)))
  ;;         ))))
  ;; (add-to-list 'window-state-change-functions 'my/corfu-candidate-overlay-mode)

  ;; enable corfu-candidate-overlay mode globally
  ;; this relies on having corfu-auto set to nil
  ;; ;; bind Ctrl + TAB to trigger the completion popup of corfu
  ;; (global-set-key (kbd "C-<tab>") 'completion-at-point)
  ;; ;; bind Ctrl + Shift + Tab to trigger completion of the first candidate
  ;; ;; (keybing <iso-lefttab> may not work for your keyboard model)
  ;; (global-set-key (kbd "C-<iso-lefttab>") 'corfu-candidate-overlay-complete-at-point)
  )
#+end_src

** nerd-icons-completion

#+begin_src emacs-lisp
(use-package nerd-icons-completion
  :after marginalia
  :config
  (nerd-icons-completion-mode)
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

* Edit modes

** YAML

#+begin_src emacs-lisp
(use-package yaml-mode
  :mode ("\\.yaml\\'" . yaml-mode)
  :config
  (add-hook 'yaml-mode-hook
            #'(lambda ()
                (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
  (setq lsp-yaml-schemas '((Kubernetes . "*k8s*/*.yaml"))))
#+end_src

** Markdown

#+begin_src emacs-lisp
;; gfm-preview is a 1-line script containing "grip --export $1 -"
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init
  (let ((cmd (expand-file-name "~/bin/gfm-preview")))
    (when (file-exists-p cmd) (setq markdown-command cmd)))
  )
#+end_src

** UML

#+begin_src emacs-lisp
(use-package plantuml-mode
  :mode (("\\.uml\\'" . plantuml-mode))
  :custom
  (plantuml-jar-path "~/Downloads/plantuml.jar")
  :config
  (with-eval-after-load 'org
    (setq org-plantuml-jar-path "~/Downloads/plantuml.jar")
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (require 'ob-plantuml)))
#+end_src

** Graphviz Dot

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :mode (("\\.dot\\'" . graphviz-dot-mode)))
#+end_src

** More generic modes

#+begin_src emacs-lisp
(require 'generic-x)
#+end_src

* Misc editing enhancements

** Tramp

*** consult-tramp

#+begin_src emacs-lisp
(use-package consult-tramp
  :straight (consult-tramp
             :type git
             :host github
             :repo "Ladicle/consult-tramp")
  :bind ("C-q t" . consult-tramp))
#+end_src

** Multiple Cursors

*** multiple-cursors

Being disabled for now in favor of macursors.

#+begin_src emacs-lisp
(use-package multiple-cursors
  :disabled
  :diminish
  :bind (:map my/edit-map
              ("a" . mc/mark-all-dwim)
              ("e" . mc/edit-lines)
              ("r" . mc/mark-in-region-regexp))
  :commands (mc/mark-all-dwim mc/edit-lines))
#+end_src

*** macrursors

Trying this out as multiple-cursors is heavy.

#+begin_src emacs-lisp
(use-package macrursors
  :after (corfu goggles)
  :straight ( :type git :host github :repo "corytertel/macrursors")
  :custom (macrursors-apply-keys "RET")
  :bind ( :map my/edit-map
          ("SPC" . my/macrursors-mark-all-at-point)
          ("RET" . macrursors-end)
          ("C-g" . macrursors-select-clear)
          ("C-SPC" . macrursors-select)
          ("m" . macrursors-mark-all-lines-or-instances)
          ("C-n" . macrursors-mark-next-instance-of)
          ("C-p" . macrursors-mark-previous-instance-of))
  :config
  (dolist (mode '(corfu-mode goggles-mode))
    (add-hook 'macrursors-pre-finish-hook mode)
    (add-hook 'macrursors-post-finish-hook mode))
  (defun my/macrursors-mark-all-at-point ()
    "Mark all instances of the thing at point."
    (interactive)
    (let ((symbol (thing-at-point 'symbol)))
      (macrursors--mark-all-instances-of symbol (point)))))
#+end_src

** Wgrep

You can edit the text in the grep buffer after typing C-c C-p. Document on the
usage is [[https://github.com/mhayashi1120/Emacs-wgrep#usage][here]].

#+begin_src emacs-lisp
(use-package wgrep :diminish)
(use-package wgrep-ag :diminish)
#+end_src

** Vundo

#+begin_src emacs-lisp
(use-package vundo
  :bind (("C-_" . vundo)
         :map my/edit-map
         ("u" . vundo))
  :config
  (setq vundo-glyph-alist vundo-unicode-symbols)
  )
#+end_src

** ws-butler

Trim spaces from EOL. Only lines touched get trimmed.

#+begin_src emacs-lisp
(use-package ws-butler
  :diminish ws-butler-mode
  :hook (prog-mode . ws-butler-mode))
#+end_src

** yasnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1)

  ;; Define my own snippets here.
  (yas-define-snippets
   'fundamental-mode
   '(("@time" "`(format-time-string \"%H:%M:%S\")`" "current time")
     ("@today" "`(format-time-string \"%Y-%m-%d\")`" "today")
     ("@tomorrow" "`(format-time-string \"%Y-%m-%d\" (time-add (current-time) (* 24 3600)))`" "tomorrow")
     ("@yesterday" "`(format-time-string \"%Y-%m-%d\" (time-subtract (current-time) (* 24 3600)))`" "yesterday")
     ))

  (yas-define-snippets
   'org-mode
   '(("<el" "#+begin_src emacs-lisp\n$0\n#+end_src" "simple emacs-lisp block")
     ))
  )

(use-package yasnippet-snippets)
#+end_src

** Projectile

#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :bind-keymap
  ("C-c P" . projectile-command-map)
  :hook ((prog-mode . projectile-mode)
         (comint-mode . (lambda () (projectile-mode -1))))
  :custom
  (projectile-mode-line '(:eval (format " [%s]" (projectile-project-name)))))
#+end_src

** audo-sudoedit

#+begin_src emacs-lisp
(use-package auto-sudoedit
  :diminish
  :custom
  (auto-sudoedit-ask t)
  :config
  (auto-sudoedit-mode 1))
#+end_src

** spellcheck

jit-spell is being tried out as jinx does not handle English words right before/after Japanese character.

*** ispell
The configuration below is borrowed from https://home.hirosaki-u.ac.jp/heroic-2020/1575/.
Do not forget to install aspell.

#+begin_src emacs-lisp
(use-package ispell
  :commands (ispell ispell-region)
  :custom
  (ispell-program-name "aspell")
  (ispell-local-dictionary "en_US")
  :config
  (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+")))
#+end_src

*** jinx
#+begin_src emacs-lisp
(use-package jinx
  :disabled
  :diminish
  :bind (("M-$" . jinx-correct)
         ("C-M-$" . jinx-languages))
  :hook (((text-mode conf-mode markdown-mode) . jinx-mode))
  :config
  ;; (add-to-list 'jinx-exclude-regexps '(t "[^\000-\377]+"))
  (setq jinx-exclude-regexps
        '((emacs-lisp-mode "Package-Requires:.*$")
          (t "[A-Z]+\\>"         ;; Uppercase words
             "-+\\>"             ;; Hyphens used as lines or bullet points
             "\\w*?[0-9]\\w*\\>" ;; Words with numbers, hex codes
             "[a-z]+://\\S-+"    ;; URI
             "[^\000-\377]+"     ;; Non-Ascii characters
             "<?[-+_.~a-zA-Z][-+_.~:a-zA-Z0-9]*@[-.a-zA-Z0-9]+>?" ;; Email
             "\\(?:Local Variables\\|End\\):\\s-*$" ;; Local variable indicator
             "jinx-\\(?:languages\\|local-words\\):\\s-+.*$"))) ;; Local variables
  (add-to-list 'vertico-multiform-categories
               '(jinx grid (vertico-grid-annotate . 20)))
  (vertico-multiform-mode 1))
#+end_src

*** jit-spell

Note that jit-spell only works well with aspell as aspell wisely ignores Japanese characters while hunspell tries to correct Japanese characters.

#+begin_src emacs-lisp
(use-package jit-spell
  :hook ((text-mode conf-mode markdown-mode) . jit-spell-mode)
  :config
  (set-face-underline 'jit-spell-misspelling '(:style wave :color "#d2b580")))
#+end_src

** File Template

#+begin_src emacs-lisp
(when (locate-library "file-template")
  (use-package file-template
    :custom
    (file-template-insert-automatically t)
    (file-template-paths '(".templates" "~/lib/elisp/templates/"))
    (file-template-mapping-alist
     '(;; ("\\.org$" . "template.org")
       ("\\.mqh$" . "template.mqh")
       ("\\.mq5$" . "template.mq5")))
    :config
    (add-hook 'find-file-not-found-functions #'file-template-find-file-not-found-hook)))
#+end_src

** Adaptive Wrap

Correct indentation on bullet lists in Markdown mode.

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :disabled
  :hook (visual-line-mode . adaptive-wrap-prefix-mode))
#+end_src

* Misc utilities and enhancements
** Dired

Mostly borrowed from https://taipapamotohus.com/post/dired/.

*** Dired+

#+begin_src emacs-lisp
(use-package dired+
  :after dired
  :straight
  (dired+ :fetcher github :repo "emacsmirror/dired-plus")
  :init
  (setq diredp-hide-details-initially-flag nil)
  (setq diredp-hide-details-propagate-flag nil)
  :config
  (diredp-toggle-find-file-reuse-dir 1)
  )
#+end_src

*** Dired quick sort

#+begin_src emacs-lisp
(use-package dired-quick-sort
  :after dired
  :config
  (dired-quick-sort-setup))
#+end_src

*** nerd-icons-dired

#+begin_src emacs-lisp
(use-package nerd-icons-dired
  :diminish
  :after dired
  :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

*** Dired hacks

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("I" . dired-insert-subdir)
              ("i" . dired-subtree-insert)
              (";" . dired-subtree-remove)))

(use-package dired-filter
  :after dired
  :hook (dired-mode . dired-filter-mode)
  :bind ( :map dired-mode-map
          ("/" . dired-filter-map)
          :map dired-filter-map
          ("M" . dired-filter-mark-map)))

(use-package dired-collapse
  :after dired
  :hook (dired-mode . dired-collapse-mode))

(use-package dired-open
  :after dired
  :bind (:map dired-mode-map
              ("V" . dired-open-xdg)))
#+end_src

*** Custom functions

#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :bind (("C-c d" . my/consult-dired-recent))
  :config
  (defun my/consult-dired-recent ()
    (interactive)
    (dired (consult--read
            (or
             (delete-dups (mapcar #'file-name-directory (bound-and-true-p recentf-list)))
             (user-error "No recent files, `recentf-mode' is %s"
                         (if recentf-mode "enabled" "disabled")))
            :prompt "Dired with recent dir: "
            :sort nil
            :require-match t
            :category 'file
            :state (consult--file-preview)
            :history 'file-name-history))))
#+end_src

** Async

#+begin_src emacs-lisp
(use-package async
  :config
  (dired-async-mode 1)
  (async-bytecomp-package-mode 1))
#+end_src

** SHR
*** shr-tag-pre-highlight

#+begin_src emacs-lisp
(use-package shr-tag-pre-highlight
  :after shr
  :config
  (add-to-list 'shr-external-rendering-functions
               '(pre . shr-tag-pre-highlight))
  (when (version< emacs-version "26")
    (with-eval-after-load 'eww
      (advice-add 'eww-display-html :around
                  'eww-display-html--override-shr-external-rendering-functions))))
#+end_src
** Japanese Holidays

#+begin_src emacs-lisp
(use-package japanese-holidays
  :after calendar
  :config
  (setq calendar-holidays
        (append japanese-holidays holiday-local-holidays holiday-other-holidays))
  (setq calendar-mark-holidays-flag t)
  (setq japanese-holiday-weekend '(0 6)
        japanese-holiday-weekend-marker
        '(holiday nil nil nil nil nil japanese-holiday-saturday))
  (add-hook 'calendar-today-visible-hook 'japanese-holiday-mark-weekend)
  (add-hook 'calendar-today-invisible-hook 'japanese-holiday-mark-weekend)

  (defun my/japanese-holiday-show (&rest _args)
    (let* ((date (calendar-cursor-to-date t))
           (calendar-date-display-form '((format "%s %s %s%s" year month day dayname)))
           (date-string (calendar-date-string date))
           (holiday-list (calendar-check-holidays date)))
      (when holiday-list
        (message "%s: %s" date-string (mapconcat #'identity holiday-list "; ")))))
  (add-hook 'calendar-move-hook 'my/japanese-holiday-show))
#+end_src
** Valign

Align tables with variable pitch fonts.

#+begin_src emacs-lisp
(use-package valign
  :diminish
  :hook ((org-mode markdown-mode) . valign-mode))
#+end_src

* Window and workspace management

** Persp-mode

Use Persp-mode to isolate buffers based on workspace or project.

Unfortunately disabled this as I found frame handling in this package conflicts
with EXWM. For example, this package manipulates frame params on dialog windows
(e.g. open file dialog on Chrome).

#+begin_src emacs-lisp
(use-package-if-not-exwm
 persp-mode
 :disabled
 :bind (("C-x b" . my/persp-switch-to-buffer)
        ("C-x C-b" . my/persp-list-buffers)
        ("C-x k" . persp-kill-buffer)
        (:map persp-key-map
              ("N" . my/persp-new)
              ("o" . my/persp-switch-to-last-persp)))
 :custom
 (persp-keymap-prefix (kbd "C-z"))
 (persp-auto-save-opt 0)
 (persp-auto-resume-time -1)
 (persp-add-buffer-on-after-change-major-mode t)
 (persp-autokill-buffer-on-remove 'kill-weak)
 (persp-buffer-list-restricted-filter-functions
  persp-common-buffer-filter-functions)
 :init
 (persp-mode)
 :config
 (set-face-attribute 'persp-face-lighter-buffer-not-in-persp nil
                     :foreground "yellow3"
                     :background 'unspecified)

 ;; Quoted from https://gist.github.com/Bad-ptr/1aca1ec54c3bdb2ee80996eb2b68ad2d#file-persp-mru-el

 (add-hook 'persp-before-switch-functions
           #'(lambda (new-persp-name w-or-f)
               (let ((cur-persp-name (safe-persp-name (get-current-persp))))
                 (when (member cur-persp-name persp-names-cache)
                   (setq persp-names-cache
                         (cons cur-persp-name
                               (delete cur-persp-name persp-names-cache)))))))

 (add-hook 'persp-renamed-functions
           #'(lambda (persp old-name new-name)
               (setq persp-names-cache
                     (cons new-name (delete old-name persp-names-cache)))))

 (add-hook 'persp-before-kill-functions
           #'(lambda (persp)
               (setq persp-names-cache
                     (delete (safe-persp-name persp) persp-names-cache))))

 (add-hook 'persp-created-functions
           #'(lambda (persp phash)
               (when (and (eq phash *persp-hash*)
                          (not (member (safe-persp-name persp)
                                       persp-names-cache)))
                 (setq persp-names-cache
                       (cons (safe-persp-name persp) persp-names-cache)))))

 ;; Switch to last perspective.
 (defun my/persp-switch-to-last-persp ()
   (interactive)
   (persp-frame-switch (car persp-names-cache)))

 (defun my/persp-switch-to-buffer (arg)
   (interactive "p")
   (call-interactively
      (if (= arg 4)
          'switch-to-buffer
        'persp-switch-to-buffer)))

 (defun my/persp-list-buffers (arg)
   (interactive "p")
   (if (= arg 4)
       (list-buffers)
     (with-persp-buffer-list () (list-buffers))))

 (defun my/persp-new (name)
  "Create a new persp"
  (interactive "spersp name: ")
  (persp-add-new name)
  (persp-switch name)
  (let ((scratch-buffer (get-scratch-buffer-create)))
    (persp-add-buffer scratch-buffer)
    (switch-to-buffer scratch-buffer)))
 )
#+end_src

** Dedicated window

Pin a window so that find-file or other operations won't steal the window.

#+begin_src emacs-lisp
;; Pin a window.
(defun my/toggle-window-dedicated ()
  "Toggle whether the current active window is dedicated or not"
  (interactive)
  (message
   (if (let (window (get-buffer-window (current-buffer)))
         (set-window-dedicated-p window
                                 (not (window-dedicated-p window))))
       "Window '%s' is dedicated"
     "Window '%s' is normal")
   (current-buffer)))

(define-key my/wm-map "d" #'my/toggle-window-dedicated)
#+end_src

** Move to last buffer

#+begin_src emacs-lisp
(defun my/switch-to-last-buffer ()
  "Switch to last buffer."
  (interactive)
  (let* ((b (other-buffer (current-buffer) 1))
         (w (get-buffer-window b)))
    (if w (select-window w)
      (switch-to-buffer b))))
(global-set-key (kbd "M-o") #'my/switch-to-last-buffer)
#+end_src

** Find file or buffer in new window

#+begin_src emacs-lisp
(defun my/switch-to-buffer-new-window (buffer-or-name &optional norecord)
  (interactive
   (list (read-buffer-to-switch "Switch to buffer in new window: ")))
  (split-window-right)
  (windmove-right)
  (switch-to-buffer buffer-or-name norecord))
(global-set-key (kbd "C-c b") #'my/switch-to-buffer-new-window)

(defun my/find-file-new-window (filename &optional wildcards)
  "Find file in a new window."
  (interactive
   (find-file-read-args "Find file in new window: "
                        (confirm-nonexistent-file-or-buffer)))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
	      (progn
	        (setq value (nreverse value))
	        (my/switch-to-buffer-new-window (car value))
	        (mapc 'switch-to-buffer (cdr value))
	        value)
      (my/switch-to-buffer-new-window value))))

;; (global-set-key (kbd "C-c f") #'my/find-file-new-window)
(global-set-key (kbd "C-c f") #'find-file-other-window)
#+end_src

** Select another window in the reverse cyclic order

#+begin_src emacs-lisp
(defun my/other-window-reverse ()
  "Select another window in the reverse cyclic order."
  (interactive)
  (other-window -1))

(global-set-key (kbd "C-x O") #'my/other-window-reverse)
#+end_src

** Tree view

TBH I don't use this often.

*** treemacs

#+begin_src emacs-lisp
(use-package treemacs
  :bind (:map my/wm-map
              ("T" . treemacs)))
#+end_src

** Ace jump

This is potentially very useful for quickly jumping to a position in the buffer
by selecting a character assigned to each position.

#+begin_src emacs-lisp
;; ace-jump-mode
(use-package ace-jump-mode
  :bind (("C-c C-SPC" . ace-jump-char-mode)
         :map my/wm-map
         ("j" . ace-jump-char-mode))
  :config
  (setq ace-jump-mode-scope 'window))
#+end_src

** Ace window

This is a must-have package for window management. For historical reasons, I
assign "~C-c <num>~" to directly select the window for the assigned number.  ~C-c w
<num>~ is useful to show the buffer in the current window to the selected
window. ~C-c W <num>~ is for swapping the buffers between the current window and
the selected window. ~aw-flip-window~ is also useful to go back and forth between
the two windows.

#+begin_src emacs-lisp
;; ace-window
(use-package ace-window
  :init
  :bind (("C-c 1" . aw-switch-to-window-1)
         ("C-c 2" . aw-switch-to-window-2)
         ("C-c 3" . aw-switch-to-window-3)
         ("C-c 4" . aw-switch-to-window-4)
         ("C-c 5" . aw-switch-to-window-5)
         ("C-c 6" . aw-switch-to-window-6)
         ("C-c 7" . aw-switch-to-window-7)
         ("C-c 8" . aw-switch-to-window-8)
         ("C-c 9" . aw-switch-to-window-9)
         :map my/wm-map
         ("o" . aw-flip-window)
         ("1" . aw-move-window-to-1)
         ("2" . aw-move-window-to-2)
         ("3" . aw-move-window-to-3)
         ("4" . aw-move-window-to-4)
         ("5" . aw-move-window-to-5)
         ("6" . aw-move-window-to-6)
         ("7" . aw-move-window-to-7)
         ("8" . aw-move-window-to-8)
         ("9" . aw-move-window-to-9)
         ("s 1" . aw-swap-window-to-1)
         ("s 2" . aw-swap-window-to-2)
         ("s 3" . aw-swap-window-to-3)
         ("s 4" . aw-swap-window-to-4)
         ("s 5" . aw-swap-window-to-5)
         ("s 6" . aw-swap-window-to-6)
         ("s 7" . aw-swap-window-to-7)
         ("s 8" . aw-swap-window-to-8)
         ("s 9" . aw-swap-window-to-9))
  :config
  ;; generate aw-switch-to-window-N
  (require 'cl)
  (dotimes (num 9 t)
    (fset (intern (format "aw-switch-to-window-%d" (1+ num)))
          (lexical-let ((n num))
            (lambda () (interactive)
              (ignore-errors
                (aw-switch-to-window (nth n (aw-window-list)))))))
    (fset (intern (format "aw-move-window-to-%d" (1+ num)))
          (lexical-let ((n num))
            (lambda () (interactive)
              (ignore-errors
                (aw-move-window (nth n (aw-window-list)))))))
    (fset (intern (format "aw-swap-window-to-%d" (1+ num)))
          (lexical-let ((n num))
            (lambda () (interactive)
              (ignore-errors
                (aw-swap-window (nth n (aw-window-list))))))))

  (setq aw-background nil)
  (setq aw-scope 'frame)
  (ace-window-display-mode))
#+end_src

** Transpose frame

#+begin_src emacs-lisp
;; transpose-frame
(use-package transpose-frame
  :bind (:map my/wm-map
              ("t" . my/hydra-transpose-frame/body))
  :config
  (defhydra my/hydra-transpose-frame (:hint nil)
    "
  Frame
  Transpose: _x_: transpose  _v_: flip      _h_: flop
     Rotate: _r_: rotate 180 _j_: clockwise _k_: anticlockwise
  "
    ("x" transpose-frame)
    ("v" flip-frame)
    ("h" flop-frame)
    ("r" rotate-frame)
    ("j" rotate-frame-clockwise)
    ("k" rotate-frame-anticlockwise)
    ("q" nil)))
#+end_src

** Custom display buffer alist

#+begin_src emacs-lisp
(setq fit-window-to-buffer-horizontally t)
(setq window-resize-pixelwise t)
(setq window-combination-resize t)
(setq split-width-threshold 80)

(defvar my/dba-min-windows 3)
(defvar my/split-window-horizontally-min-width 72)
(defun my/display-buffer-fallback-action (buf alist)
  "Return a window to display buffer BUF.  ALIST is not used.

If the nunber of windows in the frame is less than
my/dba-min-windows, create a new window holizontally.  Otherwise,
return the same window."
  (let* ((num-windows (count-windows))
         (min-frame-width
          (* (+ num-windows 1)
                     my/split-window-horizontally-min-width))
         (win (get-buffer-window buf))
         (split-width-threshold
          (if (>= (frame-width) min-frame-width) 0 nil))
        (split-height-threshold
         (if (< (frame-width) min-frame-width) 0 nil)))
    (cond
     (win win)
     ((or (< num-windows my/dba-min-windows))
      (display-buffer--maybe-pop-up-frame-or-window buf alist))
     ((not (buffer-file-name buf))
      (display-buffer-use-some-window buf alist))
     (t (or
         (display-buffer-in-previous-window buf alist)
         (display-buffer-same-window buf alist)
         (display-buffer-reuse-mode-window buf alist))))))

(setq display-buffer-fallback-action
      '((display-buffer--maybe-same-window
         display-buffer-reuse-window
         my/display-buffer-fallback-action
         display-buffer-use-some-window
         display-buffer-pop-up-frame)))

(defvar my/side-window-height .3)

(add-to-list 'display-buffer-alist
             `(,(rx bos "*"
                    (or "Completion" "compilation" "Buffer List" (regexp "build.*") "xref")
                    (* not-newline) "*" eos)
               (lambda (buf alist)
                 (let ((win (get-buffer-window buf)))
                   (if win win
                     (display-buffer-in-side-window buf alist))))
               (side . bottom) (slot . 1) (preserve-size . (nil . t))
               ;; (window-parameters . ((no-other-window . t) (no-delete-other-windows . t)))
               (window-height . ,my/side-window-height)))

;; (defun my/display-buffer-in-bottom-window (bufname slot)
;;   "Display buffer with name BUFNAME in a window with slot SLOT at the bottom."
;;   (display-buffer-in-side-window (get-buffer-create bufname)
;;                                  `((side . bottom) (slot . ,slot))))

;; (global-set-key (kbd "C-c w l")
;;                 (lambda (bufname)
;;                   (interactive "B")
;;                   (my/display-buffer-in-bottom-window bufname -1)))
;; (global-set-key (kbd "C-c w c")
;;                 (lambda (bufname)
;;                   (interactive "B")
;;                   (my/display-buffer-in-bottom-window bufname 0)))
;; (global-set-key (kbd "C-c w r")
;;                 (lambda (bufname)
;;                   (interactive "B")
;;                   (my/display-buffer-in-bottom-window bufname 1)))
#+end_src

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :bind ("C-c O" . olivetti-mode)
  :custom
  (olivetti-body-width 128))
#+end_src

* Shell modes

** Custom window/buffer management for shell-ish modes

#+begin_src emacs-lisp
(defun my/shellish-buffer-p (buf &optional filter)
  "Return if BUF is a shell-ish buffer."
  (let ((mode (with-current-buffer buf major-mode))
        (shell-pattern (if filter filter
                         (rx (or "term" "shell" "eshell" "vterm" "eat")))))
    (and (string-match-p
          (concat "\\`\\*" shell-pattern ".*\\*\\'")
          (buffer-name buf))
         (seq-contains '(shell-mode eshell-mode term-mode vterm-mode eat-mode) mode))))

(defun my/get-shellish-buffers ()
  "Return a lit of shellish buffers or nil if none."
  (mapcar
   #'buffer-name
   (cl-remove-if-not 'my/shellish-buffer-p (buffer-list))))

(defvar my/display-shellish-buffer-list #'ignore
  "Custom function used to display shellish buffer list.")

(defvar my/consult-source-shellish-buffer
  `(:name "Shellish"
          :hidden t
          :narrow ?s
          :category buffer
          :face consult-buffer
          :history  buffer-name-history
          :state ,#'consult--buffer-state
          :items
          ,(lambda () (consult--buffer-query :sort 'visibility
                                             :as #'buffer-name
                                             :predicate
                                             #'my/shellish-buffer-p
                                             ))))

(defun my/consult-shellish-buffers ()
  (interactive)
  (consult-buffer (list
                   `(:hidden nil :narrow ?s ,@my/consult-source-shellish-buffer))))

(setq my/display-shellish-buffer-list #'my/consult-shellish-buffers)

(defun my/find-last-shellish-buffer (buflist shell-str)
  "Return most recently used shell-ish buffer containing SHELL-STR in BUFLIST."
  (when buflist
    (if (my/shellish-buffer-p (car buflist) shell-str)
        (car buflist) (my/find-last-shellish-buffer (cdr buflist) shell-str))))

(defvar my/last-non-shellish-buffer nil)

(defvar my/shellish-tab-name "*shell tab*")

(defun my/remember-last-non-shellish-buffer ()
  "Remember last non-shellish buffer."
  (let ((buf (current-buffer)))
    (unless (my/shellish-buffer-p buf)
      (setq my/last-non-shellish-buffer buf))))

(defun my/get-display-buffer-action-for-shellish ()
  "Return display-buffer's ACTION parameter applied to shellish buffers."
  `(display-buffer-in-tab . ((tab-name . ,my/shellish-tab-name))))

(defun my/get-shellish (arg shellfunc shell-str)
  "Switch to the shell-ish buffer last used or create new without prefix (ARG).
  - Close the window if the current buffer is already a shell-ish buffer of
    the same type.
  - With single prefix, show buffers list.
  - With double prefixes, unconditionally create new one by calling SHELLFUNC."
  (interactive "p")
  (let ((b (my/find-last-shellish-buffer (buffer-list (selected-frame))
                                         shell-str))
        (display-buffer-overriding-action (my/get-display-buffer-action-for-shellish)))
    (cond ((or (not b) (= arg 16))
           (my/remember-last-non-shellish-buffer)
           (call-interactively shellfunc))
          ;; ((and (= arg 64) b)
          ;;  (select-window (display-buffer my/last-non-shellish-buffer)))
          ((= arg 4)
           (when b
             (select-window (display-buffer b)))
           (call-interactively my/display-shellish-buffer-list))
          ((string= (alist-get 'name (tab-bar-get-buffer-tab (current-buffer)))
                    my/shellish-tab-name)
           (if (my/shellish-buffer-p (current-buffer) shell-str)
               (tab-bar-switch-to-recent-tab)
             (select-window (display-buffer b))))
          ((my/shellish-buffer-p (current-buffer) shell-str)
           (delete-window (get-buffer-window (current-buffer))))
          (b
           (my/remember-last-non-shellish-buffer)
           (select-window (display-buffer b))))))

(defun my/newshell ()
  "Create a new shell with specified buffer name."
  (interactive)
  (if (my/find-last-shellish-buffer (buffer-list (selected-frame)) "shell")
      (shell (format "*shell<%s>*" (read-string "Shell buffer name: ")))
    (shell)))

(defun my/get-shell (arg)
  (interactive "p")
  (my/get-shellish arg 'my/newshell "shell"))

(defun my/newterm ()
  "Create a new shell with specified buffer name."
  (interactive)
  (if (my/find-last-shellish-buffer (buffer-list (selected-frame)) "term")
      (multi-term (format "*terminal<%s>*"
                          (read-string "Shell buffer name: ")))
    (multi-term)))

(defun my/get-term (arg)
  (interactive "p")
  (my/get-shellish arg 'my/newterm "term"))

;; Key bindings
(global-set-key (kbd "C-c S") #'my/get-shell)  ;; C-c s is now mapped to vterm
(global-set-key (kbd "C-c t") #'my/get-term)
#+end_src

** Shell

I have a little helper functions to make shell buffers more useful for use
cases. I have a custom configuration for display-buffer-alist to make my custom
shell buffers always appear at the bottom left on the frame.

~C-c s~ will pop up a shell buffer at the bottom then another ~C-c s~ will close the
shell window. The helper functions defined below make it possible.

#+begin_src emacs-lisp
(use-package shell
  :bind (("C-x ~" . dirs))
  :config
  ;; dirtrack using procfs
  (defun shell-procfs-dirtrack (str)
    (prog1 str
      (when (string-match comint-prompt-regexp str)
        (let ((directory (file-symlink-p
                          (format "/proc/%s/cwd"
                                  (process-id
                                   (get-buffer-process
                                    (current-buffer)))))))
          (when (file-directory-p directory)
            (cd directory))))))

  (define-minor-mode shell-procfs-dirtrack-mode
    "Track shell directory by inspecting procfs."
    :global t
    (cond (shell-procfs-dirtrack-mode
           (when (bound-and-true-p shell-dirtrack-mode)
             (shell-dirtrack-mode 0))
           (when (bound-and-true-p dirtrack-mode)
             (dirtrack-mode 0))
           (add-hook 'comint-preoutput-filter-functions
                     'shell-procfs-dirtrack nil t))
          (t
           (remove-hook 'comint-preoutput-filter-functions
                        'shell-procfs-dirtrack t))))

  ;; Temporarily comment out to make my/get-shell work with remote (i.e. in tramp
  ;; format) default-directory.
  ;; (add-hook 'shell-mode-hook #'(lambda () (shell-procfs-dirtrack-mode 1)))

  ;; custom dir track list
  ;; (add-hook 'shell-mode-hook
  ;;           '(lambda ()
  ;;              (shell-dirtrack-mode 0)
  ;;              (dirtrack-mode 1)
  ;;              (setq dirtrack-list '("(..:..)\\((.+)\\)*\\([^\033()$#]+\\)" 2))
  ;;              (company-mode 0))
  ;;           'APPEND)

  ;; custom password prompt regexp
  (setq comint-password-prompt-regexp
        "\\(^ *\\|\\( *Password\\| *SSO\\| *IronKey\\| SMB\\|'s\\|Bad\\|CVS\\|Enter\\(?: \\(?:\\(?:sam\\|th\\)e\\)\\)?\\|Kerberos\\|LDAP\\|New\\|Old\\|Repeat\\|UNIX\\|\\[sudo]\\|enter\\(?: \\(?:\\(?:sam\\|th\\)e\\)\\)?\\|login\\|new\\|old\\) *\\)\\(?:\\(?:adgangskode\\|contrase\\(?:\\(?:ny\\|\\)a\\)\\|geslo\\|h\\(?:\\(?:as\\|esl\\)o\\)\\|iphasiwedi\\|jelsz\\|l\\(?:ozinka\\|senord\\)\\|m\\(?:ot de passe\\|t khu\\)\\|[Pp]a\\(?:rola\\|s\\(?:ahitza\\|s\\(?: phrase\\|code\\|ord\\|phrase\\|wor[dt]\\)\\|vorto\\)\\)\\|s\\(?:alasana\\|enha\\|laptaodis\\)\\|wachtwoord\\|\\|\\|\\| \\|\\|\\|\\|\\|\\|\\| \\|\\|\\|\\|\\|\\|\\|\\|[]\\|\\)\\|Response\\)\\(?:\\(?:, try\\)? *again\\| (empty for no passphrase)\\| (again)\\)?\\(?: for .+\\)?[:]\\s *\\'")
  )
#+end_src

** Eshell

I don't use eshell often (I use shell instead) so there is a chance that this
config does not perfectly work.

#+begin_src emacs-lisp
(setq eshell-buffer-shorthand t
      eshell-scroll-to-bottom-on-input 'all
      eshell-error-if-no-glob t
      eshell-hist-ignoredups t
      eshell-save-history-on-exit t
      eshell-prefer-lisp-functions nil)

(add-hook 'eshell-mode-hook
          #'(lambda ()
              ;; aliases
              (eshell/alias "ls" "ls -A $*")
              (eshell/alias "l" "ls -lA $*")
              (eshell/alias "ff" "find-file-other-tab $1")
              (eshell/alias "ffsu" "find-file-other-tab /sudo::$PWD/$1")
              (eshell/alias "e" "find-file-other-tab $1")
              (eshell/alias "ms" "magit-status")
              (eshell/alias "gc" "git checkout $*")
              (eshell/alias "gb" "git branch $*")
              (eshell/alias "gs" "git status $*")
              (eshell/alias "gd" "git diff $*")
              ;; visual commands
              (add-to-list 'eshell-visual-commands "ssh")
              (add-to-list 'eshell-visual-commands "tail")
              (add-to-list 'eshell-visual-commands "top")))

;; Faces
(with-eval-after-load 'em-ls
  (set-face-attribute 'eshell-ls-directory nil
                      :foreground "DodgerBlue"))

(defun my/neweshell ()
  (interactive)
  (eshell "new"))

(defun my/get-eshell (arg)
  (interactive "p")
  (my/get-shellish arg 'my/neweshell "eshell"))

(global-set-key (kbd "C-c e") #'my/get-eshell)

(use-package eshell-git-prompt
  :config
  (eshell-git-prompt-use-theme 'powerline))

(use-package eterm-256color)
#+end_src

** VTerm

Do not forget to add the following code to .bashrc
#+begin_src shell
if [[ -n "${EMACS_VTERM_PATH}" ]]; then
  f=${EMACS_VTERM_PATH}etc/emacs-vterm-bash.sh
  if [[ -f "$f" ]]; then
    . "$f"
  fi
fi
#+end_src

#+begin_src emacs-lisp
(use-package vterm
  :bind (("C-c s" . my/get-vterm)
         ("C-c C-z" . my/vterm-send-ctrl-z))
  :commands (vterm)
  :config
  (define-key vterm-mode-map (kbd "C-z") tab-prefix-map)

  (defun my/newvterm ()
    "Create a new vterm with specified buffer name."
    (interactive)
    (if (my/find-last-shellish-buffer (buffer-list (selected-frame)) "vterm")
        (vterm (format "*vterm<%s>*"
                       (read-string "Shell buffer name: ")))
      (vterm)))

  (defun my/get-vterm (arg)
    (interactive "p")
    (my/get-shellish arg 'my/newvterm "vterm"))

  (defun my/vterm-send-ctrl-z ()
    (interactive)
    (vterm-send-key (kbd "C-z")))
  )
#+end_src

** Term

#+begin_src emacs-lisp
(use-package term
  :config
  (set-face-attribute 'term nil
                      :foreground 'unspecified
                      :background 'unspecified
                      :inherit 'default))
#+end_src

*** tramp-term

#+begin_src emacs-lisp
(use-package tramp-term
  :bind (("C-c T" . tramp-term)))
#+end_src

*** multi-term

#+begin_src emacs-lisp
(use-package multi-term
  :custom
  (multi-term-dedicated-close-back-to-open-buffer-p nil)
  (multi-term-dedicated-select-after-open-p t)
  (multi-term-program "/bin/bash")
  (term-unbind-key-list '("C-z" "C-x" "C-c" "C-h" "C-u"))
  :hook (term-mode . (lambda ()
                       (define-key term-mode-map (kbd "C-a") 'term-bol)
                       (define-key term-mode-map (kbd "C-c C-a")
                                   'move-beginning-of-line)
                       (setq-local term-prompt-regexp "^[^#$%>]*[#$%>] *")))
  :config
  (setq term-bind-key-alist
        (append
         '(("C-c C-c" . term-send-raw)
           ("C-c C-x" . term-send-raw)
           ("C-c C-z" . term-send-raw)
           ("C-c C-h" . term-send-raw)
           ("C-c C-u" . term-send-raw)
           ("C-c C-k" . term-char-mode)
           ("C-c C-j" . term-line-mode))
         term-bind-key-alist))

  ;; override multi-term to use display-buffer
  (defun multi-term (&optional name)
    "Create new term buffer.
  Will prompt you shell name when you type `C-u' before this command."
    (interactive)
    (let (term-buffer)
      ;; Set buffer.
      (setq term-buffer (multi-term-get-buffer nil))
      (setq multi-term-buffer-list
            (nconc multi-term-buffer-list (list term-buffer)))
      (unless (or (null name)
                  (string= name ""))
        (with-current-buffer term-buffer (rename-buffer name)))
      (set-buffer term-buffer)
      ;; Internal handle for `multi-term' buffer.
      (multi-term-internal)
      ;; Switch buffer
      (select-window (display-buffer term-buffer))))
  )
#+end_src

** Eat

Yet another terminal emulator. Trying out now.

#+begin_src emacs-lisp
(use-package eat
  :bind (("C-c s" . my/get-eat))
  :straight '(eat :type git
                  :host codeberg
                  :repo "akib/emacs-eat"
                  :files ("*.el" ("term" "term/*.el") "*.texi"
                          "*.ti" ("terminfo/e" "terminfo/e/*")
                          ("terminfo/65" "terminfo/65/*")
                          ("integration" "integration/*")
                          (:exclude ".dir-locals.el" "*-tests.el")))
  :hook ((eshell-mode . eat-eshell-mode))
  :config
  (define-key eat-semi-char-mode-map (kbd "C-z") tab-prefix-map)

  (defun my/neweat ()
    "Create a new eat session."
    (interactive)
      (eat nil t))

  (defun my/get-eat (arg)
    (interactive "p")
    (my/get-shellish arg 'my/neweat "eat")))
#+end_src

* Software Development

** Misc preferences

#+begin_src emacs-lisp
(setq compilation-scroll-output t)

;; linum-mode
;; (setq linum-format "%4d\u2502")
;; (add-hook 'prog-mode-hook
;;           '(lambda () (linum-mode 1)))

;; Do not use TAB for indentation by default.
(add-hook 'prog-mode-hook
          #'(lambda ()
              (setq-local indent-tabs-mode nil)))
#+end_src

** Tree Sitter

#+begin_src emacs-lisp
(use-package treesit
  :straight (:type built-in)
  :custom
  (treesit-font-lock-level 4)
  (treesit-load-name-override-list
   '((c++ "libtree-sitter-cpp" "tree_sitter_cpp")
     (js "libtree-sitter-js" "tree_sitter_javascript")
     (common-lisp "libtree-sitter-common-lisp" "tree_sitter_commonlisp")
     (csharp "libtree-sitter-csharp" "tree_sitter_c_sharp")
     (go-mod "libtree-sitter-go-mod" "tree_sitter_gomod")))
  :init
  ;; Remap major modes to tree-sitter powered modes.
  (setq major-mode-remap-alist
        (append
         major-mode-remap-alist
        '((c-mode . c-ts-mode)
          (c++-mode . c++-ts-mode)
          (csharp-mode . csharp-ts-mode)
          (go-dot-mod-mode . go-mod-ts-mode)
          (go-mode . go-ts-mode)
          (java-mode . java-ts-mode)
          (python-mode . python-ts-mode))))
  :config
  ;; setting treesit-language-source-alist via :custom not working
  (setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (c "https://github.com/tree-sitter/tree-sitter-c")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (common-lisp "https://github.com/theHamsta/tree-sitter-commonlisp")
     (cpp "https://github.com/tree-sitter/tree-sitter-cpp" "v0.22.0")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (csharp "https://github.com/tree-sitter/tree-sitter-c-sharp")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (go-mod "https://github.com/camdencheek/tree-sitter-go-mod")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (js . ("https://github.com/tree-sitter/tree-sitter-javascript" "master" "src"))
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (lua "https://github.com/Azganoth/tree-sitter-lua")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (r "https://github.com/r-lib/tree-sitter-r")
     (rust "https://github.com/tree-sitter/tree-sitter-rust")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
     (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src"))
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

  ;; Install tree-sitter language grammar for all langues configured.
  (defun my/treesit-install-all-languages ()
    (interactive)
    (dolist (ent treesit-language-source-alist)
      (let ((lang (car ent)))
        (unless (treesit-language-available-p lang)
          (message "Installing %s grammar for tree-sitter" lang)
          (treesit-install-language-grammar lang)))))
  )
#+end_src

** LSP

*** lsp-mode

#+begin_src emacs-lisp
(use-package lsp-mode
  :hook
  ((lsp-mode . (lambda ()
                 (lsp-enable-which-key-integration)
                 (define-key lsp-mode-map (kbd "C-c l") lsp-command-map))))
  :commands (lsp lsp-register-client)
  :preface
  ;; Use plists for emacs-lsp-booster
  (setenv "LSP_USE_PLISTS" "true")
  (setq lsp-use-plists t)

  :init
  (setq lsp-keymap-prefix (kbd "C-c l"))
  ;; (setq lsp-signature-auto-activate nil)
  (setq lsp-signature-render-documentation nil)
  :custom
  (lsp-diagnostic-clean-after-change t)
  :config

  ;; Hack to enable LSP in org-src-mode buffers.
  ;; https://github.com/emacs-lsp/lsp-mode/issues/2842#issuecomment-870807018
  ;; Run lsp command after switching to the associated Org Src buffer.
  (defun org-babel-edit-prep:python (babel-info)
    (let ((tangle (->> babel-info caddr (alist-get :tangle))))
      (setq-local buffer-file-name
                  (if (string= tangle "no")
                      "~/tmp/__temp__.py"
                    tangle))))
  ;; Use advice as org-babel-edit-prep:jupyter-<lang> will be defined ob-jupyter.el.
  (advice-add #'org-babel-edit-prep:jupyter-python :after
              #'org-babel-edit-prep:python)

  ;; Enable config for emacs-lsp-booster
  (when (file-exists-p "/usr/bin/emacs-lsp-booster")
    (defun lsp-booster--advice-json-parse (old-fn &rest args)
      "Try to parse bytecode instead of json."
      (or
       (when (equal (following-char) ?#)
         (let ((bytecode (read (current-buffer))))
           (when (byte-code-function-p bytecode)
             (funcall bytecode))))
       (apply old-fn args)))
    (advice-add (if (progn (require 'json)
                           (fboundp 'json-parse-buffer))
                    'json-parse-buffer
                  'json-read)
                :around
                #'lsp-booster--advice-json-parse)

    (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
      "Prepend emacs-lsp-booster command to lsp CMD."
      (let ((orig-result (funcall old-fn cmd test?)))
        (if (and (not test?)                             ;; for check lsp-server-present?
                 (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
                 lsp-use-plists
                 (not (functionp 'json-rpc-connection))  ;; native json-rpc
                 (executable-find "emacs-lsp-booster"))
            (progn
              (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
                (setcar orig-result command-from-exec-path))
              (message "Using emacs-lsp-booster for %s!" orig-result)
              (cons "emacs-lsp-booster" orig-result))
          orig-result)))
    (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)))

(use-package lsp-ui
  :after lsp-mode
  :bind (:map lsp-ui-doc-frame-mode-map
              ("C-b" . lsp-ui-doc-hide)
              ("C-f" . lsp-ui-doc-hide)
              ("C-g" . lsp-ui-doc-hide)
              ;; ("C-n" . my/lsp-ui-doc-scroll-up-by-1)
              ;; ("C-p" . my/lsp-ui-doc-scroll-down-by-1)
              ("<down>" . my/lsp-ui-doc-scroll-up-by-1)
              ("<up>" . my/lsp-ui-doc-scroll-down-by-1)
              ("C-v" . my/lsp-ui-doc-scroll-up)
              ("M-v" . my/lsp-ui-doc-scroll-down)
              ("<next>" . my/lsp-ui-doc-scroll-up)
              ("<prior>" . my/lsp-ui-doc-scroll-down))
  :custom
  (lsp-ui-doc-position 'at-point)
  (lsp-ui-doc-show-with-cursor t)
  (lsp-ui-doc-delay 1.0)
  :config
  ;; (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  ;; (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
  (define-key lsp-ui-doc-mode-map (kbd "<tab-bar> <mouse-movement>") #'ignore)
  (set-face-attribute 'lsp-ui-peek-selection nil
                      :foreground 'unspecified
                      :background 'unspecified
                      :inherit 'region)
  (set-face-attribute 'lsp-ui-peek-header nil
                      :foreground 'unspecified
                      :background "dark slate blue")
  (set-face-attribute 'lsp-ui-peek-highlight nil
                      :foreground 'unspecified
                      :background "royal blue"
                      :distant-foreground 'unspecified
                      :box '(:line-width -1 :color "white"))

  (setf (alist-get 'no-accept-focus lsp-ui-doc-frame-parameters) t)

  ;; Temporarily bind scroll-up/down keys when child frame is visible.
  (defun my/lsp-ui-doc-scroll (scroll-func &rest args)
    (when (lsp-ui-doc--frame-visible-p)
      (with-selected-frame (lsp-ui-doc--get-frame)
        (lsp-ui-doc--with-buffer
          (apply scroll-func args)))))

  (defun my/lsp-ui-doc-scroll-up (&optional n)
    (interactive "P")
    (my/lsp-ui-doc-scroll 'scroll-up n))

  (defun my/lsp-ui-doc-scroll-down (&optional n)
    (interactive "P")
    (my/lsp-ui-doc-scroll 'scroll-down n))

  (defun my/lsp-ui-doc-scroll-up-by-1 (&optional n)
    (interactive "p")
    (my/lsp-ui-doc-scroll-up n))

  (defun my/lsp-ui-doc-scroll-down-by-1 (&optional n)
    (interactive "p")
    (my/lsp-ui-doc-scroll-down n))

  (defun my/lsp-ui-doc-on-show-frame (&rest args)
    (when (lsp-ui-doc--visible-p)
      (setf (alist-get #'lsp-ui-doc-mode minor-mode-overriding-map-alist)
            lsp-ui-doc-frame-mode-map)))

  (defun my/lsp-ui-doc-on-hide-frame (&rest args)
    (setf (alist-get #'lsp-ui-doc-mode minor-mode-overriding-map-alist
                     nil 'remove) nil))

  (advice-add #'lsp-ui-doc--display :after #'my/lsp-ui-doc-on-show-frame)
  (advice-add #'lsp-ui-doc--hide-frame :after #'my/lsp-ui-doc-on-hide-frame)

  (dolist (sym '( my/lsp-ui-doc-scroll my/lsp-ui-doc-scroll-up
                  my/lsp-ui-doc-scroll-down my/lsp-ui-doc-scroll-up-by-1
                  my/lsp-ui-doc-scroll-down-by-1))
    (put sym 'completion-predicate #'ignore))
  )

(use-package lsp-pyright
  :after lsp-mode
  :custom
  (lsp-pyright-langserver-command "basedpyright"))

(use-package lsp-treemacs
  :requires lsp-mode)

(defvar my/lsp-enabled-mode-hook-list
  (if (< (string-to-number emacs-version) 29)
      '(python-mode-hook yaml-mode-hook)
    '(python-base-mode-hook yaml-mode-hook)))
(defun my/setup-lsp ()
  "Set up hooks to enable lsp-mode."
  (interactive)
  (dolist (hook my/lsp-enabled-mode-hook-list)
    (add-hook hook #'lsp)))
#+end_src

*** eglot

Currently eglot is disabled to try lsp-mode out again.

#+begin_src emacs-lisp
(use-package eglot
  :disabled
  :requires projectile
  :hook ((eglot--managed-mode . (lambda () (flycheck-mode -1)))
         ((c++-ts-mode python-ts-mode) . eglot-ensure))
  :commands (eglot eglot-ensure)
  ;; :config
  ;; Disabled as I don't remember what this is.
  ;; (with-eval-after-load 'project
  ;;   (add-to-list 'project-find-functions
  ;;                #'(lambda (dir)
  ;;                    (let ((root (projectile-project-root dir)))
  ;;                      (and root (cons 'transient root))))))
  )
#+end_src

** Eldoc

Eldoc-box displays eldoc contents in a child frame but is currently disabled.

#+begin_src emacs-lisp
(use-package eldoc-box
  :disabled
  :diminish eldoc-box-hover-mode
  :hook (prog-mode . eldoc-box-hover-mode)
  :bind (:map my/info-map
              ("i" . eldoc-box-eglot-help-at-point))
  :custom
  (eldoc-box-clear-with-C-g t))
#+end_src

** Flycheck & Flymake

*** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :diminish
  :custom (flycheck-indication-mode nil))

(use-package flycheck-popup-tip
  :hook (flycheck-mode . flycheck-popup-tip-mode))

(use-package consult-flycheck
  :diminish)
#+end_src

*** flymake
#+begin_src emacs-lisp
(use-package flymake
  :disabled
  :hook (prog-mode . flymake-mode))

(use-package flymake-diagnostic-at-point
  :hook (flymake-mode . flymake-diagnostic-at-point-mode))
#+end_src

** puni (structured editing)

#+begin_src emacs-lisp
(use-package puni
  :diminish
  :bind (("C-d" . delete-char)  ;; don't override C-d
         ("C-)" . puni-slurp-forward)
         ("C-(" . puni-barf-forward)
         ("C-c '" . my/puni-wrap-single-quote)
         ("C-c \"" . my/puni-wrap-double-quote)
         ("C-c (" . puni-wrap-round)
         ("C-c [" . puni-wrap-square)
         ("C-c {" . puni-wrap-curly)
         ("C-c <" . puni-wrap-angle)
         ("M-SPC" . puni-mark-sexp-at-point)
         :map puni-mode-map
         ("C-<" . puni-raise)
         ("C->" . puni-splice)
         :map my/edit-map
         ("'" . my/puni-wrap-single-quote)
         ("\"" . my/puni-wrap-double-quote)
         ("(" . puni-wrap-round)
         ("[" . puni-wrap-square)
         ("{" . puni-wrap-curly)
         ("<" . puni-wrap-angle))
  :hook (emacs-lisp-mode . puni-mode)
  :custom
  (puni-confirm-when-delete-unbalanced-active-region nil)
  :config
  (defun my/def-pairs (pairs)
    (dolist (wdef pairs)
      (fset (intern (concat
                     "my/puni-wrap-"
                     (symbol-name (car wdef))))
            `(lambda (&optional n)
               (interactive "P")
               (puni-wrap-next-sexps
                (puni--parse-interactive-argument-for-wrap n)
                ,(cadr wdef) ,(cddr wdef))))))

  (my/def-pairs '((single-quote . ("'" . "'"))
                  (double-quote . ("\"" . "\""))))
  )
#+end_src

** Dumb jump

#+begin_src emacs-lisp
(use-package dumb-jump
  :diminish
  :hook (prog-mode . dumb-jump-mode)
  :custom
  (dumb-jump-disable-obsolete-warnings t)
  (dumb-jumb-default-project "")
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))

#+end_src

** Aggressive indent

#+begin_src emacs-lisp
(use-package aggressive-indent
  :hook ((go-mode . aggressive-indent-mode)
         (emacs-lisp-mode . aggressive-indent-mode)))
#+end_src

** Highlighting

*** Rainbow Mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :diminish
  )
#+end_src

*** Rainbow Delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode)
  :config
  (set-face-background 'rainbow-delimiters-unmatched-face "red")

  ;; Borrowed from https://qiita.com/megane42/items/ee71f1ff8652dbf94cf7.
  (require 'cl-lib)
  (require 'color)
  (defun rainbow-delimiters-using-stronger-colors ()
    (interactive)
    (cl-loop
     for index from 1 to rainbow-delimiters-max-face-count
     do
     (let ((face (intern (format "rainbow-delimiters-depth-%d-face" index))))
       (cl-callf color-saturate-name (face-foreground face) 50))))
  (add-hook 'emacs-startup-hook 'rainbow-delimiters-using-stronger-colors))
#+end_src

*** Show whitespaces

#+begin_src emacs-lisp
(use-package whitespace
  :diminish whitespace-mode
  :hook ((prog-mode conf-mode yaml-mode) . whitespace-mode)
  :custom
  (whitespace-style '(face trailing tabs tab-mark))
  :config
  (set-face-attribute 'whitespace-tab nil
                       :foreground "gray30"
                       :background 'unspecified)
  (set-face-attribute 'whitespace-trailing nil
                       :background "gray25")
  )
#+end_src

*** Symbol overlay

#+begin_src emacs-lisp
(use-package symbol-overlay
  :diminish
  :hook (prog-mode . symbol-overlay-mode)
  :custom (symbol-overlay-idle-time 1.0))
#+end_src

*** Highlight indent guides

By default this is only enabled for yaml-mode for performance reasons.

#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :hook (yaml-mode . highlight-indent-guides-mode)
  :diminish highlight-indent-guides-mode
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-auto-enabled nil)
  :config
  (custom-set-faces
   '(highlight-indent-guides-odd-face ((t :background "DarkGray")))
   '(highlight-indent-guides-even-face ((t :background "DimGray")))
   '(highlight-indent-guides-character-face ((t :foreground "DimGray")))
   '(highlight-indent-guides-top-character-face ((t :foreground "DimGray")))
   '(highlight-indent-guides-stack-character-face ((t :foreground "DimGray")))))
#+end_src

*** Diff HL mode

#+begin_src emacs-lisp
(use-package diff-hl
  :diminish
  :config
  (with-eval-after-load 'magit
    (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))

  (global-diff-hl-mode))
#+end_src

** Git

*** Magit

#+begin_src emacs-lisp
(use-package magit
  :commands (magit-status)
  :bind (("C-c M s" . magit-status)
         ("C-c M f" . magit-file-dispatch))
  :config
  (add-hook 'magit-process-find-password-functions 'magit-process-password-auth-source))
#+end_src

*** Forge

Disabled for now. This entry is for future use.

#+begin_src emacs-lisp
(use-package forge
  :disabled
  :after magit)
#+end_src

*** Git timemachine

#+begin_src emacs-lisp
(use-package git-timemachine
  :commands (git-timemachine git-timemachine-toggle))
#+end_src

*** Git gutter

Currentl disabled as I'm trying out diff-hl.

#+begin_src emacs-lisp
(use-package git-gutter
  :disabled
  :diminish git-gutter-mode
  :bind (:map my/misc-map
              ("g" . my/hydra-git-gutter/body))
  :config
  (global-git-gutter-mode 1)
  ;; (git-gutter:linum-setup)
  (defhydra my/hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                        :hint nil)
    "
  Git gutter:
    _j_: next hunk        _s_tage hunk     _q_uit
    _k_: previous hunk    _r_evert hunk    _Q_uit and deactivate git-gutter
    ^ ^                   _p_opup hunk
    _h_: first hunk
    _l_: last hunk        set start _R_evision
  "
    ("j" git-gutter:next-hunk)
    ("k" git-gutter:previous-hunk)
    ("h" (progn (goto-char (point-min))
                (git-gutter:next-hunk 1)))
    ("l" (progn (goto-char (point-min))
                (git-gutter:previous-hunk 1)))
    ("s" git-gutter:stage-hunk)
    ("r" git-gutter:revert-hunk)
    ("p" git-gutter:popup-hunk)
    ("R" git-gutter:set-start-revision)
    ("q" nil :color blue)
    ("Q" (progn (git-gutter-mode -1)
                ;; git-gutter-fringe doesn't seem to
                ;; clear the markup right away
                (sit-for 0.1)
                (git-gutter:clear))
     :color blue)))
#+end_src

** Debugging

*** REST Client

#+begin_src emacs-lisp
(use-package restclient
  :mode ("\\.http\\'" . restclient-mode))

(use-package ob-restclient
  :after (restclient org)
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t))))
#+end_src

*** Custom code for URL encoding/decoding

#+begin_src emacs-lisp
;; urlencode
(defvar urlencode-default-coding-system 'utf-8)
(defvar urlencode-exceptional-chars "[a-zA-Z0-9]")

(defun urlencode-region (begin end &optional cdp)
  (interactive "r\nP")
  (let* ((coding-system (and cdp (read-coding-system "Coding-system: ")))
         (encoded (urlencode (buffer-substring begin end) coding-system)))
    (delete-region begin end)
    (insert encoded)))

(defun urldecode-region (begin end &optional cdp)
  (interactive "r\nP")
  (let* ((coding-system (and cdp (read-coding-system "Coding-system: ")))
         (decoded (urldecode (buffer-substring begin end) coding-system)))
    (delete-region begin end)
    (insert decoded)))

(defun urlencode-string (str &optional cdp)
  (interactive "sString: \nP")
  (let ((coding-system (and cdp (read-coding-system "Coding-system: "))))
    (insert (urlencode str coding-system))))

(defun urldecode-string (str &optional cdp)
  (interactive "sString: \nP")
  (let ((coding-system (and cdp (read-coding-system "Coding-system: "))))
    (insert (urldecode str coding-system))))

(defun urlencode (str &optional coding-system)
  (mapconcat
   (lambda (c)
     (format (if (string-match urlencode-exceptional-chars (char-to-string c))
                 "%c" "%%%02X") c))
   (encode-coding-string str
                         (or coding-system urlencode-default-coding-system))
   ""))

(defun urldecode (str &optional coding-system)
  (let (pos
        decoded)
    (while (setq pos (string-match "%.." str))
      (setq decoded
            (concat decoded (substring str 0 pos)
                    (format "%c"
                            (string-to-int (substring str (+ pos 1) (+ pos 3)) 16)))
            str (substring str (+ pos 3))))
    (decode-coding-string (concat decoded str)
                          (or coding-system urlencode-default-coding-system))))
#+end_src

** Code Completion
*** Copilot

~copilot-install-server~ needs to be run after a fresh install. Also, Node.js v18+ is needed.
Manually enable ~copilot-mode~ when needed.

#+begin_src emacs-lisp
(use-package copilot
  :straight (:host github :repo "copilot-emacs/copilot.el" :files ("*.el"))
  :bind ( :map copilot-completion-map
          ("C-<return>" . copilot-accept-completion)))  ;; tab conficts with others such as LSP.
#+end_src

*** Tabnine

#+begin_src emacs-lisp
(use-package tabnine
  :disabled
  :straight (tabnine
             :type git
             :host github
             :repo "shuxiao9058/tabnine")
  :commands (tabnine-start-process)
  :hook (;; (prog-mode . tabnine-mode)
         (kill-emacs . tabnine-kill-process))
  :diminish ""
  :custom
  (tabnine-wait 1)
  (tabnine-minimum-prefix-length 0)
  :init
  (defun my/start-tabnine ()
    (interactive)
    (add-to-list 'completion-at-point-functions #'tabnine-completion-at-point)
    (tabnine-start-process)
    (tabnine-mode))
  :bind
  (:map  tabnine-completion-map
         ("<tab>" . tabnine-accept-completion)
         ("TAB" . tabnine-accept-completion)
         ("M-f" . tabnine-accept-completion-by-word)
         ("M-<return>" . tabnine-accept-completion-by-line)
         ("C-g" . tabnine-clear-overlay)
         ("M-[" . tabnine-previous-completion)
         ("M-]" . tabnine-next-completion)))
#+end_src

*** Codeium

#+begin_src emacs-lisp
(use-package codeium
  :disabled
  :straight '(:type git :host github :repo "Exafunction/codeium.el")
  :commands (codeium-install codeium-diagnose codeium-completion-at-point)
  :init
  (defun my/start-codium ()
    (interactive)
    (add-to-list 'completion-at-point-functions #'codeium-completion-at-point))
  ;; use globally
  ;; or on a hook
  ;; (add-hook 'python-mode-hook
  ;;     (lambda ()
  ;;         (setq-local completion-at-point-functions '(codeium-completion-at-point))))

  ;; if you want multiple completion backends, use cape (https://github.com/minad/cape):
  ;; (add-hook 'python-mode-hook
  ;;     (lambda ()
  ;;         (setq-local completion-at-point-functions
  ;;             (list (cape-capf-super #'codeium-completion-at-point #'lsp-completion-at-point)))))
  ;; an async company-backend is coming soon!

  ;; codeium-completion-at-point is autoloaded, but you can
  ;; optionally set a timer, which might speed up things as the
  ;; codeium local language server takes ~0.2s to start up
  ;; (add-hook 'emacs-startup-hook
  ;;  (lambda () (run-with-timer 0.1 nil #'codeium-init)))

  ;; :defer t ;; lazy loading, if you want
  :config
  ;; if you don't want to use customize to save the api-key
  ;; (setq codeium/metadata/api_key "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")

  ;; get codeium status in the modeline
  (setq codeium-mode-line-enable
        (lambda (api) (not (memq api '(CancelRequest Heartbeat AcceptCompletion)))))
  (add-to-list 'mode-line-format '(:eval (car-safe codeium-mode-line)) t)
  ;; alternatively for a more extensive mode-line
  ;; (add-to-list 'mode-line-format '(-50 "" codeium-mode-line) t)

  ;; use M-x codeium-diagnose to see apis/fields that would be sent to the local language server
  (setq codeium-api-enabled
        (lambda (api)
          (memq api '(GetCompletions Heartbeat CancelRequest GetAuthToken RegisterUser auth-redirect AcceptCompletion))))
  ;; you can also set a config for a single buffer like this:
  ;; (add-hook 'python-mode-hook
  ;;     (lambda ()
  ;;         (setq-local codeium/editor_options/tab_size 4)))

  ;; You can overwrite all the codeium configs!
  ;; for example, we recommend limiting the string sent to codeium for better performance
  (defun my-codeium/document/text ()
    (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (min (+ (point) 1000) (point-max))))
  ;; if you change the text, you should also change the cursor_offset
  ;; warning: this is measured by UTF-8 encoded bytes
  (defun my-codeium/document/cursor_offset ()
    (codeium-utf8-byte-length
     (buffer-substring-no-properties (max (- (point) 3000) (point-min)) (point))))
  (setq codeium/document/text 'my-codeium/document/text)
  (setq codeium/document/cursor_offset 'my-codeium/document/cursor_offset))
#+end_src

** AI Agents
*** Aider
#+begin_src emacs-lisp
(use-package aider
  :straight (:host github :repo "tninja/aider.el" :files ("aider.el"))
  :commands (aider-transient-menu)
  :bind ( :map my/ai-map
          ("a" . aider-transient-menu))
  :config
  ;; Use claude-3-5-sonnet cause it is best in aider benchmark
  ;; (setq aider-args '("--model" "anthropic/claude-3-5-sonnet-20241022"))
  ;; (setenv "ANTHROPIC_API_KEY" (my/get-anthropic-apikey))
  ;; Or use chatgpt model since it is most well known
  ;; (setq aider-args '("--model" "gpt-4o-mini"))
  ;; (setenv "OPENAI_API_KEY" <your-openai-api-key>)
  ;; Or use gemini v2 model since it is very good and free
  (setq aider-args '("--model" "gemini/gemini-2.0-flash-exp"))
  (setenv "GEMINI_API_KEY" (my/get-gemini-apikey))
  ;; Or use your personal config file
  ;; (setq aider-args `("--config" ,(expand-file-name "~/.aider.conf.yml")))
  )
#+end_src

*** Copilot Chat
#+begin_src emacs-lisp
(use-package copilot-chat
  :straight (:host github :repo "chep/copilot-chat.el" :files ("*.el"))
  :commands (copilot-chat-transient copilot-chat-display)
  :bind ( :map my/ai-map
          ("c" . copilot-chat-transient))
  :custom
  (copilot-chat-backend 'curl)
  (copilot-chat-frontend 'org)
  (copilot-chat-model "claude-3.5-sonnet") ;; "gpt-4o", "o1-preview"
  )
#+end_src
** Jupyter

#+begin_src emacs-lisp
(use-package jupyter
  :custom
  (jupyter-use-zmq nil)
  :config
  ;; Override jupyter-python in org-src-lang-modes.
  (advice-add #'org-babel-jupyter-make-language-alias :after
              (lambda (kernel lang)
                (setf (alist-get "jupyter-python" org-src-lang-modes
                                 nil nil #'equal)
                      'python-ts)))

  ;; Custom function to enable the default virtual env and load ob-jupyter.
  (defun my/setup-jupyter ()
    (interactive)
    (require 'ob-jupyter)
    (pyvenv-activate "~/.venv")
    ;; use jupyter-python for python src block
    ;; (org-babel-jupyter-override-src-block "python")
    ;; (add-to-list 'ob-async-no-async-languages-alist "python")
    (jupyter-refresh-kernelspecs)
    (org-babel-jupyter-aliases-from-kernelspecs)
    ;; For handling ANSI colors in error messages.
    (defun my/display-ansi-colors ()
      (ansi-color-apply-on-region (point-min) (point-max)))
    (add-hook 'org-babel-after-execute-hook #'my/display-ansi-colors)))
#+end_src

* Programming language modes

** C++

Use c++-ts-mode by default.

#+begin_src emacs-lisp
(use-package c++-ts-mode
  :defer t
  :straight (:type built-in)
  :init
  (add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
  )
#+end_src

I adopt Google coding style. ~C-c i [br]~ key bindings should universally work as
formatting commands.

#+begin_src emacs-lisp
(use-package modern-cpp-font-lock
  :diminish modern-c++-font-lock-mode
  :hook
  ((c++-mode c++-ts-mode) . modern-c++-font-lock-mode))

(use-package clang-format
  :custom
  (clang-format-style "google")
  :hook
  ((c-mode-common c++-ts-mode) . (lambda ()
                     (local-set-key (kbd "C-c i b") 'clang-format-buffer)
                     (local-set-key (kbd "C-c i r") 'clang-format-region))))
#+end_src

** Python

#+begin_src emacs-lisp
(use-package python
  :straight (:type built-in)
  :custom
  (python-shell-completion-native-enable nil)
  (python-flymake-command '("ruff" "--quiet" "--stdin-filename=stdin" "-"))
  (python-indent-guess-indent-offset-verbose nil))
#+end_src

Use Black for formatter.

#+begin_src emacs-lisp
(use-package python-black
  :after python
  :hook ((python-mode python-ts-mode) . my/python-black-setup)
  :config
  (defun my/python-black-setup ()
    (python-black-on-save-mode-enable-dwim)
    (local-set-key (kbd "C-c i b") 'python-black-buffer)
    (local-set-key (kbd "C-c i r") 'python-black-region))
  )
#+end_src

Disable yapfify in favor of Black being tried out.

#+begin_src emacs-lisp
(use-package yapfify
  :disabled
  :hook  ((python-mode python-base-mode) . my/setup-yapfify)
  :config
  (defun my/setup-yapfify ()
    (local-set-key (kbd "C-c i b") 'yapfify-buffer)
    (local-set-key (kbd "C-c i r") 'yapfify-region)))
#+end_src

Use pyvenv package to simply support virtualenv.
~$HOME/.venv~ is the the default venv environment.

#+begin_src emacs-lisp
(use-package pyvenv
  :config
  (pyvenv-mode 1)
  ;; Enable default python environment.
  (when (f-dir-p "~/.venv")
    (pyvenv-activate "~/.venv")))
#+end_src

** Go

The settings are old (~1.12) and might need an update.

#+begin_src emacs-lisp
(use-package go-mode
  :mode ("\\.go\\'" . go-mode)
  :hook
  (go-mode . (lambda ()
               (setq-local compile-command
                           "go build -v && go test -v && go vet")
               (setq-local gofmt-command "goimports")
               (setq-local fill-column 100)
               (setq-local c-basic-offset 4)
               (setq-local tab-width 4)
               (setq-local indent-tabs-mode t)
               (go-guru-hl-identifier-mode)
               (add-hook 'before-save-hook 'gofmt-before-save nil 'local)
               (local-set-key (kbd "M-.") 'godef-jump)
               (local-set-key (kbd "M-*") 'pop-tag-mark))))

(use-package go-eldoc
  :disabled
  :hook (go-mode . go-eldoc-setup))

(use-package go-guru
  :commands go-guru-hl-identifier-mode)

(use-package golint
  :commands golint)
#+end_src

** Web-mode

TBH this is not maintaned these days.

#+begin_src emacs-lisp
;; Web-mode (HTML+CS/JS)
(use-package web-mode
  :mode ("\\.p?html?\\'" "\\.tpl\\.php\\'" "\\.[agj]sp\\'" "\\.as[cp]x\\'"
         "\\.erb\\'" "\\.mustache\\'" "\\.djhtml\\'")
  :hook ((web-mode . (lambda ()
                       (setq-local indent-tabs-mode nil))))
  :after (smartparens)
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-css-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-sql-indent-offset 2)
  (web-mode-enable-block-face t)
  (web-mode-enable-part-face t)
  (web-mode-enable-auto-pairing nil)
  (web-mode-enable-auto-closing t)
  (web-mode-enable-auto-opening t)
  (web-mode-enable-auto-quoting t)
  (web-mode-enable-auto-indentation t)
  (web-mode-enable-css-colorization t)
  (web-mode-enable-current-element-highlight nil)
  (web-mode-enable-current-column-highlight nil)
  (web-mode-enable-comment-interpolation t)
  :config
  (define-key web-mode-map (kbd "C-c /") 'web-mode-element-close)

  (set-face-foreground 'web-mode-current-element-highlight-face "orange")
  (set-face-foreground 'web-mode-html-entity-face "yellow")
  (set-face-foreground 'web-mode-html-tag-face "orangered")
  (set-face-foreground 'web-mode-html-tag-bracket-face
                       (color-darken-name (face-foreground 'default) 20))
  (set-face-foreground 'web-mode-html-attr-name-face "orange")
  (set-face-foreground 'web-mode-html-attr-equal-face "cyan")
  (set-face-foreground 'web-mode-html-attr-value-face
                       (face-foreground 'font-lock-constant-face))
  ;; (set-face-foreground 'web-mode-annotation-tag-face "lightblue")
  ;; (set-face-foreground 'web-mode-annotation-type-face "pink")
  ;; (set-face-foreground 'web-mode-annotation-value-face "navy")
  ;; (set-face-foreground 'web-mode-constant-face "limegreen")
  ;; (set-face-foreground 'web-mode-filter-face "darkblue")
  ;; (set-face-foreground 'web-mode-keyword-face "pink")
  ;; (set-face-foreground 'web-mode-symbol-face
  ;;                      (face-foreground 'font-lock-constant-face))
  ;; (set-face-foreground 'web-mode-type-face "navy")
  ;; (set-face-foreground 'web-mode-variable-name-face "lightblue")

  (defun sp-web-mode-is-code-context (id action context)
    (and (eq action 'insert)
         (not (or (get-text-property (point) 'part-side)
                  (get-text-property (point) 'block-side)))))
  (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context)))
#+end_src

** Javascript

TBH this is not maintaned these days.

#+begin_src emacs-lisp
(use-package rjsx-mode
  :mode ("\\.js\\'" "\\.jsx\\'")
  :hook (rjsx-mode . (lambda ()
                       (setq-local js-indent-level 2)
                       (setq-local tab-width 2))))
#+end_src

** Typescript

TBH this is not maintaned these days.

#+begin_src emacs-lisp
(use-package tide
  :after (flycheck)
  :mode (("\\.tsx\\'" . web-mode))
  :hook ((typescript-mode . tide-setup)
         (typescript-mode . tide-hl-identifier-mode)
         (web-mode . (lambda ()
                       (when (string-equal "tsx" (file-name-extension buffer-file-name))
                         (tide-setup)
                         (tide-hl-identifier-mode))))
         (before-save . tide-format-before-save))
  :config
  (flycheck-add-mode 'typescript-tslint 'web-mode))
#+end_src

** MQL

MQL is a subset of C++.

#+begin_src emacs-lisp
;; MQL4
(add-to-list 'auto-mode-alist '("\\.mq[45h]\\'" . c++-ts-mode))

;; add extensions to dumb-jump
(with-eval-after-load 'dumb-jump
  (dolist (ext '("mq4" "mq5" "mqh"))
    (add-to-list 'dumb-jump-language-file-exts
                 `(:language "c++" :ext ,ext :agtype "cpp" :rgtype "cpp") t)))

;; Add format of compilation error message.
(add-to-list 'compilation-error-regexp-alist
             '("^\\(.+\\)(\\([0-9]+\\),\\([0-9]+\\)) : \\(error\\|warning\\).*$" 1 2 3))
#+end_src

** Java

I don't usually write Java so there's almost nothing here. I'll just rely on
lsp-mode. The formatter is available [[https://github.com/google/google-java-format][here]].

#+begin_src emacs-lisp
(defun my/setup-java-mode ()
  "Used for java-mode hook"
  (interactive)
  (local-set-key (kbd "C-c i b") 'google-java-format-buffer)
  (local-set-key (kbd "C-c i r") 'google-java-format-region))

(add-hook 'java-mode-hook #'my/setup-java-mode)
(add-hook 'java-ts-mode-hook #'my/setup-java-mode)
#+end_src

** Protobuf

#+begin_src emacs-lisp
(use-package protobuf-mode
  :after (smartparens)
  :hook (protobuf-mode . smartparens-mode))
#+end_src

** Shell scripts

#+begin_src emacs-lisp
(use-package sh-script
  :hook (sh-mode . (lambda ()
                     (setq-local sh-basic-offset 2)
                     (setq-local tab-width 2)
                     (setq-local indent-tabs-mode nil)
                     (setq-local sh-shellcheck-arguments "-x"))))
#+end_src

** Pine Script

#+begin_src emacs-lisp
(use-package pine-script-mode
  :mode (("\\.pine" . pine-script-mode)))
#+end_src

* Org mode

** Basic Config

#+begin_src emacs-lisp
(use-package org
  :diminish (org-indent-mode)
  :commands (org-agenda org-switchb org-capture)
  :bind (("C-c o a" . org-agenda)
         ("C-c o b" . org-switchb)
         ("C-c o c" . org-capture)
         ("C-c o h" . org-insert-heading)
         ("C-c o H" . org-insert-subheading)
         ("C-c o l" . org-store-link)
         ("C-c o A" . my/org-agenda-custom-view)
         :map org-mode-map
         ("M-p" . org-babel-previous-src-block)
         ("M-n" . org-babel-next-src-block))
  :hook ((org-mode . org-indent-mode)
         (org-mode . visual-line-mode)
         (org-agenda-mode . (lambda () (hl-line-mode 1)))
         (org-babel-after-execute . org-redisplay-inline-images))
  :custom
  (org-agenda-format-date "%b %e (%a)")
  (org-agenda-file-regexp "\\`[^.].*\\.org\\\(\\.gpg\\\)?\\'")
  (org-agenda-start-on-weekday calendar-week-start-day)
  (org-agenda-window-setup 'other-tab)
  (org-log-into-drawer t)
  (org-list-allow-alphabetical t)
  (org-startup-indented t)
  (org-use-sub-superscripts '{})
  (org-export-with-sub-superscripts '{})
  (org-image-actual-width nil)
  (org-src-preserve-indentation nil)
  (org-edit-src-content-indentation 0)
  (org-src-window-setup 'other-window)
  (org-hide-leading-stars t)
  (org-src-fontify-natively t)
  (org-confirm-babel-evaluate nil)
  (org-hide-emphasis-markers t)
  (org-todo-keywords
   '((sequence "SHOPPING(s)" "TODO(t!)" "NEXT(n!)" "ACTIVE(a!)"
               "WAITING(w@/!)" "BLOCKED(b@/!)" "|" "DONE(d!)" "CANCELLED(c@)")))
  (org-log-done 'time)
  (org-capture-templates nil) ;; Migrated to org-roam-capture.
  (org-agenda-files '("agenda.org" "economic-calendar.org"))
  (org-tag-alist
   '(("ai")
     ("algo")
     ("blog")
     ("bot")
     ("cloud")
     ("crypto")
     ("device")
     ("favorite")
     ("fx")
     ("finance")
     ("investing")
     ("life")
     ("llm")
     ("linux")
     ("ml")
     ("mt")
     ("net")
     ("news")
     ("options")
     ("project")
     ("reddit")
     ("security")
     ("tech")
     ("trading")
     ("youtube")
     ))
  (org-agenda-custom-commands
   '(("d" "Today"
      ((todo "NEXT"
             ((org-agenda-overriding-header "Next")))
       (todo "TODO"
             ((org-agenda-overriding-header "Inbox")))
       (agenda ""
               ((org-agenda-span 'day)))
       (todo "SHOPPING"
             ((org-agenda-overriding-header "Shopping List")))))))
  (org-stuck-projects
   '("+PROJECT/-DONE-SOMEDAY" ("TODO" "WAIT")))

  ;; Moved from org-modern
  (org-auto-align-tags nil)
  (org-tags-column 0)
  (org-fold-catch-invisible-edits 'show-and-error)
  (org-special-ctrl-a/e t)
  (org-insert-heading-respect-content t)
  ;; Org styling, hide markup etc.
  (org-hide-emphasis-markers t)
  (org-pretty-entities t)
  ;; Agenda styling
  (org-agenda-block-separator ?)
  (org-agenda-time-grid
   '((daily today require-timed remove-match)
     (800 1200 1800 2200)
     "  " ""))
  (org-agenda-current-time-string
   " now ")
  (org-ellipsis "")
  (org-agenda-prefix-format
   '((agenda . " %-2i  %11t  %-10(my/org-agenda-property \"project\" 10)  ")
     (todo . " %-2i  %-10(my/org-agenda-property \"project\" 10)  ")
     (tags . " %-2i  %-10(my/org-agenda-property \"project\" 10)  ")
     (search . " %-2i  %-10(my/org-agenda-property \"project\" 10)  ")))
  :config

  ;; Faces

  (custom-set-faces
   '(org-document-title ((t :height 1.5)))
   '(org-level-1 ((t :height 1.3
                     :weight bold
                     :foreground "lightgray")))
   '(org-level-2 ((t :height 1.2
                     :weight bold
                     :foreground "steelblue3")))
   '(org-level-3 ((t :height 1.1
                     :weight bold
                     :foreground "honeydew4")))
   '(org-level-4 ((t :foreground "tan3")))
   '(org-level-5 ((t :foreground "DarkSlateGray4")))
   '(org-level-6 ((t :foreground "IndianRed")))
   '(org-level-7 ((t :foreground "DarkOrchid3")))
   '(org-level-8 ((t :foreground "OliveDrab4")))
   '(org-time-grid ((t :foreground "#666633")))
   '(org-agenda-current-time ((t :foreground "#cccc99" :weight bold)))
   '(org-block-begin-line ((t :background "#2e3652")))
   '(org-block-end-line ((t :background unspecified
                            :inherit 'org-block-begin-line)))
   `(org-block ((t :background ,(if window-system "#252938" "color-236"))))
   '(org-code ((t :foreground "sea green"
                  :family "Inconsolata Nerd Font")))
   '(org-ellipsis ((t  :inherit default :box nil)))
   '(org-scheduled ((t :foreground "#88cc88" :inherit default)))
   '(org-agenda-calendar-event ((t :inherit default)))
   '(org-agenda-date ((t :foreground "#3366aa" :weight bold :height 1.1)))
   '(org-agenda-date-today ((t :foreground "#6699cc" :weight bold :slant italic :inherit org-agenda-date)))
   '(org-agenda-date-weekend ((t :foreground "#aa6633" :inherit org-agenda-date)))
   '(org-agenda-date-weekend-today ((t :foreground "#cc9966" :inherit org-agenda-date-today)))
   '(org-agenda-structure ((t :family "Noto Serif" :foreground "#cccc88" :weight bold :height 1.2))))

  (defun my/org-setup-variable-font ()
    "Override default face with variable fonts."
    (interactive)
    ;; Create a new fontset called "fontset-serif".
    (create-fontset-from-ascii-font
     (my/make-font-str "Noto Serif") nil "serif")
    (let ((fontset "fontset-serif"))
      ;; Set Japanese font to the fontset.
      (set-fontset-font fontset 'kana
                        (my/make-font-str "Noto Serif CJK JP")
                        nil 'prepend)
      (set-fontset-font fontset 'han
                        (my/make-font-str "Noto Serif CJK JP")
                        nil 'prepend)
      ;; Set the fontset to org-default face.
      (set-face-attribute 'org-default nil
                          :font (my/make-font-str "Noto Serif")
                          :fontset fontset)
      (my/set-fontset-emoji-font fontset)
      (face-remap-add-relative 'default 'org-default)))

  (defun my/org-agenda-property (property &optional width)
    "Helper function to return a string representing vaflues of the given property."
    (let ((value (string-join (org-property-values property) ",")))
      (if (and width (> (length value) width))
          (concat (substring value 0 (- width 2)) "..")
        value)))

  ;; Set up category icons using Noto Color Emoji.

  (defvar my/org-agenda-category-emoji-icon-alist
    '(("gcal" . "")
      ("task" . "")
      ("journal" . "")
      ("Holiday" . "")
      ("us-market-holidays" . "")
      ("economic-calendar" . "")))

  (defun my/emoji-icon (emoji &rest props)
    "propertize EMOJI suitable for org-agenda-category-icon-alist."
    (let ((face `(:family "Noto Color Emoji" ,@props)))
      (propertize emoji
                  'face face
                  'font-lock-face face
                  'rear-nonsticky t)))

  (defun my/org-agenda-set-category-emoji-icon ()
    "Set up category icon as per my/org-agenda-category-emoji-icon-alist."
    (dolist (entry my/org-agenda-category-emoji-icon-alist)
      (let ((category (car entry))
            (emoji (cdr entry)))
        (add-to-list 'org-agenda-category-icon-alist
                     (list category
                           (list (my/emoji-icon emoji))
                           nil nil :ascent 'center)))))

  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "C-c C-p") #'org-agenda-backward-block)
    (define-key org-agenda-mode-map (kbd "C-c C-n") #'org-agenda-forward-block)
    (my/org-agenda-set-category-emoji-icon))

  ;; Patched org-do-emphasis-faces to allow nested emphasis markers.

  (defun my/org-do-emphasis-faces (limit)
    "Run through the buffer and emphasize strings."
    (let ((quick-re (format "\\([%s]\\|^\\)\\([~=*/_+]\\)"
                            (car org-emphasis-regexp-components))))
      (catch :exit
        (while (re-search-forward quick-re limit t)
          (let* ((marker (match-string 2))
                 (verbatim? (member marker '("~" "="))))
            (when (save-excursion
                    (goto-char (match-beginning 0))
                    (and
                     ;; Do not match table hlines.
                     (not (and (equal marker "+")
                               (org-match-line
                                "[ \t]*\\(|[-+]+|?\\|\\+[-+]+\\+\\)[ \t]*$")))
                     ;; Do not match headline stars.  Do not consider
                     ;; stars of a headline as closing marker for bold
                     ;; markup either.
                     (not (and (equal marker "*")
                               (save-excursion
                                 (forward-char)
                                 (skip-chars-backward "*")
                                 (looking-at-p org-outline-regexp-bol))))
                     ;; Match full emphasis markup regexp.
                     (looking-at (if verbatim? org-verbatim-re org-emph-re))
                     ;; Do not span over paragraph boundaries.
                     (not (string-match-p org-element-paragraph-separate
                                          (match-string 2)))
                     ;; Do not span over cells in table rows.
                     (not (and (save-match-data (org-match-line "[ \t]*|"))
                               (string-match-p "|" (match-string 4))))))
              (pcase-let ((`(,_ ,face ,_) (assoc marker org-emphasis-alist))
                          (m (if org-hide-emphasis-markers 4 2)))
                (font-lock-prepend-text-property
                 (match-beginning m) (match-end m) 'face face)
                (when verbatim?
                  (org-remove-flyspell-overlays-in
                   (match-beginning 0) (match-end 0))
                  (when (and (org-fold-core-folding-spec-p 'org-link)
                             (org-fold-core-folding-spec-p 'org-link-description))
                    (org-fold-region (match-beginning 0) (match-end 0) nil 'org-link)
                    (org-fold-region (match-beginning 0) (match-end 0) nil 'org-link-description))
                  (remove-text-properties (match-beginning 2) (match-end 2)
                                          '(display t invisible t intangible t)))
                (add-text-properties (match-beginning 2) (match-end 2)
                                     '(font-lock-multiline t org-emphasis t))
                (when (and org-hide-emphasis-markers
                           (not (org-at-comment-p)))
                  (add-text-properties (match-end 4) (match-beginning 5)
                                       '(invisible t))
                  (add-text-properties (match-beginning 3) (match-end 3)
                                       '(invisible t)))
                ;; Perform recursive call to process potential nested markers.
                (save-excursion
                  (save-restriction
                    (let ((start (match-beginning 4))
                          (end (match-end 4)))
                      (narrow-to-region start end)
                      (goto-char start)
                      (org-do-emphasis-faces end))
                    )
                  )
                (throw :exit t))))))))

  (advice-add #'org-do-emphasis-faces :override #'my/org-do-emphasis-faces)

  ;; Specify which major-mode to be used for a given language of src block
  (setf (alist-get "python" org-src-lang-modes nil nil #'equal) 'python-ts)

  ;; Enable template expansion with '<' prefix.
  (require 'org-tempo)

  ;; (font-lock-add-keywords 'org-mode
  ;;                         '(("^ *\\([-]\\) "
  ;;                            (0 (prog1 ()
  ;;                                 (compose-region (match-beginning 1)
  ;;                                                 (match-end 1) ""))))))

  ;; Enable babel for languages.
  (require 'ob-shell)
  (require 'ob-java)
  (require 'ob-python)
  (require 'ob-C)
  (require 'ob-emacs-lisp)
  (require 'ob-org)
  (require 'ob-awk)
  (require 'ob-sed)
  (require 'ob-js)
  (require 'ob-css)

  ;; For Encrypting contents.
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
  ;; GPG key to use for encryption
  ;; Either the Key ID or set to nil to use symmetric encryption.
  (setq org-crypt-key (getenv "ORG_CRYPT_KEY"))

  ;; Open custom agenda view on startup.
  (defun my/org-agenda-custom-view ()
    (interactive)
    (org-agenda nil "d"))

  (add-hook 'emacs-startup-hook 'my/org-agenda-custom-view))
#+end_src

** org-bebel extensions

#+begin_src emacs-lisp
(use-package ob-go)
(use-package ob-async
  :after org
  :config
  (setq ob-async-no-async-languages-alist '("jupyter-python" "jupyter-julia")))
#+end_src

** org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :bind (("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n l" . org-roam-buffer-toggle)
         ("C-c n t a" . org-roam-tag-add)
         ("C-c n t r" . org-roam-tag-remove)
         ("C-c o p j" . my/org-roam-project-capture-journal)
         ("C-c o p t" . my/org-roam-project-capture-task)
         ("C-c o j" . my/org-roam-personal-capture-journal)
         ("C-c o t" . my/org-roam-personal-capture-task)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  :hook (after-init . (lambda ()
                        (require 'org-roam-protocol)))
  :custom
  (org-roam-node-display-template (concat "${title:*} " (propertize "${tags:30}" 'face 'org-tag)))
  (org-roam-capture-templates
   '(("c" "add a contact note" entry "* ${title}\n%?" :target
      (file+head "resources/contacts.org" "#+title: Personal Contacts\n")
      :unnarrowed t)
     ("f" "add a fleeting note" plain "%?" :target
      (file+head "fleeting/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("l" "add a literature note" plain "%?" :target
      (file+head "literature/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("r" "add a resource note" plain "%?" :target
      (file+head "resources/${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)
     ("S" "add a secure note" plain "%?" :target
      (file+head "secure/${slug}.org.gpg" "#+title: ${title}\n")
      :unnarrowed t)))
  (org-roam-capture-ref-templates
   '(("r" "add a note through org-protocol://roam-ref" plain "%?"
      :target (file+head "fleeting/${slug}.org"
                         "#+title: ${title}")
      :unnarrowed t)))
  :init
  ;; Add project files to org-agenda.
  (setq org-roam-directory "~/org/roam")

  ;; Helper function to update org-agenda-files
  (defun my/org-agenda-update-agenda-files ()
    (interactive)
    (setq org-agenda-files
          (append org-agenda-files
                  (directory-files
                   (format "%s/projects/" org-roam-directory)
                   t "\\`[^.]"))))

  (my/org-agenda-update-agenda-files)

  :config
  (unless (f-dir-p org-roam-directory)
    (mkdir org-roam-directory t))
  (org-roam-db-autosync-enable)

  ;; Helper functions for journaling and task management with Org Roam.
  ;; - "project" related org files are stored under projects/ directory.
  ;; - "personal" project is special one for personal daily matters.

  (defun my/org-roam-project-add-properties (prj &optional props)
    "A hook for org-roam-capture-new-node-hook to add project
 property and additional properties to the new file."
    (let ((pos (point)))
      (org-entry-put (point) "project" prj)
      (when props
        (dolist (entry props)
          (org-entry-put pos (car entry) (cdr entry))))))

  (defun my/org-roam-project-create-new-file (prj basename &optional props)
    "Set up a new file node for the project.
     - create a project directory under projects/ if needed.
     - setup a new file node."
    (let ((prj-dir (concat org-roam-directory "/projects/" prj)))
      (let* ((file (format "%s/%s.org" prj-dir basename))
             (title (format "projects/%s/%s" prj basename))
             (org-roam-capture-templates
              `(("d" "default - create a new node"
                 plain "%?"
                 :target (file+head ,file "#+title: ${title}\n")
                 :immediate-finish t)))
             (node (org-roam-node-create :file file :title title))
             (hook (lambda ()
                     (my/org-roam-project-add-properties prj props))))
        (unless (f-dir-p prj-dir)
          (mkdir prj-dir t))
        (add-hook 'org-roam-capture-new-node-hook hook)
        (org-roam-capture- :node node)
        (remove-hook 'org-roam-capture-new-node-hook hook))))

  (defun my/org-roam-project-read ()
    (interactive)
    (completing-read
     "Project: "
     (directory-files
      (format "%s/projects/" org-roam-directory)
      nil "\\`[^.]")
     (lambda (f) (file-directory-p (format "%s/projects/%s" org-roam-directory f))) 'confirm))

  (defun my/org-roam-project-capture (prj basename entry-str &optional props)
    "Capture new task for the selected project."
    (let* ((file (format "%s/projects/%s/%s.org"
                         org-roam-directory prj basename))
           (org-capture-templates
            `(("d" "capture a new entry to the selected project"
               entry (file+datetree ,file) ,entry-str
               :unnarrowed t :kill-buffer t))))
      (unless (file-exists-p file)
        (my/org-roam-project-create-new-file prj basename props))
      (org-capture nil "d")))

  (defun my/org-roam-project-capture-journal (prj)
    "Capture new journal for the selected project."
    (interactive (list (my/org-roam-project-read)))
    (my/org-roam-project-capture prj "journal" "* %<%H:%S> %?"))

  (defun my/org-roam-project-capture-task (prj)
    "Capture new task for the selected project."
    (interactive (list (my/org-roam-project-read)))
    (my/org-roam-project-capture prj "tasks" "* TODO %?"
                                 '(("category" . "task"))))

  (defun my/org-roam-personal-capture-journal ()
    "Capture new journal for personal project."
    (interactive)
    (my/org-roam-project-capture-journal "personal"))

  (defun my/org-roam-personal-capture-task ()
    "Capture new task for personal project."
    (interactive)
    (my/org-roam-project-capture-task "personal"))

  ;; add org-roam-directory to consult-omni-notes's source list
  (with-eval-after-load 'consult-omni-notes
    (add-to-list 'consult-omni-notes-files org-roam-directory)))
#+end_src

*** org-roam-ui
#+begin_src emacs-lisp
(use-package org-roam-ui
  :diminish
  :straight ( :host github
              :repo "org-roam/org-roam-ui"
              :branch "main"
              :files ("*.el" "out"))
  :after org-roam
  :bind ("C-c n g" . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src

*** org-roam-timestamps

add ctime and mtime properties to org-roam nodes.

#+begin_src emacs-lisp
(use-package org-roam-timestamps
  :diminish
  :after org-roam
  :custom
  (org-roam-timestamps-remember-timestamps nil)
  :config
  (org-roam-timestamps-mode))
#+end_src

** org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :hook ((org-mode . org-modern-mode)
         (org-agenda-finalize . org-modern-agenda))
  :config
  ;; borrowed from https://misohena.jp/blog/2022-08-27-fix-org-table-lines-using-org-modern-and-org-indent.html

  (defun my/org-indent--compute-prefixes-after ()
    ;; org-indent--text-line-prefixes is line-prefix at each level
    ;; This function is called after org-indent--compute-prefixes calculates the prefixes.
    (let ((prefixes org-indent--text-line-prefixes))
      ;; Fix prefix at each level.
      (dotimes (i (length prefixes))
        (let* ((space-str (aref prefixes i))
               (space-length (length space-str)))
          (when (> space-length 0)
            (aset prefixes i
                  ;; Add the text property `display (space :width i :height
                  ;; (1))`.  This displays a 1px high space instead of a blank
                  ;; character as the line prefix, correctly reflecting line
                  ;; height. Previously, lines wouldn't shrink below the height
                  ;; of the blank prefix.
                  (org-add-props
                      space-str
                      nil
                    'display (cons 'space
                                   (list :width space-length
                                         ;; (list (* space-length
                                         ;;          (frame-char-width)))
                                         :height '(1))))))))))
  ;; (advice-add #'org-indent--compute-prefixes :after
  ;;             #'my/org-indent--compute-prefixes-after))
)
#+end_src


** org-modern-indent

Disabled for now as it's not working well with some Org buffers (e.g. copilot-chat).

#+begin_src emacs-lisp
(use-package org-modern-indent
  :disabled
  :straight (org-modern-indent
             :type git
             :host github
             :repo "jdtsmith/org-modern-indent")
  :config
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+end_src

** org-cliplink

#+begin_src emacs-lisp
(use-package org-cliplink
  :custom
  (org-cliplink-transport-implementation 'curl)
  (org-cliplink-curl-transport-arguments '("--http2" "-L"))
  :bind (("C-c o L" . org-cliplink)))
#+end_src

#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox
  :custom
  (org-hugo-default-section-directory "posts"))
#+end_src

** org-download

As of 3/19/2022, this does not work with Chrome. Works well with Firefox.

#+begin_src emacs-lisp
(use-package org-download
  :hook ((org-mode . org-download-enable)
         (dired-mode . org-download-enable))
  :bind ("C-c o s" . org-download-screenshot)
  :custom
  (org-download-screenshot-method "spectacle -b -r -o %s")
  (org-download-image-dir "./images")
  (org-download-heading-lvl nil))
#+end_src

** org-appear

#+begin_src emacs-lisp
(use-package org-appear
  :straight (org-appear :type git :host github :repo "awth13/org-appear")
  :hook (org-mode . org-appear-mode))
#+end_src
** org-remoteimg

Display remote images specified by URLs inline in org-mode.

#+begin_src emacs-lisp
(use-package org-remoteimg
  :straight (org-remoteimg :type git :host github :repo "gaoDean/org-remoteimg")
  :custom
  (org-display-remote-inline-images 'cache) ;; enable caching
  )
#+end_src
** org-fragtog

#+begin_src emacs-lisp
(use-package org-fragtog
  :after org
  :straight (org-fragtog
             :type git
             :host github
             :repo "io12/org-fragtog"
             :files ("*.el"))
  :hook (org-mode . org-fragtog-mode))
#+end_src

** Latex support

#+begin_src emacs-lisp
(use-package org
  :custom
  (org-preview-latex-default-process 'dvisvgm)
  (org-latex-default-class "bxjsarticle")
  (org-latex-pdf-process '("latexmk -xelatex %f"))
  ;; (org-latex-pdf-process '("latexmk -e '$lualatex=q/lualatex %%S/' -e '$bibtex=q/bibtexu %B/' -e '$biber=q/biber --bblencoding=utf8 -u -U --output_safechars %B/' -e '$makeindex=q/upmendex -o %%D %%S/' -norc -gg -pdflua %f"))
  ;; (org-latex-pdf-process '("latexmk -e '$latex=q/uplatex -kanji=utf8 -no-guess-input-enc %%S/' -e '$bibtex=q/bibtexu %B/' -e '$biber=q/biber --bblencoding=utf8 -u -U --output_safechars %B/' -e '$makeindex=q/upmendex -o %%D %%S/' -e '$dvipdf=q/dvipdfmx -o %%D %%S/' -norc -gg -pdfdvi %f"))
  :config
  (with-eval-after-load 'ox-latex
    (add-to-list 'org-latex-classes
                 '("jlreq-article"
                   "\\ifdefined\\kanjiskip
  \\documentclass[uplatex,dvipdfmx,11pt,paper=a4]{jlreq}
\\else
  \\documentclass[11pt,paper=a4]{jlreq}
\\fi
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\usepackage{newtxtext,newtxmath}
\\ifdefined\\kanjiskip
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\hypersetup{pdfencoding=auto,colorlinks=true}
\\fi"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    (add-to-list 'org-latex-classes
                 '("jlreq-article-tate"
                   "\\ifdefined\\kanjiskip
  \\documentclass[uplatex,dvipdfmx,tate,11pt,paper=a4]{jlreq}
\\else
  \\documentclass[tate,11pt,paper=a4]{jlreq}
\\fi
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\usepackage{newtxtext,newtxmath}
\\ifdefined\\kanjiskip
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\hypersetup{pdfencoding=auto,colorlinks=true}
\\fi"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

    (add-to-list 'org-latex-classes
                 '("bxjsarticle"
                   "\\documentclass[autodetect-engine,dvi=dvipdfmx,11pt,a4paper,ja=standard]{bxjsarticle}
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\usepackage{mathcomp}
\\usepackage{newtxtext,newtxmath}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\ifdefined\\kanjiskip
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\ifdefined\\XeTeXversion
      \\hypersetup{colorlinks=true}
  \\else
    \\ifdefined\\directlua
      \\hypersetup{pdfencoding=auto,colorlinks=true}
    \\else
      \\hypersetup{unicode,colorlinks=true}
    \\fi
  \\fi
\\fi"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    )

  ;;
  ;; Adjust line prefix and vertical margin on overlay equations.
  ;;

  (defun my/org-adjust-preview-overlay (beg end image &optional imagetype)
    "Adjust latex preview images as follows:
       1) vertically align them with the text on the same line.
       2) center equations in latex environments."
    (let* ((ov (car (overlays-at beg end)))
           (ovlbp (car (overlays-at (line-beginning-position))))
           (disp (overlay-get ov 'display))
           (img (cdr disp)))
      (when (and (string-match-p "\\`\\s-*\\'" (buffer-substring
                                                (line-beginning-position) beg))
                 (string-match-p "\\(\\`\\|[\]$}]\\)\\s-*\\'"
                                 (buffer-substring end (line-end-position))))
        ;; Center equations in latex environments.
        (overlay-put ov 'before-string (propertize " " 'display
                                                   `(space :align-to (- center (0.5 . ,disp)))))

        ;; Another option: Add 4 spaces to the current indentation level.
        ;; (let* ((prefix-len (length (get-text-property beg 'line-prefix)))
        ;;        (indent-width (+ prefix-len
        ;;                         (length (buffer-substring
        ;;                                  (line-beginning-position) beg))
        ;;                         4)))
        ;;   (overlay-put ov 'before-string (propertize " " 'display
        ;;                                              `(space :width ,indent-width))))
        )

      ;; add vertical margin
      (let ((margin
             (if (string-match-p "\\([sS]erif\\|[mM]incho\\)" (face-attribute 'default :family))
                 4 1)))
        (plist-put img :margin `(0 . ,margin)))
      ))

  (advice-add 'org--make-preview-overlay :after 'my/org-adjust-preview-overlay)

  ;;
  ;; Config for latex preview which supports Japanese text in math mode with \text{}.
  ;;

  ;; Product svgs to have transparent fg/bg colors.
  (plist-put org-format-latex-options :foreground nil)
  (plist-put org-format-latex-options :background nil)

  ;; Header for xelatex supporting Japanese text.
  (setq org-format-latex-header "\\documentclass[a4paper,xelatex,ja=standard]{bxjsarticle}
\\usepackage[usenames]{color}
\[DEFAULT-PACKAGES]
\[PACKAGES]
\\usepackage{mathcomp}
\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}")

  ;; Use xelatex to produce svgs supporting Japanese text.
  (setf (alist-get 'dvisvgm org-preview-latex-process-alist)
        '( :programs
           ("xelatex" "dvisvgm")
           :description "xdv > svg" :message "you need to install the programs: latex and dvisvgm." :image-input-type "xdv" :image-output-type "svg" :image-size-adjust
           (1.7 . 1.5)
           :latex-compiler
           ("xelatex -no-pdf -interaction nonstopmode -output-directory %o %f")
           :image-converter
           ("dvisvgm %f --no-fonts --exact-bbox --scale=%S --output=%O")))
  )
#+end_src

Install cdlatex to enable some useful features. cdlatex depends on texmathp.el in AUCTeX hence AUCTeX as well.

#+begin_src emacs-lisp
(use-package cdlatex
  :hook ((LaTeX-mode . turn-on-cdlatex)
         (latex-mode . turn-on-cdlatex)
         (cdlatex-mode . my/setup-cdlatex-mode)
         (org-cdlatex-mode . my/setup-cdlatex-mode))
  :bind ( :map org-cdlatex-mode-map
          ("$" . cdlatex-dollar)
          ("(" . cdlatex-pbb)
          ("{" . cdlatex-pbb)
          ("[" . cdlatex-pbb)
          ("|" . cdlatex-pbb)
          ("<" . cdlatex-pbb))
  :custom
  (cdlatex-paired-parens "$([{")
  :config
  (defun my/setup-cdlatex-mode ()
    "Setup config suitable for cdlatex-mode and org-cdlatex-mode."
    (setq-local org-use-sub-superscripts t)
    (setq-local org-export-with-sub-superscripts t)
    (electric-pair-mode -1))
)
#+end_src

#+begin_src emacs-lisp
(use-package auctex)
#+end_src

Here is a Workaround for latex preview scaling issues that I borrow from [[https://karthinks.com/software/scaling-latex-previews-in-emacs/]].

#+begin_src emacs-lisp
(use-package org
  :hook (text-scale-mode . my/text-scale-adjust-latex-previews)
  :config
  (defun my/text-scale-adjust-latex-previews ()
    "Adjust the size of latex preview fragments when changing the buffer's text scale."
    (pcase major-mode
      ('latex-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'category)
                 'preview-overlay)
             (my/text-scale--resize-fragment ov))))
      ('org-mode
       (dolist (ov (overlays-in (point-min) (point-max)))
         (if (eq (overlay-get ov 'org-overlay-type)
                 'org-latex-overlay)
             (my/text-scale--resize-fragment ov))))))

  (defun my/text-scale--resize-fragment (ov)
    (overlay-put
     ov 'display
     (cons 'image
           (plist-put
            (cdr (overlay-get ov 'display))
            :scale (+ 1.0 (* 0.25 text-scale-mode-amount))))))
  )
#+end_src

** Citation

Citar provides a rich UI frontend for org-cite. citar-org-roam provides more integration with org-roam.

#+begin_src emacs-lisp
(use-package citar
  :no-require
  :bind ("C-c n n" . citar-create-note)
  :hook (org-mode . citar-capf-setup)
  :custom
  (require 'bibtex)
  (org-cite-global-bibliography '("~/lib/bib/references.bib"))
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-notes-paths '((concat org-roam-directory "/literature")))
  (citar-bibliography org-cite-global-bibliography))

(use-package citar-embark
  :after (citar embark)
  :no-require
  :config (citar-embark-mode))

(use-package citar-org-roam
  :diminish
  :after (citar org-roam)
  :custom
  (citar-org-roam-subdir "literature")
  (citar-org-roam-note-title-template "[${author}] ${title}")
  (citar-org-roam-capture-template-key "n")
  :config
  (add-to-list
   'org-roam-capture-templates
   '("n" "add literature note through Citar" plain
     "%?"
     :target
     (file+head
      "%(expand-file-name (or citar-org-roam-subdir \"\") org-roam-directory)/${citar-citekey}.org"
      "#+title: ${note-title}\n#+author: ${citar-author}\n#+released_on: ${citar-date}\n\n")
     :unnarrowed t) 'append)
  (citar-org-roam-mode))
#+end_src


** org-gcal

#+begin_src emacs-lisp
(use-package org-gcal
  :straight (:type git :host github :repo "kidd/org-gcal.el")
  :commands (org-gcal-fetch org-gcal-reload-client-id-secret)
  :init
  (setq org-agenda-files (append
                          org-agenda-files
                          '("~/org/gcal.org"
                            "~/org/us-market-holidays.org")))
  (defun my/org-gcal-setup ()
    (interactive)
    (let* ((authinfo (car (auth-source-search :host "org-gcal")))
           (client (plist-get authinfo :client))
           (secret (auth-source-pick-first-password :host "org-gcal"))
           (calendar (plist-get authinfo :calendar)))
      (setq org-gcal-client-id client)
      (setq org-gcal-client-secret secret)
      (setq org-gcal-fetch-file-alist
            `((,calendar . "~/org/gcal.org")
              ("monex.co.jp_hkslb9v1kj95se5r8ag2mms4k8@group.calendar.google.com" . "~/org/us-market-holidays.org")))
      (org-gcal-reload-client-id-secret))))
#+end_src

** org-super-agenda

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after org-agenda
  :config
  ;; Faces
  (custom-set-faces
   '(org-super-agenda-header ((t :foreground "#cc8888" :box (:line-width 1 :color "#000000")) :weight bold)))

  (org-super-agenda-mode))
#+end_src
* Docker / Containers

** Docker Tramp
#+begin_src emacs-lisp
(use-package docker-tramp
  :disabled
  :after tramp
  :custom
  (docker-tramp-use-names t)
  (docker-tramp-docker-executable "podman"))
#+end_src
* EXWM

#+begin_src emacs-lisp
(use-package-if-exwm
 exwm
 :config
 (require 'exwm-config)

 ;; Allow non-floating resizing with mouse.
 (setq window-divider-default-bottom-width 2
       window-divider-default-right-width 2)
 (window-divider-mode)

 (setq exwm-workspace-number 1)

 ;; Try to isolate EXWM buffers per frame.
 (setq exwm-workspace-show-all-buffers nil)
 (setq exwm-layout-show-all-buffers nil)

 ;; Enable char-mode by default.
 (setq exwm-manage-configurations '((t char-mode t)))

 ;; Rename buffer to window title.
 (add-hook 'exwm-update-title-hook
           #'(lambda () (exwm-workspace-rename-buffer exwm-title)))
 ;; (add-hook 'exwm-update-class-hook
 ;;           #'(lambda () (exwm-workspace-rename-buffer exwm-class-name)))

 ;; Do not show mode-line for floating windows.
 (add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
 (add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

 ;; Make sure that modeline is updated for the active window.
 (add-hook 'exwm-workspace-switch-hook
           #'(lambda ()
               (run-with-idle-timer 0.1 nil
                                    #'my/exwm-set-input-focus)))

 (defun my/exwm-layout-toggle-fullscreen-or-single-window ()
   (interactive)
   (if (derived-mode-p 'exwm-mode)
       (call-interactively 'exwm-layout-toggle-fullscreen)
     (require 'functions)
     (my/toggle-single-window)))

 (defun my/exwm-set-input-focus ()
   "Workaround for losing input focus after switch-to-next/prev-buffer"
   (interactive)
   (when (and (eq window-system 'x)
              (not (active-minibuffer-window)))
     (let ((window (selected-window)))
       (select-window window)
       (x-focus-frame (window-frame window))
       (exwm-input--set-focus
        (exwm--buffer->id (window-buffer window))))))

 (defvar my/single-window--last-configuration nil
   "Last window configuration before calling `delete-other-windows'.")
 (defun my/toggle-single-window ()
   "Un-maximize current window.
    If multiple windows are active, save window configuration and
    delete other windows.  If only one window is active and a window
    configuration was previously save, restore that configuration."
   (interactive)
   (if (= (count-windows) 1)
       (when my/single-window--last-configuration
         (set-window-configuration my/single-window--last-configuration))
     (setq my/single-window--last-configuration (current-window-configuration))
     (delete-other-windows)))

 (defun my/switch-to-last-buffer ()
   "Switch to last open buffer in current window."
   (interactive)
   (let* ((b (other-buffer (current-buffer) 1))
          (w (get-buffer-window b)))
     (if w (select-window w)
       (progn
         (switch-to-buffer b)
         (my/exwm-set-input-focus)))))

 ;; Add a new EXWM window to the current perspective.
 (when (and (featurep 'persp-mode) persp-mode)
   (add-hook 'exwm-manage-finish-hook
             #'(lambda () (persp-add-buffer
                           (current-buffer) (get-current-persp)))))

 ;; === Key bindings working in line-mode. ===

 ;; Clear key bindings for line-mode to unmap C-c.
 (setq exwm-mode-map (make-sparse-keymap))

 ;; Make C-c a prefix key.
 (push ?\C-c exwm-input-prefix-keys)
 ;; Send C-c by typing C-c C-c.
 (define-key exwm-mode-map (kbd "C-c C-c") #'(lambda () (interactive)
                                               (exwm-input--fake-key 3)))

 ;; Send C-x (cut) by typing C-x C-x.
 (define-key exwm-mode-map (kbd "C-x C-x") #'(lambda () (interactive)
                                               (exwm-input--fake-key 24)))
 ;; Make C-z a prefix key.
 (push ?\C-z exwm-input-prefix-keys)
 ;; Send C-z (undo) by typing C-z C-z.
 (defun my/send-ctrl-z () (interactive) (exwm-input--fake-key 26))
 (define-key exwm-mode-map (kbd "C-z C-z") #'my/send-ctrl-z)
 (when (eq (lookup-key (current-global-map) (kbd "C-z")) 'suspend-frame)
   (global-set-key (kbd "C-z") #'my/send-ctrl-z))

 ;; Make C-q a quoted insert.
 (push ?\C-q exwm-input-prefix-keys)
 (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

 ;; === Key bindings working in both char-mode and line-mode. ===

 (exwm-input-set-key (kbd "s-'") #'exwm-input-toggle-keyboard)

 (exwm-input-set-key (kbd "s-h") #'windmove-left)
 (exwm-input-set-key (kbd "s-j") #'windmove-down)
 (exwm-input-set-key (kbd "s-k") #'windmove-up)
 (exwm-input-set-key (kbd "s-l") #'windmove-right)

 (exwm-input-set-key (kbd "s-`") #'my/switch-to-last-buffer)
 (exwm-input-set-key (kbd "s-<return>")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "lxterminal")))
 (exwm-input-set-key (kbd "s-b")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "google-chrome")))
 (exwm-input-set-key (kbd "s-B")
                     #'(lambda ()
                         (interactive)
                         (split-window-right)
                         (redisplay)
                         (windmove-right)
                         (start-process "" nil "google-chrome")))
 (exwm-input-set-key (kbd "s-L")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil
                                        "xscreensaver-command" "-lock")))
 (exwm-input-set-key (kbd "s-S")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil
                                        "gnome-screenshot" "-i")))
 ;; 's-r': Reset
 (exwm-input-set-key (kbd "s-r") #'exwm-reset)
 ;; 's-w': Move window to other workspace
 (exwm-input-set-key (kbd "s-w") #'exwm-workspace-move-window)
 ;; 's-<tab>': Switch to next workspace
 (defun my/exwm-cycle-workspace ()
   "Cycle workspace to the next one."
   (interactive)
   (let ((next-idx (1+ exwm-workspace-current-index)))
     (if (>= next-idx (length exwm-workspace--list))
         (setq next-idx 0))
     (exwm-workspace-switch next-idx)))
 (exwm-input-set-key (kbd "s-<tab>") #'my/exwm-cycle-workspace)

 ;; 's-N': Switch to Nth workspace
 (dotimes (i 10)
   (exwm-input-set-key (kbd (format "s-%d" i))
                       `(lambda ()
                          (interactive)
                          (exwm-workspace-switch-create ,i)
                          (my/exwm-set-input-focus))))

 ;; 's-!': Launch application
 (exwm-input-set-key (kbd "s-!")
                     #'(lambda (command)
                         (interactive (list (read-shell-command "$ ")))
                         (start-process-shell-command command nil command)))

 (exwm-input-set-key (kbd "s-n") #'(lambda ()
                                     (interactive)
                                     (switch-to-next-buffer)
                                     (my/exwm-set-input-focus)))
 (exwm-input-set-key (kbd "s-p")  #'(lambda ()
                                      (interactive)
                                      (switch-to-prev-buffer)
                                      (my/exwm-set-input-focus)))
 (exwm-input-set-key (kbd "s-C") #'kill-buffer-and-window)
 (exwm-input-set-key (kbd "s-F") #'exwm-floating-toggle-floating)
 (exwm-input-set-key (kbd "s-f")
                     #'my/exwm-layout-toggle-fullscreen-or-single-window)

 (exwm-input-set-key (kbd "s-m") #'consult-buffer)

 (exwm-input-set-key (kbd "s-o") #'find-file-other-window)

 (defvar my/exwm-workspace-previous-index 0
   "The previous active workspace index.")
 (defun my/exwm-workspace--current-to-previous-index
     (frame-or-index &optional force)
   "Save the current active workspace index."
   (if (numberp frame-or-index)
       (setq my/exwm-workspace-previous-index exwm-workspace-current-index)))
 (add-hook 'exwm-init-hook
           #'(lambda ()
               (advice-add 'exwm-workspace-switch :before
                           #'my/exwm-workspace--current-to-previous-index)))
 (defun my/exwm-workspace-switch-to-previous ()
   (interactive)
   "Switch to the previous active workspace."
   (let ((index my/exwm-workspace-previous-index))
     (exwm-workspace-switch index)))

 (exwm-input-set-key (kbd "s-;") #'my/exwm-workspace-switch-to-previous)
 (exwm-input-set-key (kbd "s-N") #'(lambda () (interactive)
                                     (switch-to-buffer-other-frame
                                      (get-buffer-create "*scratch*"))))
 (exwm-input-set-key (kbd "s-s") #'my/get-vterm)
 (exwm-input-set-key (kbd "s-e") #'my/get-eshell)
 ;; Note that s-t does not work in exwm mode for some unknown reason.
 (exwm-input-set-key (kbd "s-t") #'my/get-term)

 ;; Other configurations
 (exwm-config-misc)

 ;; systemtray
 (when (member (getenv "use_exwm_systray") '("1" "yes"))
   (require 'exwm-systemtray)
   (exwm-systemtray-enable))

 ;; xrandr
 (when (getenv "CHROME_REMOTE_DESKTOP_SESSION")
   (require 'exwm-randr)
   (setq exwm-randr-workspace-output-plist '(0 "Screen"))
   (exwm-randr-enable))

 ;; Enable EXWM at the end of the initialization.
 (with-eval-after-load "emacs-init"
   (exwm-enable))

 (defun my/inactive-exwm-buffer-p (buf)
   "Return t if BUF is an inactive exwm buffer."
   (let ((window (get-buffer-window buf t)))
     (and
      (null window)
      (not (string-prefix-p " " (buffer-name buf)))
      (with-current-buffer buf
        (derived-mode-p 'exwm-mode)))))

 (defun my/get-inactive-exwm-buffers ()
   "Return a list of inactive EXWM buffers or nil if none."
   (cl-remove-if-not #'my/inactive-exwm-buffer-p
                     (buffer-list)))

 (defun my/get-inactive-exwm-buffer-names ()
   "Return a list of inactive EXWM buffers or nil if none."
   (mapcar
    #'buffer-name
    (my/get-inactive-exwm-buffers)))

 ;; Select inactive EXWM buffers with Vertico/Consult.
 (defvar my/consult-source-inactive-exwm-buffer
   `(:name "EXWM"
           :hidden t
           :narrow ?x
           :category buffer
           :face consult-buffer
           :history  buffer-name-history
           :state ,#'consult--buffer-state
           :items
           ,(lambda () (consult--buffer-query :sort 'visibility
                                              :as #'buffer-name
                                              :predicate
                                              #'my/inactive-exwm-buffer-p
                                              ))))

 (setq my/consult-exwm-buffer-source
       (list
        `(:hidden nil :narrow ?x ,@my/consult-source-inactive-exwm-buffer)))

 (defun my/consult-inactive-exwm-buffers ()
   (interactive)
   (let ((buflist (my/get-inactive-exwm-buffers)))
     (cl-case (length buflist)
       (0 (message "No inactive EXWM buffers found"))
       (1 (switch-to-buffer (car buflist))
          (my/exwm-set-input-focus))
       (t (consult-buffer my/consult-exwm-buffer-source)))))

 ;; Override s-i.
 (exwm-input-set-key (kbd "s-i") #'my/consult-inactive-exwm-buffers)
 )
#+end_src

* Device Control and Management

** PulseAudio

Disabled atm as new distro is adopting pipewire.

#+begin_src emacs-lisp
(use-package-if-exwm
 pulseaudio-control
 :requires exwm
 :config
 (push 'XF86AudioMute exwm-input-prefix-keys)
 (push 'XF86AudioLowerVolume exwm-input-prefix-keys)
 (push 'XF86AudioRaiseVolume exwm-input-prefix-keys)

 (exwm-input-set-key (kbd "<XF86AudioRaiseVolume>") #'pulseaudio-control-increase-volume)
 (exwm-input-set-key (kbd "<XF86AudioLowerVolume>") #'pulseaudio-control-decrease-volume)
 (exwm-input-set-key (kbd "<XF86AudioMute>") #'pulseaudio-control-toggle-current-sink-mute)
 )
#+end_src

** Brightness

#+begin_src emacs-lisp
(when-use-exwm
 (push 'XF86MonBrightnessDown exwm-input-prefix-keys)
 (push 'XF86MonBrightnessUp exwm-input-prefix-keys)

 (exwm-input-set-key (kbd "<XF86MonBrightnessDown>")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "light" "-U" "10")))

 (exwm-input-set-key (kbd "<XF86MonBrightnessUp>")
                     #'(lambda ()
                         (interactive)
                         (start-process "" nil "light" "-A" "10")))
 )
#+end_src

* LLM

** Common Settings

Macros to retrive API keys for LLM servce providers.

#+begin_src emacs-lisp
(defun my/get-gemini-apikey ()
  (auth-source-pick-first-password :host "gemini-apikey"))

(defun my/get-groq-apikey ()
  (auth-source-pick-first-password :host "groq-apikey"))

(defun my/get-sambanova-apikey ()
  (auth-source-pick-first-password :host "sambanova-apikey"))

(defun my/get-cohere-apikey ()
  (auth-source-pick-first-password :host "cohere-apikey"))

(defun my/get-hf-apikey ()
  (auth-source-pick-first-password :host "huggingface-apikey"))

(defun my/get-anthropic-apikey ()
  (auth-source-pick-first-password :host "api.anthropic.com"))

(defun my/get-openrouter-apikey ()
  (auth-source-pick-first-password :host "openrouter-apikey"))

(defun my/get-deepseek-apikey ()
  (auth-source-pick-first-password :host "deepseek-apikey"))
#+end_src

** Ellama - Emacs client for ollama

#+begin_src emacs-lisp
(use-package ellama
  :bind ("C-c m" . ellama-chat)
  :bind-keymap
  ("C-c L" . ellama-command-map)
  :custom
  (llm-warn-on-nonfree nil)
  (ellama-fill-paragraphs nil)
  (ellama-long-lines-length 1024)
  :config
  ;; setup key bindings
  (setopt ellama-keymap-prefix "C-c L")
  ;; language you want ellama to translate to
  (setopt ellama-language "Japanese")
  ;; could be llm-openai for example
  ;; (require 'llm-ollama)
  (require 'llm-openai)

  ;; custom macro for local OpenAI compatible server
  (defmacro my/make-llm-local-server (&rest args)
    `(make-llm-openai-compatible
      :url "http://localhost:8000/v1/"
      :embedding-model "nomic-embed-text"
      ,@args))

  (defmacro my/make-llm-groq (&rest args)
    `(make-llm-openai-compatible
      :url "https://api.groq.com/openai/v1/"
      :key (my/get-groq-apikey)
      ,@args))

  (defmacro my/make-llm-sambanova (&rest args)
    `(make-llm-openai-compatible
      :url "https://api.sambanova.ai/v1/"
      :key (my/get-sambanova-apikey)
      ,@args))

  (defmacro my/make-llm-cohere (&rest args)
    `(make-llm-openai-compatible
      :url "http://localhost:6600/v1/"
      :key (my/get-cohere-apikey)
      ,@args))

  (defmacro my/make-llm-hf (&rest args)
    `(make-llm-openai-compatible
      :url "https://api-inference.huggingface.co/v1/"
      :key (my/get-hf-apikey)
      ,@args))

  (require 'llm-gemini)
  (defmacro my/make-llm-gemini (&rest args)
    `(make-llm-gemini
      :key (my/get-gemini-apikey)
      ,@args))

  ;; (setopt ellama-provider
  ;;         (my/make-llm-local-server
  ;;          :chat-model "deepseek-coder-v2:latest"))

  (setopt ellama-provider (my/make-llm-gemini
                           :chat-model "gemini-2.0-flash-exp"))
  ;; Predefined llm providers for interactive switching.
  ;; You shouldn't add ollama providers here - it can be selected interactively
  ;; without it. It is just example.
  (setopt ellama-providers
          '(("gemini-flash" . (my/make-llm-gemini
                               :chat-model "gemini-2.0-flash-exp"))
            ("gemini-flash-thinking" . (my/make-llm-gemini
                                        :chat-model "gemini-2.0-flash-thinking-exp"))
            ("gemini-pro" . (my/make-llm-gemini
                               :chat-model "gemini-2.0-pro-exp"))
            ("groq-llama-3.3-specdec" . (my/make-llm-groq
                                         :chat-model "llama-3.3-70b-specdec"))
            ("groq-llama-3.3-versatile" . (my/make-llm-groq
                                           :chat-model "llama-3.3-70b-versatile"))
            ("groq-mixtral-8x7b" . (my/make-llm-groq
                                    :chat-model "mixtral-8x7b-32768"))
            ("sambanova-llama-3.1" . (my/make-llm-sambanova
                                      :chat-model "Meta-Llama-3.1-405B-Instruct"))
            ("sambanova-qwen-2.5" . (my/make-llm-sambanova
                                     :chat-model "Qwen2.5-72B-Instruct"))
            ("cohere-command-r-plus" . (my/make-llm-cohere
                                        :chat-model "command-r-plus"))
            ("hf-qwen2.5-coder" . (my/make-llm-hf
                                   :chat-model "Qwen/Qwen2.5-Coder-32B-Instruct"))

            ("ezo-common" . (my/make-llm-local-server
                             :chat-model "ezo-common"))
            ("ezo-humanities" . (my/make-llm-local-server
                                 :chat-model "ezo-humanities"))
            ("elyza" . (my/make-llm-local-server
                        :chat-model "elyza"))))

  ;; Change AI's nickname as per the selected model.
  (defun my/ellama-update-assistant-nick ()
    (setq ellama-assistant-nick
          (format-message
           "AI (%s)"
           (capitalize (cl-struct-slot-value (type-of ellama-provider)
                                             'chat-model ellama-provider)))))

  (advice-add #'ellama-provider-select :after #'my/ellama-update-assistant-nick)
  (my/ellama-update-assistant-nick)

  ;; Disabled ellama-naming-provider and ellama-translation-provider to take
  ;; into account the situation where no local LLM server is running on the
  ;; host.

  ;; ;; Naming new sessions with llm
  ;; (setopt ellama-naming-provider
  ;;         (my/make-llm-local-server
  ;;          :chat-model "elyza"
  ;;          :default-chat-non-standard-params '(("stop" . ("\n")))))
  ;; (setopt ellama-naming-scheme 'ellama-generate-name-by-llm)
  ;; ;; Translation llm provider
  ;; (setopt ellama-translation-provider (my/make-llm-local-server
  ;;                                      :chat-model "ezo-common"))
  )
#+end_src

** gptel

#+begin_src emacs-lisp
(use-package gptel
  :commands (gptel gptel-send gptel-menu)
  :custom
  (gptel-default-mode #'org-mode)
  :config
  (when (fboundp 'org-element-lineage-map)
    (setq gptel-org-branching-context t))

  (add-hook 'gptel-post-stream-hook 'gptel-auto-scroll)
  (add-hook 'gptel-post-response-functions 'gptel-end-of-response)

  ;; Define backends.

  (gptel-make-gemini "Gemini"
    :key #'my/get-gemini-apikey
    :models '(gemini-2.0-flash-exp
              gemini-2.0-flash-thinking-exp
              gemini-2.0-pro-exp)
    :stream t)

  (gptel-make-openai "Groq"
    :host "api.groq.com"
    :endpoint "/openai/v1/chat/completions"
    :stream t
    :key #'my/get-groq-apikey
    :models '(llama-3.3-70b-specdec
              llama-3.3-70b-versatile))

  (gptel-make-ollama "Ollama"
    :host "localhost:11434"
    :stream t
    :models '(qwen2.5-coder:latest
              deepseek-coder-v2:latest
              ezo-common-gemma2:9b
              mistral-nemo-instruct:latest
              llama3.1:latest))

  (gptel-make-openai "SambaNova"
    :host "api.sambanova.ai"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-sambanova-apikey
    :models '(Meta-Llama-3.1-405B-Instruct
              Qwen2.5-72B-Instruct))

  (gptel-make-openai "Cohere"
    :host "localhost:6600"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-cohere-apikey
    :models '(command-r-plus
              command-r-plus-08-2024))

  (gptel-make-openai "HuggingFace"
    :host "api-inference.huggingface.co"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-hf-apikey
    :models '(Qwen/Qwen2.5-Coder-32B-Instruct
              Qwen/Qwen2.5-72B-Instruct))

  (gptel-make-anthropic "Anthropic"
    :stream t
    :key #'my/get-anthropic-apikey
    :models '(claude-3.5-sonnet-20241022))

  (gptel-make-openai "DeepSeek"
    :host "api.deepseek.com"
    :endpoint "/v1/chat/completions"
    :stream t
    :key #'my/get-deepseek-apikey
    :models '(deepseek-chat
              deepseek-reasoner))

  (gptel-make-openai "OpenRouter"
    :host "openrouter.ai"
    :endpoint "/api/v1/chat/completions"
    :stream t
    :key #'my/get-openrouter-apikey
    :models '(openai/o1-preview))

  (defun my/gptel-get-backend (key)
    (alist-get key gptel--known-backends nil nil 'string=))

  ;; Set default backend.
  (setq gptel-backend (my/gptel-get-backend "Gemini"))
  (setq gptel-model 'gemini-2.0-flash-exp)
  )
#+end_src

** org-ai

Use groq as the LLM service.

#+begin_src emacs-lisp
(use-package org-ai
  :diminish
  :after org
  :straight (org-ai :type git :host github :repo "rksm/org-ai"
                    :local-repo "org-ai"
                    :files ("*.el" "README.md" "snippets"))
  :commands (org-ai-mode
             org-ai-global-mode)
  :hook (org-mode . org-ai-mode)
  :config
  ;; Use Llama 3.1 70B by Groq as the backend. The API key is in authinfo.
  (setq org-ai-default-chat-model "")
  (setq org-ai-openai-chat-endpoint "https://openrouter.ai/api/v1/chat/completions")
  (setq org-ai-openai-completion-endpoint "https://openrouter.ai/api/v1/completions")

  (org-ai-install-yasnippets)

  ;; remove C-c r from org-ai-mode-map
  (keymap-unset org-ai-mode-map "C-c r" t)
  )
#+end_src

* Internet Information and Media Tools

** elfeed

#+begin_src emacs-lisp
(use-package elfeed
  :bind (("C-c F" . elfeed)
         ("<f12>" . elfeed))
  :bind ( :map elfeed-search-mode-map
          ("<mouse-1>" . elfeed-search-show-entry)
          ("b" . my/elfeed-search-browse-url-with-eww)
          ("B" . elfeed-search-browse-url)
          :map elfeed-show-mode-map
          ("j" . scroll-up-command)
          ("k" . scroll-down-command)
          ("v" . elfeed-show-visit)
          ("b" . my/elfeed-show-visit-with-eww)
          ("B" . elfeed-show-visit)
          ("RET" . my/elfeed-show-visit-with-eww))
  :hook (elfeed-show-mode . visual-line-mode)
  :custom
  (elfeed-search-remain-on-entry t)  ;; for navigation from split entry pane.
  :config
  ;; Set external program to retrieve a URL.
  (setq my/eww-retrieve-command '("curl" "--http2" "-L" "--user-agent" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"))
  ;; (setq my/eww-retrieve-command
  ;;       '("google-chrome" "--headless" "--dump-dom" "--user-agent=Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"))

  ;; Show an feed entry in a split pane using display-buffer-alist.
  (setq elfeed-show-entry-switch #'pop-to-buffer)
  (add-to-list 'display-buffer-alist
               '("\\`\\*elfeed-entry\\*"
                 (display-buffer-reuse-mode-window display-buffer-in-direction)
                 (direction . right)
                 (window-width . 0.5)))

  ;; Close the window when q is pressed in the elfeed-entry buffer.
  (advice-add #'elfeed-kill-buffer :after
              (lambda () (delete-window)))
  ;; Close the other windows when elfeed-entry buffer is opened.
  (advice-add #'elfeed-search-show-entry :before
              (lambda (entry) (delete-other-windows)))

  (defun my/elfeed-search-browse-url-with-eww (entry)
    (interactive (list (elfeed-search-selected :ignore-region)))
    (let ((browse-url-browser-function #'eww-browse-url)
          (eww-retrieve-command my/eww-retrieve-command))
      (elfeed-search-show-entry entry)
      (elfeed-show-visit)))

  (defun my/elfeed-show-visit-with-eww (&optional use-generic-p)
    (interactive "P")
    (let ((browse-url-browser-function #'eww-browse-url)
          (eww-retrieve-command my/eww-retrieve-command))
      (elfeed-show-visit use-generic-p)))
  )

(use-package elfeed-goodies
  :disabled
  :after elfeed
  :custom
  (elfeed-goodies/feed-source-column-width 20)
  (elfeed-goodies/tag-column-width 20)
  (elfeed-goodies/entry-pane-position 'right)
  (elfeed-goodies/entry-pane-size 0.5)
  :config
  (elfeed-goodies/setup))

(use-package elfeed-org
  :after (elfeed org)
  :custom
  (rmh-elfeed-org-files (list "~/.elfeed.org"))
  :config
  (elfeed-org))
#+end_src

*** elfeed-tube

#+begin_src emacs-lisp
(use-package elfeed-tube
  :after elfeed
  :commands (elfeed-tube-add-feeds)
  :custom
  (elfeed-tube-auto-save-p t)
  (elfeed-tube-auto-fetch-p t)
  (elfeed-tube-captions-languages
   '("ja" "japanese" "japanese (auto generated)" "en" "english" "english (auto generated)"))
  :bind (:map elfeed-show-mode-map
              ("F" . elfeed-tube-fetch)
              ([remap save-buffer] . elfeed-tube-save)
              :map elfeed-search-mode-map
              ("F" . elfeed-tube-fetch)
              ([remap save-buffer] . elfeed-tube-save))
  :config
  (elfeed-tube-setup)
  )

(use-package elfeed-tube-mpv
  :after elfeed
  :bind (:map elfeed-show-mode-map
              ("C-c C-f" . elfeed-tube-mpv-follow-mode)
              ("C-c C-w" . elfeed-tube-mpv-where)))
#+end_src

** engine-mode
#+begin_src emacs-lisp
(use-package engine-mode
  :config
  (defengine amazon-jp
    "https://amazon.co.jp/s?k=%s"
    :keybinding "a")

  (defengine duckduckgo
    "https://duckduckgo.com/?q=%s"
    :term-transformation-hook (lambda (term) (if current-prefix-arg
                                                 (concat "\"" term "\"")
                                               term)))

  (defengine deepl
    "https://www.deepl.com/ja/translator#en/ja/%s"
    :keybinding "d")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s")

  (defengine google
    "https://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :term-transformation-hook (lambda (term) (if current-prefix-arg
                                                 (concat "\"" term "\"")
                                               term))
    :keybinding "g")

  (defengine google-images
    "https://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s")

  (defengine google-maps
    "https://maps.google.com/maps?q=%s"
    :docstring "Mappin' it up."
    :keybinding "m")

  (defengine google-translate
    "https://translate.google.com/?sl=auto&tl=ja&text=%s&op=translate"
    :keybinding "t")

  (defengine twitter
    "https://twitter.com/search?q=%s"
    :keybinding "x")

  (defengine wikipedia
    "https://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w"
    :docstring "Searchin' the wikis.")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine wolfram-alpha
    "https://www.wolframalpha.com/input/?i=%s")

  (defengine youtube
    "https://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y")

  (engine-mode t))
#+end_src

** go-translate

#+begin_src emacs-lisp
(use-package plz)
(use-package go-translate
  :bind (("C-c y" . gt-do-translate))
  :config
  (setq gt-langs '(en ja))

  (defun my/gt-strip-linebreak (ts)
    (with-slots (text) ts
      (setf text
            (mapcar (lambda (s) (string-replace "\n" " " s)) text))
      ))

  (setq gt-chatgpt-key (my/get-groq-apikey))
  (setq my/gt-google-translate
        (gt-translator :taker (gt-taker
                               :langs '(en ja)
                               :text 'word
                               :then #'my/gt-strip-linebreak)
                       :engines (gt-google-engine)
                       :render (gt-buffer-render
                                :buffer-name "*gt-result*"
                                :window-config '((display-buffer-at-bottom))
                                :then (lambda (_) (pop-to-buffer "*gt-result*"))))
        my/gt-groq-llama-3.1
        (gt-translator :taker (gt-taker
                               :langs '(en ja)
                               :text 'sentence
                               :then #'my/gt-strip-linebreak)
                       :engines (gt-chatgpt-engine
                                 :host "https://api.groq.com/openai"
                                 :model "llama-3.1-70b-versatile")
                       :render (gt-buffer-render
                                :buffer-name "*gt-result*"
                                :window-config '((display-buffer-at-bottom))
                                :then (lambda (_) (pop-to-buffer "*gt-result*")))))

  (setq gt-preset-translators
        `((google-translate . ,my/gt-google-translate)
          (groq-llama-3.1 . ,my/gt-groq-llama-3.1)))

  ;; Add key bindings for the render buffer.
  (advice-add #'gt-keybinds :after
              (lambda (fn &rest args)
                (gt-buffer-render-key ("SPC")  #'scroll-up-command)
                (gt-buffer-render-key ("N")  #'scroll-up-command)
                (gt-buffer-render-key ("S-SPC")  #'scroll-up-command)
                (gt-buffer-render-key ("P")  #'scroll-down-command)))
  )
#+end_src

** consult-omni

#+begin_src emacs-lisp
;; consult-omni depends on browser-hist.
(use-package browser-hist
  :config
  (setq browser-hist-default-browser 'chrome)
  :commands (browser-hist-search))

(use-package consult-gh
  :straight (consult-gh :type git :host github :repo "armindarvish/consult-gh")
  :commands (consult-gh-search-repos))

(use-package consult-omni
  :straight (consult-omni :type git
                          :host github
                          :repo "armindarvish/consult-omni"
                          :files (:defaults "sources/*.el"))
  :bind ( :map my/search-map
          ("/" . consult-omni-multi)
          ("a" . consult-omni-apps)
          ("e" . consult-omni-elfeed)
          ("g" . consult-omni-google)
          ("G" . consult-omni-github)
          ("l" . consult-omni-locate)
          ("n" . consult-omni-notes-search)
          ("s" . consult-omni-multi-static)
          ("w" . consult-omni-wikipedia)
          ("y" . consult-omni-youtube))
  :custom
  ;; General settings that apply to all sources
  (consult-omni-show-preview t) ;;; show previews
  (consult-omni-preview-key "C-o") ;;; set the preview key to C-o
  (consult-omni-default-count 20)  ;; get search results up to 20
  :config
  ;; Load Sources Core code
  (require 'consult-omni-sources)
  (require 'consult-omni-apps)
  (require 'consult-omni-bing)
  (require 'consult-omni-browser-history)
  (require 'consult-omni-elfeed)
  (require 'consult-omni-invidious)
  (require 'consult-omni-notes)
  (require 'consult-omni-gh)
  (require 'consult-omni-google)
  (require 'consult-omni-google-autosuggest)
  (require 'consult-omni-locate)
  (require 'consult-omni-wikipedia)
  (require 'consult-omni-youtube)

  ;; Load Embark Actions
  (require 'consult-omni-embark)

  ;; Either load all source modules or a selected list

  ;;; Select a list of modules you want to aload, otherwise all sources all laoded
  ;; (setq consult-omni-sources-modules-to-load (list 'consult-omni-wkipedia 'consult-omni-notes))
  (consult-omni-sources-load-modules)
  ;;; set multiple sources for consult-omni-multi command. Change these lists as
  ;;; needed for different interactive commands. Keep in mind that each source
  ;;; has to be a key in `consult-omni-sources-alist'.
  (setq consult-omni-multi-sources '(;; "calc"
                                     ;; "File"
                                     ;; "Buffer"
                                     ;; "Bookmark"
                                     "Apps"
                                     ;; "gptel"
                                     ;; "Brave"
                                     ;; "Dictionary"
                                     "Org Agenda"
                                     "locate"
                                     "Notes Search"
                                     "Browser History"
                                     "Google"
                                     "Wikipedia"
                                     "elfeed"
                                     ;; "mu4e"
                                     ;; "buffers text search"
                                     "GitHub"
                                     "YouTube"
                                     ;; "Invidious"
                                     ))

  ;; Per source customization

  ;;; Set API KEYs. It is recommended to use a function that returns the string for better security.
  (setq consult-omni-google-customsearch-key
        (auth-source-pick-first-password :host "google-cse-apikey"))
  (setq consult-omni-google-customsearch-cx
        (auth-source-pick-first-password :host "google-cse-id"))
  (setq consult-omni-youtube-search-key
        (auth-source-pick-first-password :host "google-youtube-apikey"))

  ;; (setq consult-omni-brave-api-key "YOUR-BRAVE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-stackexchange-api-key "YOUR-STACKEXCHANGE-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-pubmed-api-key "YOUR-PUBMED-API-KEY-OR-FUNCTION")
  ;; (setq consult-omni-openai-api-key "YOUR-OPENAI-API-KEY-OR-FUNCTION")

  ;;; Pick you favorite autosuggest command.
  (setq consult-omni-default-autosuggest-command #'consult-omni-google-autosuggest)

  ;;; Set your shorthand favorite interactive command
  (setq consult-omni-default-interactive-command #'consult-omni-multi)
  )
#+end_src

* Post Init Config

Load postinit.org if exists.

#+begin_src emacs-lisp
(let ((postinit-file (expand-file-name "~/.emacs.d/postinit.org")))
  (when (file-exists-p postinit-file)
    (org-babel-load-file postinit-file)))
#+end_src

* Post post-init config

** GC settings

Set GC parameters here to reset the initial value set in early-init.el.
Also, add measurement of GC time with the code borrowed by https://akrl.sdf.org/#orgc15a10d.

#+begin_src emacs-lisp
(setq garbage-collection-messages nil)
(setq gc-cons-threshold (* 100 1024 1024))

(defmacro my/k-time (&rest body)
  "Measure and return the time it takes evaluating BODY."
  `(let ((time (current-time)))
     ,@body
     (float-time (time-since time))))

(defun my/gc ()
  (message "Garbage Collector has run for %.06fsec"
           (my/k-time (garbage-collect))))

(defvar my/k-gc-timer (run-with-idle-timer 15 t #'my/gc))
(add-function :after after-focus-change-function #'my/gc)
#+end_src

* EOF

#+begin_src emacs-lisp
(provide 'emacs-init)
#+end_src
